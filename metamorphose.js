(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./lua/Lua", "./lua/PackageLib", "./lua/MathLib", "./lua/BaseLib", "./lua/OSLib", "./lua/TableLib", "./lua/StringLib"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Lua_1 = require("./lua/Lua");
    const PackageLib_1 = require("./lua/PackageLib");
    const MathLib_1 = require("./lua/MathLib");
    const BaseLib_1 = require("./lua/BaseLib");
    const OSLib_1 = require("./lua/OSLib");
    const TableLib_1 = require("./lua/TableLib");
    const StringLib_1 = require("./lua/StringLib");
    function trace(s) {
        if (typeof document !== 'undefined' && document) {
            document.write(s.replace(/\n/g, '<br>'));
            document.write('<br>');
        }
        console.log(s);
    }
    var test001 = "n = 99 + (1 * 10) / 2 - 0.5;\n" +
        "if n > 10 then return 'Oh, 真的比10还大哦:'..n end\n" +
        "return n\n";
    var test002 = "return _VERSION";
    var test003 = "return nil";
    var isLoadLib = true;
    //try {
    trace("Start test...");
    var L = new Lua_1.Lua();
    if (isLoadLib) {
        BaseLib_1.BaseLib.open(L);
        PackageLib_1.PackageLib.open(L);
        MathLib_1.MathLib.open(L);
        OSLib_1.OSLib.open(L);
        StringLib_1.StringLib.open(L);
        TableLib_1.TableLib.open(L);
        isLoadLib = false;
    }
    L.setTop(0);
    var status = L.doString(test003);
    if (status != 0) {
        var errObj = L.value(1);
        var tostring = L.getGlobal("tostring");
        L.pushObject(tostring);
        L.pushObject(errObj);
        L.call(1, 1);
        var errObjStr = L.toString_(L.value(-1));
        throw new Error("Error compiling : " + L.value(1));
    }
    else {
        var result = L.value(1);
        var tostring_ = L.getGlobal("tostring");
        L.pushObject(tostring_);
        L.pushObject(result);
        L.call(1, 1); // call BaseLib.tostring = function() {...}
        var resultStr = L.toString_(L.value(-1));
        trace("Result >>> " + resultStr);
    }
});
//} catch (e) {
//    //trace(e.getStackTrace()); //FIXME:
//    trace(e.stack);
//}

},{"./lua/BaseLib":29,"./lua/Lua":45,"./lua/MathLib":53,"./lua/OSLib":54,"./lua/PackageLib":55,"./lua/StringLib":58,"./lua/TableLib":61}],2:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteArray = void 0;
    class ByteArray {
        get length() {
            this.throwError("ByteArray.length not implement");
            return 0;
        }
        constructor() {
            //FIXME:
        }
        clear() {
            //TODO:
            this.throwError("ByteArray.clear() not implement");
        }
        //b:number[]
        writeBytes(b, off, len) {
            //TODO:
            this.throwError("ByteArray.writeBytes() not implement");
        }
        writeByte(x) {
            //TODO:
            this.throwError("ByteArray.writeByte() not implement");
        }
        setByIndex(index, val) {
            this.throwError("ByteArray.setByIndex() not implement");
        }
        writeUTFBytes(x) {
            this.throwError("ByteArray.writeUTFBytes() not implement");
        }
        get(x) {
            this.throwError("ByteArray.get() not implement");
            return 0;
        }
        readUTFBytes(a) {
            this.throwError("ByteArray.readUTFBytes() not implement");
            return "";
        }
        readByte() {
            this.throwError("ByteArray.readByte() not implement");
            return 0;
        }
        throwError(str) {
            console.log(str);
            throw new Error(str);
        }
    }
    exports.ByteArray = ByteArray;
});

},{}],3:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./ByteArray", "./OutputStream"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteArrayOutputStream = void 0;
    const ByteArray_1 = require("./ByteArray");
    const OutputStream_1 = require("./OutputStream");
    class ByteArrayOutputStream extends OutputStream_1.OutputStream {
        constructor() {
            super();
            this._bytes = new ByteArray_1.ByteArray();
        }
        toByteArray() {
            return this._bytes;
        }
        close() {
            this._bytes.clear();
        }
        flush() {
        }
        //FIXME:number[]
        write(b) {
            this._bytes.writeBytes(b);
        }
        //FIXME:number[]
        writeBytes(b, off, len) {
            this._bytes.writeBytes(b, off, len);
        }
        //TODO: 这个方法有待修改
        //Writes a char to the underlying output stream as a 2-byte value, high byte first
        writeChar(b) {
            // var bytes:ByteArray = new ByteArray();
            // bytes.writeMultiByte(String.fromCharCode(b), "");
            // this._bytes.writeBytes(bytes);
            this._bytes.writeByte(b);
        }
    }
    exports.ByteArrayOutputStream = ByteArrayOutputStream;
});

},{"./ByteArray":2,"./OutputStream":19}],4:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Calendar = void 0;
    class Calendar {
        constructor() {
            this._date = null;
        }
        _get(field) {
            switch (field) {
                case Calendar.SECOND:
                    return this._date.getSeconds();
                case Calendar.MINUTE:
                    return this._date.getMinutes();
                case Calendar.HOUR:
                    return this._date.getHours();
                case Calendar.MONTH:
                    return this._date.getMonth();
                case Calendar.YEAR:
                    return this._date.getFullYear();
                case Calendar.DAY_OF_WEEK:
                    console.log("DAY_OF_WEEK not implement");
                    return 0;
                case Calendar.DAY_OF_MONTH:
                    return this._date.getDay();
            }
            console.log("Calendar._get(): field not implement");
            return 0;
        }
        _set(field, value) {
            var _a, _b, _c, _d, _e;
            switch (field) {
                case Calendar.SECOND:
                    (_a = this._date) === null || _a === void 0 ? void 0 : _a.setSeconds(value);
                    return;
                case Calendar.MINUTE:
                    (_b = this._date) === null || _b === void 0 ? void 0 : _b.setMinutes(value);
                    return;
                case Calendar.HOUR:
                    (_c = this._date) === null || _c === void 0 ? void 0 : _c.setHours(value);
                    return;
                case Calendar.MONTH:
                    (_d = this._date) === null || _d === void 0 ? void 0 : _d.setMonth(value);
                    return;
                case Calendar.YEAR:
                    (_e = this._date) === null || _e === void 0 ? void 0 : _e.setFullYear(value);
                    return;
            }
            console.log("Calendar._set(): field not implement");
        }
        static getInstance(tz) {
            return Calendar._instance;
        }
        setTime(d) {
            this._date = d;
        }
        getTime() {
            return this._date;
        }
    }
    exports.Calendar = Calendar;
    Calendar.SECOND = 1;
    Calendar.MINUTE = 2;
    Calendar.HOUR = 3;
    Calendar.DAY_OF_MONTH = 4;
    Calendar.MONTH = 5;
    Calendar.YEAR = 6;
    Calendar.DAY_OF_WEEK = 7;
    Calendar.SUNDAY = 8;
    Calendar.MONDAY = 9;
    Calendar.TUESDAY = 10;
    Calendar.WEDNESDAY = 11;
    Calendar.THURSDAY = 12;
    Calendar.FRIDAY = 13;
    Calendar.SATURDAY = 14;
    Calendar.JANUARY = 15;
    Calendar.FEBRUARY = 16;
    Calendar.MARCH = 17;
    Calendar.APRIL = 18;
    Calendar.MAY = 19;
    Calendar.JUNE = 20;
    Calendar.JULY = 21;
    Calendar.AUGUST = 22;
    Calendar.SEPTEMBER = 23;
    Calendar.OCTOBER = 24;
    Calendar.NOVEMBER = 25;
    Calendar.DECEMBER = 26;
    Calendar._instance = new Calendar();
});

},{}],5:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Character = void 0;
    // 注意：Character.toString用String.fromCharCode()代替
    class Character {
        static isUpperCase(ch) {
            return ch >= 'A'.charCodeAt(0) && ch <= 'Z'.charCodeAt(0);
        }
        static isLowerCase(ch) {
            return ch >= 'a'.charCodeAt(0) && ch <= 'z'.charCodeAt(0);
        }
        static isDigit(ch) {
            return ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0);
        }
        static toLowerCase(ch) {
            return String.fromCharCode(ch).toLowerCase();
        }
    }
    exports.Character = Character;
});

},{}],6:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataOutputStream = void 0;
    /**
     * 数据输出流允许应用程序以适当方式将基本 Java 数据类型写入输出流中。
     * 然后，应用程序可以使用数据输入流将数据读入。
     *
     * 封装构造函数中的OutputStream，而这个类的特点是统计了写入字节数。
     * 实现这个类，基本上只用writeByte处理
     */
    /**
     * 实际传入的是 ByteArrayOutputStream，见StringLib
     */
    class DataOutputStream {
        constructor(writer) {
            this.written = 0;
            this.written = 0;
            this._writer = writer;
        }
        flush() {
            this._writer.flush();
        }
        //FIXME: not used
        size() {
            return this.written;
        }
        //FIXME:number[]
        write(b, off, len) {
            if (off === undefined) {
                off = 0;
            }
            if (len === undefined) {
                len = 0;
            }
            // var bytes = new ByteArray();
            // bytes.writeBytes(b, off, len);
            // this._writer!.write(bytes);
            //this.written += bytes.length;   
            this._writer.writeBytes(b, off, len);
            this.written += len;
        }
        //public write(b:int):void
        //{
        //	
        //}
        writeBoolean(v) {
            this.throwError("DataOutputStream.writeBoolean() not implement");
            // var bytes = new ByteArray();
            // bytes.writeBoolean(v);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        writeByte(v) {
            this.throwError("DataOutputStream.writeByte() not implement");
            // //???
            // //this._writer.writeChar(v);
            // var bytes = new ByteArray();
            // bytes.writeByte(v);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        writeBytes(s) {
            this.throwError("DataOutputStream.writeBytes() not implement");
            // var bytes = new ByteArray();
            // bytes.writeMultiByte(s, "");
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        //TODO: 这个方法有待修改
        writeChar(v) {
            this.throwError("DataOutputStream.writeChar() not implement");
            // var bytes = new ByteArray();
            // bytes.writeMultiByte(String.fromCharCode(v), "");
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        //TODO: 这个方法有待修改
        writeChars(s) {
            this.throwError("DataOutputStream.writeChars() not implement");
            // var bytes = new ByteArray();
            // bytes.writeMultiByte(s, "");
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        writeDouble(v) {
            this.throwError("DataOutputStream.writeDouble() not implement");
            // var bytes = new ByteArray();
            // bytes.writeDouble(v);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        writeFloat(v) {
            this.throwError("DataOutputStream.writeFloat() not implement");
            // var bytes = new ByteArray();
            // bytes.writeFloat(v);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        writeInt(v) {
            this.throwError("DataOutputStream.writeInt() not implement");
            // var bytes = new ByteArray();
            // bytes.writeInt(v);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        //这里可能有问题
        writeLong(v) {
            this.throwError("DataOutputStream.writeLong() not implement");
            // var bytes = new ByteArray();
            // bytes.writeInt(v);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        writeShort(v) {
            this.throwError("DataOutputStream.writeShort() not implement");
            // var bytes = new ByteArray();
            // bytes.writeShort(v);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        writeUTF(str) {
            this.throwError("DataOutputStream.writeUTF() not implement");
            // var bytes = new ByteArray();
            // bytes.writeUTFBytes(str);
            // this._writer.write(bytes);
            // this.written += bytes.length;
        }
        throwError(str) {
            console.log(str);
            throw new Error(str);
        }
    }
    exports.DataOutputStream = DataOutputStream;
});

},{}],7:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EOFException = void 0;
    class EOFException extends Error {
        constructor(str) {
            super();
            if (str === undefined) {
                str = "";
            }
            this.message = str;
            this._stackTrace = new Error(this.message).stack;
        }
        //FIXME: not used
        getStackTrace() {
            //this._stackTrace = new Error(this.message).stack;
            return this._stackTrace;
        }
    }
    exports.EOFException = EOFException;
});

},{}],8:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Enumeration = void 0;
    class Enumeration {
        hasMoreElements() {
            return false;
        }
        nextElement() {
            return null;
        }
    }
    exports.Enumeration = Enumeration;
});

},{}],9:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./HashtableEnum"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hashtable = void 0;
    const HashtableEnum_1 = require("./HashtableEnum");
    class Hashtable {
        constructor(initialCapacity) {
            if (initialCapacity === undefined) {
                initialCapacity = 11;
            }
            //Dictionary支持用Object作为键，而Array会对键进行toString的转换
            this._dic = new Map();
        }
        rehash() {
        }
        keys() {
            var enum_ = new HashtableEnum_1.HashtableEnum();
            var arr = new Array();
            for (var key in this._dic) {
                arr.push(key);
            }
            enum_.setArr(arr);
            return enum_;
        }
        _get(key) {
            //    if (typeof this._dic === 'undefined') {
            //        console.log('here');
            //    }
            return this._dic.get(key);
        }
        put(key, value) {
            //    if (typeof this._dic === 'undefined') {
            //        console.log('here');
            //    }
            var pre = this._dic.get(key);
            this._dic.set(key, value);
            return pre;
        }
        remove(key) {
            var pre = null;
            if (this._dic.get(key)) {
                pre = this._dic.get(key);
                this._dic.set(key, null);
                // delete this._dic[key];
                this._dic.delete(key);
            }
            return pre;
        }
    }
    exports.Hashtable = Hashtable;
});

},{"./HashtableEnum":10}],10:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Enumeration"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashtableEnum = void 0;
    const Enumeration_1 = require("./Enumeration");
    // 注意：这个类不应该由Hashtable以外的类创建
    class HashtableEnum extends Enumeration_1.Enumeration {
        constructor() {
            super();
            this._arr = null;
            this._idx = 0;
            this._len = 0;
            this._arr = null;
            this._idx = 0;
            this._len = 0;
        }
        hasMoreElements() {
            return this._idx < this._len;
        }
        nextElement() {
            return this._arr[this._idx++];
        }
        //注意：仅暴露给Hashtable使用的方法
        setArr(arr) {
            if (arr != null) {
                this._arr = arr;
                this._idx = 0;
                this._len = this._arr.length;
            }
        }
    }
    exports.HashtableEnum = HashtableEnum;
});

},{"./Enumeration":8}],11:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IOException = void 0;
    class IOException extends Error {
        constructor(str) {
            super();
            if (str === undefined) {
                str = "";
            }
            this.message = str;
            this._stackTrace = new Error(this.message).stack;
        }
        //FIXME: not used
        getStackTrace() {
            //this._stackTrace = new Error(this.message).stack;
            return this._stackTrace;
        }
    }
    exports.IOException = IOException;
});

},{}],12:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IllegalArgumentException = void 0;
    class IllegalArgumentException extends Error {
        constructor(str) {
            super();
            if (str === undefined) {
                str = "";
            }
            this.message = str;
            this._stackTrace = new Error(this.message).stack;
        }
        //FIXME: not used
        getStackTrace() {
            //this._stackTrace = new Error(this.message).stack;
            return this._stackTrace;
        }
    }
    exports.IllegalArgumentException = IllegalArgumentException;
});

},{}],13:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputStream = void 0;
    /**
     *
     * 此抽象类是表示字节输入流的所有类的超类。
     * 需要定义 InputStream 的子类的应用程序
     * 必须始终提供返回下一个输入字节的方法。
     *
     */
    class InputStream {
        //FIXME: number[]->ByteArray
        readBytes(b) {
            this.throwError("InputStream.readBytes() not implement");
            return 0;
        }
        // 从输入流读取下一个数据字节。
        read() {
            this.throwError("InputStream.readChar() not implement");
            return 0;
        }
        reset() {
            this.throwError("InputStream.reset() not implement");
        }
        mark(readahead) {
            this.throwError("InputStream.mark() not implement");
        }
        markSupported() {
            this.throwError("InputStream.markSupported() not implement");
            return false;
        }
        close() {
            this.throwError("InputStream.close() not implement");
        }
        available() {
            this.throwError("InputStream.available() not implement");
            return 0;
        }
        skip(n) {
            this.throwError("InputStream.skip() not implement");
            return 0;
        }
        readMultiBytes(bytes, off, len) {
            this.throwError("InputStream.readBytes() not implement");
            return 0;
        }
        throwError(str) {
            console.log(str);
            throw new Error(str);
        }
    }
    exports.InputStream = InputStream;
});

},{}],14:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Reader"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputStreamReader = void 0;
    const Reader_1 = require("./Reader");
    /**
     *	用于读取字符流的抽象类。
     *	子类必须实现的方法只有 read(char[], int, int) 和 close()。
     *	但是，多数子类将重写此处定义的一些方法，
     *	以提供更高的效率和/或其他功能。
     */
    /**
     *  InputStreamReader 是字节流通向字符流的桥梁：
     * 	它使用指定的 charset 读取字节并将其解码为字符。
     * 	它使用的字符集可以由名称指定或显式给定，
     * 	否则可能接受平台默认的字符集。
     * 	每次调用 InputStreamReader 中的一个 read() 方法都会导致从基础输入流读取一个或多个字节。
     * 	要启用从字节到字符的有效转换，可以提前从基础流读取更多的字节，
     * 	使其超过满足当前读取操作所需的字节。
     * 	为了达到最高效率，可要考虑在 BufferedReader 内包装 InputStreamReader。
     */
    //见LuaInternal，创建一个带字符集（UTF8）的读出器
    //i可能是DumpedInput
    //charsetName可能是"UTF8"
    class InputStreamReader extends Reader_1.Reader {
        constructor(i, charsetName) {
            super();
            this._i = i;
            this._charsetName = charsetName;
        }
        close() {
            this._i.close();
        }
        mark(readAheadLimit) {
            this._i.mark(readAheadLimit);
        }
        markSupported() {
            return this._i.markSupported();
        }
        read() {
            return this._i.read();
        }
        readBytes(cbuf) {
            return this._i.readBytes(cbuf);
        }
        //本工程未使用
        readMultiBytes(cbuf, off, len) {
            return this._i.readMultiBytes(cbuf, off, len);
        }
        //TODO:?
        ready() {
            return true;
        }
        reset() {
            this._i.reset();
        }
        // 本工程未使用
        skip(n) {
            return this._i.skip(n);
        }
    }
    exports.InputStreamReader = InputStreamReader;
});

},{"./Reader":22}],15:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MathUtil = void 0;
    //see http://codesnipp.it/code/939
    class MathUtil {
        // 弧度转换为角度
        // convert radians to degrees  
        static toDegrees(rad) {
            return (rad / 180 * Math.PI);
        }
        // convert degrees to radians  
        // 角度转换为弧度
        static toRadians(deg) {
            return (deg * Math.PI / 180);
        }
    }
    exports.MathUtil = MathUtil;
});

},{}],16:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullPointerException = void 0;
    class NullPointerException extends Error {
        constructor(str) {
            super();
            if (str === undefined) {
                str = "";
            }
            this.message = str;
            this._stackTrace = new Error(this.message).stack;
        }
        //FIXME: not used
        getStackTrace() {
            //this._stackTrace = new Error(this.message).stack;
            return this._stackTrace;
        }
    }
    exports.NullPointerException = NullPointerException;
});

},{}],17:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumberFormatException = void 0;
    class NumberFormatException extends Error {
        constructor(str) {
            super();
            if (str === undefined) {
                str = "";
            }
            this.message = str;
            this._stackTrace = new Error(this.message).stack;
        }
        //FIXME: not used
        getStackTrace() {
            //this._stackTrace = new Error(this.message).stack;
            return this._stackTrace;
        }
    }
    exports.NumberFormatException = NumberFormatException;
});

},{}],18:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfMemoryError = void 0;
    class OutOfMemoryError extends Error {
        constructor(str) {
            super();
            if (str === undefined) {
                str = "";
            }
            this.message = str;
            this._stackTrace = new Error(this.message).stack;
        }
        //FIXME: not used
        getStackTrace() {
            //this._stackTrace = new Error(this.message).stack;
            return this._stackTrace;
        }
    }
    exports.OutOfMemoryError = OutOfMemoryError;
});

},{}],19:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputStream = void 0;
    /**
     * 此抽象类是表示输出字节流的所有类的超类。
     * 输出流接受输出字节并将这些字节发送到某个接收器。
     * 需要定义 OutputStream 子类的应用程序必须始终提供
     * 至少一种可写入一个输出字节的方法。
     *
     * 这个类不应该实例化
     * 略加修改，让所有写方法都可以返回写入字节数
     */
    class OutputStream {
        constructor() {
        }
        //FIXME: not used
        close() {
            this.throwError("OutputStream.close() not implement");
        }
        //FIXME: not used
        flush() {
            this.throwError("OutputStream.flush() not implement");
        }
        //FIXME: not used //FIXME:
        write(b) {
            this.throwError("OutputStream.write() not implement");
        }
        //FIXME: not used //number[]
        writeBytes(b, off, len) {
            this.throwError("OutputStream.writeBytes() not implement");
        }
        //FIXME: not used
        writeChar(b) {
            this.throwError("OutputStream.writeChar() not implement");
        }
        //FIXME: not used
        throwError(str) {
            console.log(str);
            throw new Error(str);
        }
    }
    exports.OutputStream = OutputStream;
});

},{}],20:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrintStream = void 0;
    class PrintStream {
        constructor() {
            PrintStream.init();
        }
        static init() {
            PrintStream.OutputArr = new Array();
            PrintStream.OutputArr.push("");
        }
        //TODO:
        print(str) {
            PrintStream.OutputArr[PrintStream.OutputArr.length - 1] += str;
            console.log(str);
        }
        //TODO:
        println() {
            PrintStream.OutputArr.push("");
            console.log("\n");
        }
    }
    exports.PrintStream = PrintStream;
    PrintStream.OutputArr = null;
});

},{}],21:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Random = void 0;
    class Random {
        nextDouble() {
            return Math.random();
        }
        nextInt(i) {
            return Math.floor(Math.random() * i);
        }
        setSeed(seed) {
        }
    }
    exports.Random = Random;
});

},{}],22:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = void 0;
    /**
     *	用于读取字符流的抽象类。
     *	子类必须实现的方法只有 read(char[], int, int) 和 close()。
     *	但是，多数子类将重写此处定义的一些方法，
     *	以提供更高的效率和/或其他功能。
     */
    class Reader {
        close() {
            this.throwError("Reader.close() not implement");
        }
        mark(readahead) {
            this.throwError("Reader.mark() not implement");
        }
        markSupported() {
            this.throwError("Reader.markSupported() not implement");
            return false;
        }
        read() {
            this.throwError("Reader.read() not implement");
            return 0;
        }
        //FIXME: not used //FIXME:number[]
        readBytes(cbuf) {
            this.throwError("Reader.readBytes() not implement");
            return 0;
        }
        readMultiBytes(cbuf, off, len) {
            this.throwError("Reader.readMultiBytes() not implement");
            return 0;
        }
        //FIXME: not used
        ready() {
            this.throwError("Reader.ready() not implement");
            return false;
        }
        reset() {
            this.throwError("Reader.reset() not implement");
        }
        //FIXME:not used
        skip(n) {
            this.throwError("Reader.skip() not implement");
            return 0;
        }
        // 新增
        throwError(str) {
            console.log(str);
            throw new Error(str);
        }
    }
    exports.Reader = Reader;
});

},{}],23:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Runtime = void 0;
    class Runtime {
        static getRuntime() {
            return Runtime._instance;
        }
        totalMemory() {
            return 0; //FIXME:
        }
        freeMemory() {
            console.log("Runtime.freeMemory() not implement");
            return 0;
        }
    }
    exports.Runtime = Runtime;
    Runtime._instance = new Runtime();
});

},{}],24:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuntimeException = void 0;
    class RuntimeException extends Error {
        constructor(str) {
            super();
            if (str === undefined) {
                str = "";
            }
            this.message = str;
            this._stackTrace = new Error(str).stack;
        }
        //FIXME: not used
        getStackTrace() {
            //this._stackTrace = new Error(this.message).stack;
            return this._stackTrace;
        }
    }
    exports.RuntimeException = RuntimeException;
});

},{}],25:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stack = void 0;
    /**
     * Stack 类表示后进先出（LIFO）的对象堆栈。
     * 它通过五个操作对类 Vector 进行了扩展 ，
     * 允许将向量视为堆栈。
     * 它提供了通常的 push 和 pop 操作，
     * 以及取栈顶点的 peek 方法、
     * 测试堆栈是否为空的 empty 方法、
     * 在堆栈中查找项并确定到栈顶距离的 search 方法。
     * 首次创建堆栈时，它不包含数据项。
     *
     * 在Java中Stack继承Vector，需要注意转换问题。
     */
    class Stack {
        constructor() {
            this._arr = new Array();
            this.size = 0;
        }
        /**
         *  相当于push
         */
        addElement(o) {
            this._arr.push(o);
        }
        lastElement() {
            var len = this._arr.length;
            if (len > 0) {
                //trace("lastElement:", this._arr[len - 1]);
                return this._arr[len - 1];
            }
            return null;
        }
        //FIXME:not used
        getSize() {
            return this._arr.length;
        }
        //FIXME:not used
        /**
         * 设置此向量的大小。
         * ]如果新大小大于当前大小，则会在向量的末尾添加相应数量的 null 项。
         * 如果新大小小于当前大小，
         * 则丢弃索引 newSize 处及其之后的所有项。
         */
        //TODO:
        setSize(size) {
            var i;
            var len = this._arr.length;
            if (size >= 0) {
                if (size > len) {
                    for (i = 0; i < size - len; i++) {
                        //this._arr.push(new Object());
                        this._arr.push(null);
                    }
                }
                else {
                    for (i = 0; i < len - size; i++) {
                        this._arr.pop();
                    }
                }
            }
        }
        pop() {
            var obj = this._arr.pop();
            return obj;
        }
        elementAt(i) {
            var obj = this._arr[i];
            return obj;
        }
    }
    exports.Stack = Stack;
});

},{}],26:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringBuffer = void 0;
    class StringBuffer {
        constructor(str) {
            if (str === undefined) {
                str = "";
            }
            this._str = str;
        }
        //并不创建任何字符，只是预留空间
        init(i) {
        }
        //主要用于清空长度，一般为0
        setLength(i) {
            if (i == 0) {
                this._str = "";
            }
            else if (i > 0) {
                this._str = this._str.substr(0, i);
            }
            else {
                throw new Error("StringBuffer.setLength() error: i < 0");
            }
        }
        toString() {
            return this._str;
        }
        append(ch) {
            this._str = this._str.concat(String.fromCharCode(ch));
        }
        appendStringBuffer(buf) {
            this._str = this._str.concat(buf._str);
        }
        appendString(str) {
            this._str = this._str.concat(str);
        }
        /**
         * 移除此序列的子字符串中的字符。该子字符串从指定的 start 处开始，
         * 一直到索引 end - 1 处的字符，如果不存在这种字符，则一直到序列尾部。
         * 如果 start 等于 end，则不发生任何更改。
         *
         * delete在Java中不是关键字，但在AS3中是关键字
         */
        _delete(start, end) {
            //console.log("StringBuffer._delete(" + start + "," + end + ")");
            if (end > this._str.length) {
                end = this._str.length; //end可能是个过大的数
            }
            if (0 <= start && start < end && end <= this._str.length) {
                this._str = this._str.substring(0, start) +
                    this._str.substring(end);
                return this;
            }
            else {
                throw new Error("StringBuffer.delete() error");
            }
        }
        insert(at, ch) {
            this._str = this._str.substring(0, at) +
                String(ch) +
                this._str.substring(at);
        }
        insertStringBuffer(at, buf) {
            this._str = this._str.substring(0, at) +
                buf._str +
                this._str.substring(at);
        }
        length() {
            return this._str.length;
        }
        charAt(index) {
            return this._str.charCodeAt(index);
        }
        deleteCharAt(index) {
            return this._delete(index, index + 1);
        }
    }
    exports.StringBuffer = StringBuffer;
});

},{}],27:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./PrintStream"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemUtil = void 0;
    const PrintStream_1 = require("./PrintStream");
    class SystemUtil {
        static arraycopy(src, srcPos, dest, destPos, length) {
            if (src != null && dest != null && src instanceof Array && dest instanceof Array) {
                for (var i = destPos; i < destPos + length; i++) {
                    dest[i] = src[i];
                    //console.log("arraycopy:", i, (src as Array)[i]); 
                }
            }
        }
        static gc() {
        }
        static identityHashCode(obj) {
            return 0;
        }
        static getResourceAsStream(s) {
            return null;
        }
        static currentTimeMillis() {
            return 0;
        }
    }
    exports.SystemUtil = SystemUtil;
    SystemUtil.out = new PrintStream_1.PrintStream();
});

},{"./PrintStream":20}],28:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeZone = void 0;
    class TimeZone {
        constructor() {
            this._id = null;
            this._id = null;
        }
        //Flash自动调整夏令时
        useDaylightTime() {
            return true;
        }
        //获取本地时间
        static getDefault() {
            if (TimeZone.tz._id == null)
                TimeZone.tz._id = "default";
            return TimeZone.tz;
        }
        //获取GMT时间
        static getTimeZone(ID) {
            if (ID != "GMT") {
                console.log("TimeZone.getTimeZone(): not support name");
                throw new Error("TimeZone.getTimeZone(): not support name");
                //return TimeZone.tz; //FIXME:
            }
            if (TimeZone.tzGMT._id == null)
                TimeZone.tzGMT._id = "GMT";
            return TimeZone.tzGMT;
        }
        //时区字符串
        getID() {
            return this._id;
        }
    }
    exports.TimeZone = TimeZone;
    TimeZone.tz = new TimeZone();
    TimeZone.tzGMT = new TimeZone();
});

},{}],29:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/NumberFormatException", "../java/SystemUtil", "./BaseLibReader", "./DumpedInput", "./Lua", "./LuaJavaCallback"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseLib = void 0;
    const NumberFormatException_1 = require("../java/NumberFormatException");
    const SystemUtil_1 = require("../java/SystemUtil");
    const BaseLibReader_1 = require("./BaseLibReader");
    const DumpedInput_1 = require("./DumpedInput");
    const Lua_1 = require("./Lua");
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/BaseLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Contains Lua's base library.  The base library is generally
     * considered essential for running any Lua program.  The base library
     * can be opened using the {@link #open} method.
     */
    class BaseLib extends LuaJavaCallback_1.LuaJavaCallback {
        /** Constructs instance, filling in the 'which' member. */
        constructor(which) {
            super();
            /**
            * For wrapped threads created by coroutine.wrap, this references the
            * Lua thread object.
            */
            this.thread = null;
            this.which = which;
            BaseLib.OutputArr = new Array();
            BaseLib.OutputArr.push("");
        }
        /** Instance constructor used by coroutine.wrap. */
        init(L) {
            this.which = BaseLib.WRAP_AUX;
            this.thread = L;
        }
        /**
         * Implements all of the functions in the Lua base library.  Do not
         * call directly.
         * @param L  the Lua state in which to execute.
         * @return number of returned parameters, as per convention.
         */
        luaFunction(L) {
            switch (this.which) {
                case BaseLib.ASSERT:
                    return BaseLib.assertFunction(L);
                case BaseLib.COLLECTGARBAGE:
                    return BaseLib.collectgarbage(L);
                case BaseLib.DOFILE:
                    return BaseLib.dofile(L);
                case BaseLib.ERROR:
                    return BaseLib.error(L);
                case BaseLib.GETFENV:
                    return BaseLib.getfenv(L);
                case BaseLib.GETMETATABLE:
                    return BaseLib.getmetatable(L);
                case BaseLib.IPAIRS:
                    return BaseLib.ipairs(L);
                case BaseLib.LOAD:
                    return BaseLib.load(L);
                case BaseLib.LOADFILE:
                    return BaseLib.loadfile(L);
                case BaseLib.LOADSTRING:
                    return BaseLib.loadstring(L);
                case BaseLib.NEXT:
                    return BaseLib.next(L);
                case BaseLib.PAIRS:
                    return BaseLib.pairs(L);
                case BaseLib.PCALL:
                    return BaseLib.pcall(L);
                case BaseLib.PRINT:
                    return BaseLib.print(L);
                case BaseLib.RAWEQUAL:
                    return BaseLib.rawequal(L);
                case BaseLib.RAWGET:
                    return BaseLib.rawget(L);
                case BaseLib.RAWSET:
                    return BaseLib.rawset(L);
                case BaseLib.SELECT:
                    return BaseLib.select(L);
                case BaseLib.SETFENV:
                    return BaseLib.setfenv(L);
                case BaseLib.SETMETATABLE:
                    return BaseLib.setmetatable(L);
                case BaseLib.TONUMBER:
                    return BaseLib.tonumber(L);
                case BaseLib.TOSTRING:
                    return BaseLib.tostring(L);
                case BaseLib.TYPE:
                    return BaseLib.type(L);
                case BaseLib.UNPACK:
                    return BaseLib.unpack(L);
                case BaseLib.XPCALL:
                    return BaseLib.xpcall(L);
                case BaseLib.IPAIRS_AUX:
                    return BaseLib.ipairsaux(L);
                case BaseLib.PAIRS_AUX:
                    return BaseLib.pairsaux(L);
                case BaseLib.CREATE:
                    return BaseLib.create(L);
                case BaseLib.RESUME:
                    return BaseLib.resume(L);
                case BaseLib.RUNNING:
                    return BaseLib.running(L);
                case BaseLib.STATUS:
                    return BaseLib.status(L);
                case BaseLib.WRAP:
                    return BaseLib.wrap(L);
                case BaseLib.YIELD:
                    return BaseLib.yield(L);
                case BaseLib.WRAP_AUX:
                    return this.wrapaux(L);
            }
            return 0;
        }
        /**
         * Opens the base library into the given Lua state.  This registers
         * the symbols of the base library in the global table.
         * @param L  The Lua state into which to open.
         */
        static open(L) {
            // set global _G
            L.setGlobal("_G", L.getGlobals());
            // set global _VERSION
            L.setGlobal("_VERSION", Lua_1.Lua.VERSION);
            BaseLib.r(L, "assert", BaseLib.ASSERT);
            BaseLib.r(L, "collectgarbage", BaseLib.COLLECTGARBAGE);
            BaseLib.r(L, "dofile", BaseLib.DOFILE);
            BaseLib.r(L, "error", BaseLib.ERROR);
            BaseLib.r(L, "getfenv", BaseLib.GETFENV);
            BaseLib.r(L, "getmetatable", BaseLib.GETMETATABLE);
            BaseLib.r(L, "ipairs", BaseLib.IPAIRS);
            BaseLib.r(L, "loadfile", BaseLib.LOADFILE);
            BaseLib.r(L, "load", BaseLib.LOAD);
            BaseLib.r(L, "loadstring", BaseLib.LOADSTRING);
            BaseLib.r(L, "next", BaseLib.NEXT);
            BaseLib.r(L, "pairs", BaseLib.PAIRS);
            BaseLib.r(L, "pcall", BaseLib.PCALL);
            BaseLib.r(L, "print", BaseLib.PRINT);
            BaseLib.r(L, "rawequal", BaseLib.RAWEQUAL);
            BaseLib.r(L, "rawget", BaseLib.RAWGET);
            BaseLib.r(L, "rawset", BaseLib.RAWSET);
            BaseLib.r(L, "select", BaseLib.SELECT);
            BaseLib.r(L, "setfenv", BaseLib.SETFENV);
            BaseLib.r(L, "setmetatable", BaseLib.SETMETATABLE);
            BaseLib.r(L, "tonumber", BaseLib.TONUMBER);
            BaseLib.r(L, "tostring", BaseLib.TOSTRING);
            BaseLib.r(L, "type", BaseLib.TYPE);
            BaseLib.r(L, "unpack", BaseLib.UNPACK);
            BaseLib.r(L, "xpcall", BaseLib.XPCALL);
            L.__register("coroutine");
            BaseLib.c(L, "create", BaseLib.CREATE);
            BaseLib.c(L, "resume", BaseLib.RESUME);
            BaseLib.c(L, "running", BaseLib.RUNNING);
            BaseLib.c(L, "status", BaseLib.STATUS);
            BaseLib.c(L, "wrap", BaseLib.WRAP);
            BaseLib.c(L, "yield", BaseLib.YIELD);
        }
        /** Register a function. */
        static r(L, name, which) {
            var f = new BaseLib(which);
            L.setGlobal(name, f);
        }
        /** Register a function in the coroutine table. */
        static c(L, name, which) {
            var f = new BaseLib(which);
            L.setField(L.getGlobal("coroutine"), name, f);
        }
        /** Implements assert.  <code>assert</code> is a keyword in some
         * versions of Java, so this function has a mangled name.
         */
        static assertFunction(L) {
            L.checkAny(1);
            if (!L.toBoolean(L.value(1))) {
                L.error(L.optString(2, "assertion failed!"));
            }
            return L.getTop();
        }
        /** Implements collectgarbage. */
        static collectgarbage(L) {
            var o = L.checkOption(1, "collect", BaseLib.CGOPTS);
            var ex = L.optInt(2, 0);
            var res = L.gc(BaseLib.CGOPTSNUM[o], ex);
            switch (BaseLib.CGOPTSNUM[o]) {
                case Lua_1.Lua.GCCOUNT:
                    {
                        var b = L.gc(Lua_1.Lua.GCCOUNTB, 0);
                        L.pushNumber(res + b / 1024);
                        return 1;
                    }
                case Lua_1.Lua.GCSTEP:
                    L.pushBoolean(res != 0);
                    return 1;
                default:
                    L.pushNumber(res);
                    return 1;
            }
        }
        /** Implements dofile. */
        static dofile(L) {
            var fname = L.optString(1, null);
            var n = L.getTop();
            if (L.loadFile(fname) != 0) {
                L.error(L.value(-1));
            }
            L.call(0, Lua_1.Lua.MULTRET);
            return L.getTop() - n;
        }
        /** Implements error. */
        static error(L) {
            var level = L.optInt(2, 1);
            L.setTop(1);
            if (Lua_1.Lua.isString(L.value(1)) && level > 0) {
                L.insert(L.where(level), 1);
                L.concat(2);
            }
            L.error(L.value(1));
            // NOTREACHED
            return 0;
        }
        /** Helper for getfenv and setfenv. */
        static getfunc(L) {
            var o = L.value(1);
            if (Lua_1.Lua.isFunction(o)) {
                return o;
            }
            else {
                var level = L.optInt(1, 1);
                L.argCheck(level >= 0, 1, "level must be non-negative");
                var ar = L.getStack(level);
                if (ar == null) {
                    L.argError(1, "invalid level");
                }
                L.getInfo("f", ar);
                o = L.value(-1);
                if (Lua_1.Lua.isNil(o)) {
                    L.error("no function environment for tail call at level " + level);
                }
                L.pop(1);
                return o;
            }
        }
        /** Implements getfenv. */
        static getfenv(L) {
            var o = BaseLib.getfunc(L);
            if (Lua_1.Lua.isJavaFunction(o)) {
                L.pushObject(L.getGlobals());
            }
            else {
                var f = o;
                L.pushObject(f.env);
            }
            return 1;
        }
        /** Implements getmetatable. */
        static getmetatable(L) {
            L.checkAny(1);
            var mt = L.getMetatable(L.value(1));
            if (mt == null) {
                L.pushNil();
                return 1;
            }
            var protectedmt = L.getMetafield(L.value(1), "__metatable");
            if (Lua_1.Lua.isNil(protectedmt)) {
                L.pushObject(mt); // return metatable
            }
            else {
                L.pushObject(protectedmt); // return __metatable field
            }
            return 1;
        }
        /** Implements load. */
        static load(L) {
            var cname = L.optString(2, "=(load)");
            L.checkType(1, Lua_1.Lua.TFUNCTION);
            var r = new BaseLibReader_1.BaseLibReader(L, L.value(1));
            var status;
            status = L.__load(r, cname);
            return BaseLib.load_aux(L, status);
        }
        /** Implements loadfile. */
        static loadfile(L) {
            var fname = L.optString(1, null);
            return BaseLib.load_aux(L, L.loadFile(fname));
        }
        /** Implements loadstring. */
        static loadstring(L) {
            var s = L.checkString(1);
            var chunkname = L.optString(2, s);
            if (s.substr(0, 1) == "0x1B") //"\033")
             {
                // "binary" dumped into string using string.dump.
                return BaseLib.load_aux(L, L.load(new DumpedInput_1.DumpedInput(s), chunkname));
            }
            else {
                return BaseLib.load_aux(L, L.loadString(s, chunkname));
            }
        }
        static load_aux(L, status) {
            if (status == 0) // OK?
             {
                return 1;
            }
            else {
                L.insert(Lua_1.Lua.NIL, -1); // put before error message
                return 2; // return nil plus error message
            }
        }
        /** Implements next. */
        static next(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            L.setTop(2); // Create a 2nd argument is there isn't one
            if (L.next(1)) {
                return 2;
            }
            L.pushObject(Lua_1.Lua.NIL);
            return 1;
        }
        /** Implements ipairs. */
        static ipairs(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            L.pushObject(BaseLib.IPAIRS_AUX_FUN);
            L.pushValue(1);
            L.pushNumber(0);
            return 3;
        }
        /** Generator for ipairs. */
        static ipairsaux(L) {
            var i = L.checkInt(2);
            L.checkType(1, Lua_1.Lua.TTABLE);
            ++i;
            var v = Lua_1.Lua.rawGetI(L.value(1), i);
            if (Lua_1.Lua.isNil(v)) {
                return 0;
            }
            L.pushNumber(i);
            L.pushObject(v);
            return 2;
        }
        /** Implements pairs.  PUC-Rio uses "next" as the generator for pairs.
         * Jill doesn't do that because it would be way too slow.  We use the
         * {@link java.util.Enumeration} returned from
         * {@link java.util.Hashtable#keys}.  The {@link #pairsaux} method
         * implements the step-by-step iteration.
         */
        static pairs(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            L.pushObject(BaseLib.PAIRS_AUX_FUN); // return generator,
            var t = L.value(1);
            L.pushObject([t, t.keys()]); //TODO:   				 // state,
            L.pushObject(Lua_1.Lua.NIL); // and initial value.
            return 3;
        }
        /** Generator for pairs.  This expects a <var>state</var> and
         * <var>var</var> as (Lua) arguments.
         * The state is setup by {@link #pairs} and is a
         * pair of {LuaTable, Enumeration} stored in a 2-element array.  The
         * <var>var</var> is not used.  This is in contrast to the PUC-Rio
         * implementation, where the state is the table, and the var is used
         * to generated the next key in sequence.  The implementation, of
         * pairs and pairsaux, has no control over <var>var</var>,  Lua's
         * semantics of <code>for</code> force it to be the previous result
         * returned by this function.  In Jill this value is not suitable to
         * use for enumeration, which is why it isn't used.
         */
        static pairsaux(L) {
            var a = L.value(1); //(Object[])
            var t = a[0];
            var e = a[1];
            if (!e.hasMoreElements()) {
                return 0;
            }
            var key = e.nextElement();
            L.pushObject(key);
            L.pushObject(t.getlua(key));
            return 2;
        }
        /** Implements pcall. */
        static pcall(L) {
            L.checkAny(1);
            var status = L.pcall(L.getTop() - 1, Lua_1.Lua.MULTRET, null);
            var b = (status == 0);
            L.insert(Lua_1.Lua.valueOfBoolean(b), 1);
            return L.getTop();
        }
        /** Implements print. */
        static print(L) {
            var n = L.getTop();
            var tostring = L.getGlobal("tostring");
            for (var i = 1; i <= n; ++i) {
                L.pushObject(tostring);
                L.pushValue(i);
                L.call(1, 1);
                var s = L.toString_(L.value(-1));
                if (s == null) {
                    return L.error("'tostring' must return a string to 'print'");
                }
                if (i > 1) {
                    this.OutputArr[this.OutputArr.length - 1] += "\t";
                    this.OUT.print('\t');
                }
                this.OutputArr[this.OutputArr.length - 1] += s;
                this.OUT.print(s);
                L.pop(1);
            }
            this.OutputArr.push("");
            this.OUT.println();
            return 0;
        }
        /** Implements rawequal. */
        static rawequal(L) {
            L.checkAny(1);
            L.checkAny(2);
            L.pushBoolean(Lua_1.Lua.rawEqual(L.value(1), L.value(2)));
            return 1;
        }
        /** Implements rawget. */
        static rawget(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            L.checkAny(2);
            L.pushObject(Lua_1.Lua.rawGet(L.value(1), L.value(2)));
            return 1;
        }
        /** Implements rawset. */
        static rawset(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            L.checkAny(2);
            L.checkAny(3);
            L.rawSet(L.value(1), L.value(2), L.value(3));
            return 0;
        }
        /** Implements select. */
        static select(L) {
            var n = L.getTop();
            if (L.type(1) == Lua_1.Lua.TSTRING && "#" == L.toString_(L.value(1))) {
                L.pushNumber(n - 1);
                return 1;
            }
            var i = L.checkInt(1);
            if (i < 0) {
                i = n + i;
            }
            else if (i > n) {
                i = n;
            }
            L.argCheck(1 <= i, 1, "index out of range");
            return n - i;
        }
        /** Implements setfenv. */
        static setfenv(L) {
            L.checkType(2, Lua_1.Lua.TTABLE);
            var o = BaseLib.getfunc(L);
            var first = L.value(1);
            if (Lua_1.Lua.isNumber(first) && L.toNumber(first) == 0) {
                // :todo: change environment of current thread.
                return 0;
            }
            else if (Lua_1.Lua.isJavaFunction(o) || !L.setFenv(o, L.value(2))) {
                L.error("'setfenv' cannot change environment of given object");
            }
            L.pushObject(o);
            return 1;
        }
        /** Implements setmetatable. */
        static setmetatable(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            var t = L.type(2);
            L.argCheck(t == Lua_1.Lua.TNIL || t == Lua_1.Lua.TTABLE, 2, "nil or table expected");
            if (!Lua_1.Lua.isNil(L.getMetafield(L.value(1), "__metatable"))) {
                L.error("cannot change a protected metatable");
            }
            L.setMetatable(L.value(1), L.value(2));
            L.setTop(1);
            return 1;
        }
        /** Implements tonumber. */
        static tonumber(L) {
            var base = L.optInt(2, 10);
            if (base == 10) // standard conversion
             {
                L.checkAny(1);
                var o = L.value(1);
                if (Lua_1.Lua.isNumber(o)) {
                    L.pushNumber(L.toNumber(o));
                    return 1;
                }
            }
            else {
                var s = L.checkString(1);
                L.argCheck(2 <= base && base <= 36, 2, "base out of range");
                // :todo: consider stripping space and sharing some code with
                // Lua.vmTostring
                try {
                    var i = parseInt(s); //Integer.parseInt(s, base); //TODO:
                    L.pushNumber(i);
                    return 1;
                }
                catch (e_) {
                    if (e_ instanceof NumberFormatException_1.NumberFormatException) {
                        console.log(e_.stack);
                    }
                }
            }
            L.pushObject(Lua_1.Lua.NIL);
            return 1;
        }
        /** Implements tostring. */
        static tostring(L) {
            L.checkAny(1);
            var o = L.value(1);
            if (L.callMeta(1, "__tostring")) // is there a metafield?
             {
                return 1; // use its value
            }
            switch (L.type(1)) {
                case Lua_1.Lua.TNUMBER:
                    L.pushString(L.toString_(o));
                    break;
                case Lua_1.Lua.TSTRING:
                    L.pushObject(o);
                    break;
                case Lua_1.Lua.TBOOLEAN:
                    if (L.toBoolean(o)) {
                        L.pushLiteral("true");
                    }
                    else {
                        L.pushLiteral("false");
                    }
                    break;
                case Lua_1.Lua.TNIL:
                    L.pushLiteral("nil");
                    break;
                default:
                    L.pushString(o.toString());
                    break;
            }
            return 1;
        }
        /** Implements type. */
        static type(L) {
            L.checkAny(1);
            L.pushString(L.typeNameOfIndex(1));
            return 1;
        }
        /** Implements unpack. */
        static unpack(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            var t = L.value(1);
            var i = L.optInt(2, 1);
            var e = L.optInt(3, t.getn());
            var n = e - i + 1; // number of elements
            if (n <= 0) {
                return 0; // empty range
            }
            // i already initialised to start index, which isn't necessarily 1
            for (; i <= e; ++i) {
                L.pushObject(t.getnum(i));
            }
            return n;
        }
        /** Implements xpcall. */
        static xpcall(L) {
            L.checkAny(2);
            var errfunc = L.value(2);
            L.setTop(1); // remove error function from stack
            var status = L.pcall(0, Lua_1.Lua.MULTRET, errfunc);
            L.insert(Lua_1.Lua.valueOfBoolean(status == 0), 1);
            return L.getTop(); // return status + all results
        }
        /** Implements coroutine.create. */
        static create(L) {
            var NL = L.newThread();
            var faso = L.value(1);
            L.argCheck(Lua_1.Lua.isFunction(faso) && !Lua_1.Lua.isJavaFunction(faso), 1, "Lua function expected");
            L.setTop(1); // function is at top
            L.xmove(NL, 1); // move function from L to NL
            L.pushObject(NL);
            return 1;
        }
        /** Implements coroutine.resume. */
        static resume(L) {
            var co = L.toThread(L.value(1));
            L.argCheck(co != null, 1, "coroutine expected");
            var r = BaseLib.auxresume(L, co, L.getTop() - 1);
            if (r < 0) {
                L.insert(Lua_1.Lua.valueOfBoolean(false), -1);
                return 2; // return false + error message
            }
            L.insert(Lua_1.Lua.valueOfBoolean(true), L.getTop() - (r - 1));
            return r + 1; // return true + 'resume' returns
        }
        /** Implements coroutine.running. */
        static running(L) {
            if (L.isMain()) {
                return 0; // main thread is not a coroutine
            }
            L.pushObject(L);
            return 1;
        }
        /** Implements coroutine.status. */
        static status(L) {
            var co = L.toThread(L.value(1));
            L.argCheck(co != null, 1, "coroutine expected");
            if (L == co) {
                L.pushLiteral("running");
            }
            else {
                switch (co.status) {
                    case Lua_1.Lua.YIELD:
                        L.pushLiteral("suspended");
                        break;
                    case 0:
                        {
                            var ar = co.getStack(0);
                            if (ar != null) // does it have frames?
                             {
                                L.pushLiteral("normal"); // it is running
                            }
                            else if (co.getTop() == 0) {
                                L.pushLiteral("dead");
                            }
                            else {
                                L.pushLiteral("suspended"); // initial state
                            }
                        }
                        break;
                    default: // some error occured
                        L.pushLiteral("dead");
                }
            }
            return 1;
        }
        /** Implements coroutine.wrap. */
        static wrap(L) {
            BaseLib.create(L);
            L.pushObject(BaseLib.wrapit(L.toThread(L.value(-1))));
            return 1;
        }
        /** Helper for wrap.  Returns a LuaJavaCallback that has access to the
         * Lua thread.
         * @param L the Lua thread to be wrapped.
         */
        static wrapit(L) {
            var lib = new BaseLib(0);
            lib.init(L);
            return lib;
        }
        /** Helper for wrap.  This implements the function returned by wrap. */
        wrapaux(L) {
            var co = this.thread;
            var r = BaseLib.auxresume(L, co, L.getTop());
            if (r < 0) {
                if (Lua_1.Lua.isString(L.value(-1))) // error object is a string?
                 {
                    var w = L.where(1);
                    L.insert(w, -1);
                    L.concat(2);
                }
                L.error(L.value(-1)); // propagate error
            }
            return r;
        }
        static auxresume(L, co, narg) {
            // if (!co.checkStack...
            if (co.status == 0 && co.getTop() == 0) {
                L.pushLiteral("cannot resume dead coroutine");
                return -1; // error flag;
            }
            L.xmove(co, narg);
            var status = co.resume(narg);
            if (status == 0 || status == Lua_1.Lua.YIELD) {
                var nres = co.getTop();
                // if (!L.checkStack...
                co.xmove(L, nres); // move yielded values
                return nres;
            }
            co.xmove(L, 1); // move error message
            return -1; // error flag;
        }
        /** Implements coroutine.yield. */
        static yield(L) {
            return L.yield(L.getTop());
        }
    }
    exports.BaseLib = BaseLib;
    // :todo: consider making the enums contiguous so that the compiler
    // uses the compact and faster form of switch.
    // Each function in the base library corresponds to an instance of
    // this class which is associated (the 'which' member) with an integer
    // which is unique within this class.  They are taken from the following
    // set.
    BaseLib.ASSERT = 1;
    BaseLib.COLLECTGARBAGE = 2;
    BaseLib.DOFILE = 3;
    BaseLib.ERROR = 4;
    // private static const GCINFO:int = 5;
    BaseLib.GETFENV = 6;
    BaseLib.GETMETATABLE = 7;
    BaseLib.LOADFILE = 8;
    BaseLib.LOAD = 9;
    BaseLib.LOADSTRING = 10;
    BaseLib.NEXT = 11;
    BaseLib.PCALL = 12;
    BaseLib.PRINT = 13;
    BaseLib.RAWEQUAL = 14;
    BaseLib.RAWGET = 15;
    BaseLib.RAWSET = 16;
    BaseLib.SELECT = 17;
    BaseLib.SETFENV = 18;
    BaseLib.SETMETATABLE = 19;
    BaseLib.TONUMBER = 20;
    BaseLib.TOSTRING = 21;
    BaseLib.TYPE = 22;
    BaseLib.UNPACK = 23;
    BaseLib.XPCALL = 24;
    BaseLib.IPAIRS = 25;
    BaseLib.PAIRS = 26;
    BaseLib.IPAIRS_AUX = 27;
    BaseLib.PAIRS_AUX = 28;
    // The coroutine functions (which reside in the table "coroutine") are also
    // part of the base library.
    BaseLib.CREATE = 50;
    BaseLib.RESUME = 51;
    BaseLib.RUNNING = 52;
    BaseLib.STATUS = 53;
    BaseLib.WRAP = 54;
    BaseLib.YIELD = 55;
    BaseLib.WRAP_AUX = 56;
    /**
    * Lua value that represents the generator function for ipairs.  In
    * PUC-Rio this is implemented as an upvalue of ipairs.
    */
    BaseLib.IPAIRS_AUX_FUN = new BaseLib(BaseLib.IPAIRS_AUX);
    /**
    * Lua value that represents the generator function for pairs.  In
    * PUC-Rio this is implemented as an upvalue of pairs.
    */
    BaseLib.PAIRS_AUX_FUN = new BaseLib(BaseLib.PAIRS_AUX);
    /** Used by {@link #collectgarbage}. */
    BaseLib.CGOPTS = [
        "stop", "restart", "collect",
        "count", "step", "setpause", "setstepmul"
    ];
    /** Used by {@link #collectgarbage}. */
    BaseLib.CGOPTSNUM = [
        Lua_1.Lua.GCSTOP, Lua_1.Lua.GCRESTART, Lua_1.Lua.GCCOLLECT,
        Lua_1.Lua.GCCOUNT, Lua_1.Lua.GCSTEP, Lua_1.Lua.GCSETPAUSE, Lua_1.Lua.GCSETSTEPMUL
    ];
    /**
     * The {@link PrintStream} used by print.  Makes it more convenient if
     * redirection is desired.  For example, client code could implement
     * their own instance which sent output to the screen of a JME device.
     */
    BaseLib.OUT = SystemUtil_1.SystemUtil.out;
});

},{"../java/NumberFormatException":17,"../java/SystemUtil":27,"./BaseLibReader":30,"./DumpedInput":36,"./Lua":45,"./LuaJavaCallback":49}],30:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/IOException", "../java/Reader", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseLibReader = void 0;
    const IOException_1 = require("../java/IOException");
    const Reader_1 = require("../java/Reader");
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/BaseLibReader.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Extends {@link java.io.Reader} to create a Reader from a Lua
     * function.  So that the <code>load</code> function from Lua's base
     * library can be implemented.
     */
    class BaseLibReader extends Reader_1.Reader {
        constructor(L, f) {
            super();
            this._s = "";
            this._i = 0; // = 0;
            this._mark = -1;
            this._L = L;
            this._f = f;
        }
        close() {
            this._f = null;
        }
        mark(l) {
            if (l > 1) {
                throw new IOException_1.IOException("Readahead must be <= 1");
            }
            this._mark = this._i;
        }
        markSupported() {
            return true;
        }
        read() {
            if (this._i >= this._s.length) {
                this._L.pushObject(this._f);
                this._L.call(0, 1);
                if (Lua_1.Lua.isNil(this._L.value(-1))) {
                    return -1;
                }
                else if (Lua_1.Lua.isString(this._L.value(-1))) {
                    this._s = this._L.toString_(this._L.value(-1));
                    if (this._s.length == 0) {
                        return -1;
                    }
                    if (this._mark == this._i) {
                        this._mark = 0;
                    }
                    else {
                        this._mark = -1;
                    }
                    this._i = 0;
                }
                else {
                    this._L.error("reader function must return a string");
                }
            }
            return this._s.charCodeAt(this._i++);
        }
        readMultiBytes(cbuf, off, len) {
            var j = 0; // loop index required after loop
            for (j = 0; j < len; ++j) {
                var c = this.read();
                if (c == -1) {
                    if (j == 0) {
                        return -1;
                    }
                    else {
                        return j;
                    }
                }
                cbuf[off + j] = c;
            }
            return j;
        }
        reset() {
            if (this._mark < 0) {
                throw new IOException_1.IOException("reset() not supported now");
            }
            this._i = this._mark;
        }
    }
    exports.BaseLibReader = BaseLibReader;
});

},{"../java/IOException":11,"../java/Reader":22,"./Lua":45}],31:[function(require,module,exports){
/*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/BlockCnt.java#1 $
 * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockCnt = void 0;
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /*
    ** nodes for block list (list of active blocks)
    */
    class BlockCnt {
        constructor() {
            this.previous = null; /* chain */
            this.breaklist = 0; /* list of jumps out of this loop */
            this.nactvar = 0; /* # active locals outside the breakable structure */
            this.upval = false; /* true if some variable in the block is an upvalue */
            this.isbreakable = false; /* true if `block' is a loop */
        }
    }
    exports.BlockCnt = BlockCnt;
});

},{}],32:[function(require,module,exports){
/*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/CallInfo.java#1 $
 * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallInfo = void 0;
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class CallInfo {
        /** Only used to create the first instance. */
        constructor() {
            this._savedpc = 0;
            this._func = 0;
            this._base = 0;
            this._top = 0;
            this._nresults = 0;
            this._tailcalls = 0;
        }
        /**
         * @param func  stack index of function
         * @param base  stack base for this frame
         * @param top   top-of-stack for this frame
         * @param nresults  number of results expected by caller
         */
        init(func, base, top, nresults) {
            this._func = func;
            this._base = base;
            this._top = top;
            this._nresults = nresults;
        }
        /** Setter for savedpc. */
        set savedpc(pc) {
            this._savedpc = pc;
        }
        /** Getter for savedpc. */
        get savedpc() {
            return this._savedpc;
        }
        /**
         * Get the stack index for the function object for this record.
         */
        get func() {
            return this._func;
        }
        /**
         * Get stack index where results should end up.  This is an absolute
         * stack index, not relative to L.base.
         */
        res() {
            // Same location as function.
            return this._func;
        }
        /**
         * Get stack base for this record.
         */
        get base() {
            return this._base;
        }
        /**
         * Get top-of-stack for this record.  This is the number of elements
         * in the stack (or will be when the function is resumed).
         */
        get top() {
            return this._top;
        }
        /**
         * Setter for top.
         */
        set top(top) {
            this._top = top;
        }
        /**
         * Get number of results expected by the caller of this function.
         * Used to adjust the returned results to the correct number.
         */
        get nresults() {
            return this._nresults;
        }
        /**
         * Get number of tailcalls
         */
        get tailcalls() {
            return this._tailcalls;
        }
        /**
         * Used during tailcall to set the base and top members.
         */
        tailcall(baseArg, topArg) {
            this._base = baseArg;
            this._top = topArg;
            ++this._tailcalls;
        }
    }
    exports.CallInfo = CallInfo;
});

},{}],33:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Expdesc"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsControl = void 0;
    const Expdesc_1 = require("./Expdesc");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Syntax.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class ConsControl {
        constructor(t) {
            this.v = new Expdesc_1.Expdesc(); /* last list item read */
            this.nh = 0; /* total number of `record' elements */
            this.na = 0; /* total number of array elements */
            this.tostore = 0; /* number of array elements pending to be stored */
            this.t = t;
        }
    }
    exports.ConsControl = ConsControl;
});

},{"./Expdesc":38}],34:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Debug = void 0;
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Debug.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Equivalent to struct lua_Debug.  This implementation is incomplete
     * because it is not intended to form part of the public API.  It has
     * only been implemented to the extent necessary for internal use.
     */
    class Debug {
        /**
         * @param ici  index of CallInfo record in L.civ
         */
        constructor(ici) {
            // private, no public accessors defined.
            this._ici = 0;
            // public accessors may be defined for these.
            this._event = 0;
            this._what = null;
            this._source = null;
            this._currentline = 0;
            this._linedefined = 0;
            this._lastlinedefined = 0;
            this._shortsrc = null;
            this._ici = ici;
        }
        set ici(ici) {
            this._ici = ici;
        }
        /**
         * Get ici, index of the {@link CallInfo} record.
         */
        get ici() {
            return this._ici;
        }
        /**
         * Setter for event.
         */
        set event(event) {
            this._event = event;
        }
        /**
         * Sets the what field.
         */
        set what(what) {
            this._what = what;
        }
        /**
         * Sets the source, and the shortsrc.
         */
        set source(source) {
            this._source = source;
            this._shortsrc = Lua_1.Lua.oChunkid(source);
        }
        /**
         * Gets the current line.  May become public.
         */
        get currentline() {
            return this._currentline;
        }
        /**
         * Set currentline.
         */
        set currentline(currentline) {
            this._currentline = currentline;
        }
        /**
         * Get linedefined.
         */
        get linedefined() {
            return this._linedefined;
        }
        /**
         * Set linedefined.
         */
        set linedefined(linedefined) {
            this._linedefined = linedefined;
        }
        /**
         * Set lastlinedefined.
         */
        set lastlinedefined(lastlinedefined) {
            this._lastlinedefined = lastlinedefined;
        }
        /**
         * Gets the "printable" version of source, for error messages.
         * May become public.
         */
        get shortsrc() {
            return this._shortsrc;
        }
    }
    exports.Debug = Debug;
});

},{"./Lua":45}],35:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/ByteArray", "./Loader", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DumpState = void 0;
    const ByteArray_1 = require("../java/ByteArray");
    const Loader_1 = require("./Loader");
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/BlockCnt.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class DumpState {
        constructor(writer, strip) {
            this._writer = writer;
            this._strip = strip;
        }
        //////////////// dumper ////////////////////
        DumpHeader() {
            /*
                * In order to make the code more compact the dumper re-uses the
                * header defined in Loader.java.  It has to fix the endianness byte
                * first.
                */
            Loader_1.Loader.HEADER[6] = 0;
            //TODO:Java to AS3
            var b = new ByteArray_1.ByteArray();
            var len = Loader_1.Loader.HEADER.length;
            for (var i = 0; i < len; ++i) {
                b.writeByte(Loader_1.Loader.HEADER[i]);
            }
            this._writer.write(b);
        }
        DumpInt(i) {
            this._writer.writeInt(i); // big-endian
        }
        DumpNumber(d) {
            this._writer.writeDouble(d); // big-endian
        }
        DumpFunction(f, p) {
            this.DumpString((f.source == p || this._strip) ? null : f.source);
            this.DumpInt(f.linedefined);
            this.DumpInt(f.lastlinedefined);
            this._writer.writeByte(f.nups);
            this._writer.writeByte(f.numparams);
            this._writer.writeBoolean(f.isVararg);
            this._writer.writeByte(f.maxstacksize);
            this.DumpCode(f);
            this.DumpConstants(f);
            this.DumpDebug(f);
        }
        DumpCode(f) {
            var n = f.sizecode;
            var code = f.code; //int [] 
            this.DumpInt(n);
            for (var i = 0; i < n; i++)
                this.DumpInt(code[i]);
        }
        DumpConstants(f) {
            var n = f.sizek;
            var k = f.k; //Slot[]
            this.DumpInt(n);
            for (var i = 0; i < n; i++) {
                var o = k[i].r;
                if (o == Lua_1.Lua.NIL) {
                    this._writer.writeByte(Lua_1.Lua.TNIL);
                }
                else if (typeof (o) == "boolean") {
                    this._writer.writeByte(Lua_1.Lua.TBOOLEAN);
                    this._writer.writeBoolean(o);
                }
                else if (o == Lua_1.Lua.NUMBER) {
                    this._writer.writeByte(Lua_1.Lua.TNUMBER);
                    this.DumpNumber(k[i].d);
                }
                else if (typeof (o) == "string") {
                    this._writer.writeByte(Lua_1.Lua.TSTRING);
                    this.DumpString(o);
                }
                else {
                    //# assert false
                }
            }
            n = f.sizep;
            this.DumpInt(n);
            for (i = 0; i < n; i++) {
                var subfunc = f.p[i];
                this.DumpFunction(subfunc, f.source);
            }
        }
        DumpString(s) {
            if (s == null) {
                this.DumpInt(0);
            }
            else {
                /*
                    * Strings are dumped by converting to UTF-8 encoding.  The MIDP
                    * 2.0 spec guarantees that this encoding will be supported (see
                    * page 9 of midp-2_0-fr-spec.pdf).  Nonetheless, any
                    * possible UnsupportedEncodingException is left to be thrown
                    * (it's a subclass of IOException which is declared to be thrown).
                    */
                //TODO: Java to AS3
                var contents = new ByteArray_1.ByteArray(); // s.getBytes("UTF-8"); //byte []
                contents.writeUTFBytes(s);
                var size = contents.length;
                this.DumpInt(size + 1);
                this._writer.write(contents, 0, size);
                this._writer.writeByte(0);
            }
        }
        DumpDebug(f) {
            if (this._strip) {
                this.DumpInt(0);
                this.DumpInt(0);
                this.DumpInt(0);
                return;
            }
            var n = f.sizelineinfo;
            this.DumpInt(n);
            for (var i = 0; i < n; i++)
                this.DumpInt(f.lineinfo[i]);
            n = f.sizelocvars;
            this.DumpInt(n);
            for (i = 0; i < n; i++) {
                var locvar = f.locvars[i];
                this.DumpString(locvar.varname);
                this.DumpInt(locvar.startpc);
                this.DumpInt(locvar.endpc);
            }
            n = f.sizeupvalues;
            this.DumpInt(n);
            for (i = 0; i < n; i++)
                this.DumpString(f.upvalues[i]);
        }
        //新增
        get writer() {
            return this._writer;
        }
    }
    exports.DumpState = DumpState;
});

},{"../java/ByteArray":2,"./Loader":43,"./Lua":45}],36:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/InputStream"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DumpedInput = void 0;
    const InputStream_1 = require("../java/InputStream");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/DumpedInput.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Converts a string obtained using string.dump into an
     * {@link java.io.InputStream} so that it can be passed to {@link
     * Lua#load(java.io.InputStream, java.lang.String)}.
     */
    class DumpedInput extends InputStream_1.InputStream {
        constructor(s) {
            super();
            this._i = 0; // = 0
            this._mark = -1;
            this._s = s;
        }
        available() {
            return this._s.length - this._i;
        }
        close() {
            this._s = null;
            this._i = -1;
        }
        mark(readlimit) {
            this._mark = this._i;
        }
        markSupported() {
            return true;
        }
        read() {
            if (this._i >= this._s.length) {
                return -1;
            }
            var c = this._s.charCodeAt(this._i);
            ++this._i;
            return c & 0xff;
        }
        reset() {
            this._i = this._mark;
        }
        skip(n) {
            console.log("DumpedInput.skip() not implement");
            return 0;
        }
    }
    exports.DumpedInput = DumpedInput;
});

},{"../java/InputStream":13}],37:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Enum = void 0;
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Syntax.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class Enum {
        constructor(t, e) {
            this._i = 0; // = 0
            this._t = t;
            this._e = e;
            this.inci();
        }
        /**
        * Increments {@link #i} until it either exceeds
        * <code>t.sizeArray</code> or indexes a non-nil element.
        */
        inci() {
            while (this._i < this._t.sizeArray && this._t.array[this._i] == Lua_1.Lua.NIL) {
                ++this._i;
            }
        }
        hasMoreElements() {
            if (this._i < this._t.sizeArray) {
                return true;
            }
            return this._e.hasMoreElements();
        }
        nextElement() {
            var r;
            if (this._i < this._t.sizeArray) {
                ++this._i; // array index i corresponds to key i+1
                r = new Number(this._i);
                this.inci();
            }
            else {
                r = this._e.nextElement();
            }
            return r;
        }
    }
    exports.Enum = Enum;
});

},{"./Lua":45}],38:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./FuncState"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Expdesc = void 0;
    const FuncState_1 = require("./FuncState");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Expdesc.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /** Equivalent to struct expdesc. */
    class Expdesc extends Object {
        //TODO:
        constructor() {
            super();
            this._k = 0; // one of V* enums above
            this._info = 0;
            this._aux = 0;
            this._nval = 0;
            this._t = 0;
            this._f = 0;
        }
        //public function Expdesc(k:int, i:int):void
        //{
        //init(k, i);
        //}
        /** Equivalent to init_exp from lparser.c */
        init(kind, i) {
            this._t = FuncState_1.FuncState.NO_JUMP;
            this._f = FuncState_1.FuncState.NO_JUMP;
            this._k = kind;
            this._info = i;
        }
        copy(e) {
            // Must initialise all members of this.
            this._k = e._k;
            this._info = e._info;
            this._aux = e._aux;
            this._nval = e._nval;
            this._t = e._t;
            this._f = e._f;
        }
        get kind() {
            return this._k;
        }
        set kind(kind) {
            this._k = kind;
        }
        get k() {
            return this._k;
        }
        set k(kind) {
            this._k = kind;
        }
        get info() {
            return this._info;
        }
        set info(i) {
            this._info = i;
        }
        get aux() {
            return this._aux;
        }
        set aux(aux) {
            this._aux = aux;
        }
        get nval() {
            return this._nval;
        }
        set nval(d) {
            this._nval = d;
        }
        /** Equivalent to hasmultret from lparser.c */
        hasmultret() {
            return this._k == Expdesc.VCALL || this._k == Expdesc.VVARARG;
        }
        /** Equivalent to hasjumps from lcode.c. */
        hasjumps() {
            return this._t != this._f;
        }
        nonreloc(i) {
            this._k = Expdesc.VNONRELOC;
            this._info = i;
        }
        reloc(i) {
            this._k = Expdesc.VRELOCABLE;
            this._info = i;
        }
        upval(i) {
            this._k = Expdesc.VUPVAL;
            this._info = i;
        }
        //新增
        get f() {
            return this._f;
        }
        //新增
        set f(f) {
            this._f = f;
        }
        //新增
        get t() {
            return this._t;
        }
        //新增
        set t(t) {
            this._t = t;
        }
    }
    exports.Expdesc = Expdesc;
    Expdesc.VVOID = 0; // no value
    Expdesc.VNIL = 1;
    Expdesc.VTRUE = 2;
    Expdesc.VFALSE = 3;
    Expdesc.VK = 4; // info = index into 'k'
    Expdesc.VKNUM = 5; // nval = numerical value
    Expdesc.VLOCAL = 6; // info = local register
    Expdesc.VUPVAL = 7; // info = index into 'upvalues'
    Expdesc.VGLOBAL = 8; // info = index of table;
    // aux = index of global name in 'k'
    Expdesc.VINDEXED = 9; // info = table register
    // aux = index register (or 'k')
    Expdesc.VJMP = 10; // info = instruction pc
    Expdesc.VRELOCABLE = 11; // info = instruction pc
    Expdesc.VNONRELOC = 12; // info = result register
    Expdesc.VCALL = 13; // info = instruction pc
    Expdesc.VVARARG = 14; // info = instruction pc
});

},{"./FuncState":41}],39:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/StringBuffer", "../java/Character", "../java/NumberFormatException", "./Lua", "./Syntax"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FormatItem = void 0;
    const StringBuffer_1 = require("../java/StringBuffer");
    const Character_1 = require("../java/Character");
    const NumberFormatException_1 = require("../java/NumberFormatException");
    const Lua_1 = require("./Lua");
    const Syntax_1 = require("./Syntax");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/StringLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class FormatItem {
        /**
         * Parse a format item (starting from after the <code>L_ESC</code>).
         * If you promise that there won't be any format errors, then
         * <var>L</var> can be <code>null</code>.
         */
        constructor(L, s) {
            this._left = false; // '-' flag
            this._sign = false; // '+' flag
            this._space = false; // ' ' flag
            this._alt = false; // '#' flag
            this._zero = false; // '0' flag
            this._width = 0; // minimum field width
            this._precision = -1; // precision, -1 when no precision specified.
            this._type = 0; // the type of the conversion
            this._length = 0; // length of the format item in the format string.
            this._L = L;
            var i = 0;
            var l = s.length;
            // parse flags
            flag: while (true) {
                if (i >= l)
                    L.error("invalid format");
                switch (s.charAt(i)) {
                    case '-':
                        this._left = true;
                        break;
                    case '+':
                        this._sign = true;
                        break;
                    case ' ':
                        this._space = true;
                        break;
                    case '#':
                        this._alt = true;
                        break;
                    case '0':
                        this._zero = true;
                        break;
                    default:
                        break flag;
                }
                ++i;
            } /* flag */
            // parse width
            var widths = i; // index of start of width specifier
            while (true) {
                if (i >= l)
                    this._L.error("invalid format");
                if (Syntax_1.Syntax.isdigit(s.charCodeAt(i))) //TODO:
                    ++i;
                else
                    break;
            }
            if (widths < i) {
                try {
                    this._width = parseInt(s.substring(widths, i)); //TODO:
                }
                catch (e_) {
                    if (e_ instanceof Error) {
                        console.log(e_.stack);
                    }
                }
            }
            // parse precision
            if (s.charAt(i) == '.') {
                ++i;
                var precisions = i; // index of start of precision specifier
                while (true) {
                    if (i >= l)
                        L.error("invalid format");
                    if (Syntax_1.Syntax.isdigit(s.charCodeAt(i))) //TODO:
                        ++i;
                    else
                        break;
                }
                if (precisions < i) {
                    try {
                        this._precision = parseInt(s.substring(precisions, i)); //TODO:
                    }
                    catch (e_) {
                        if (e_ instanceof NumberFormatException_1.NumberFormatException) {
                            console.log(e_.stack);
                        }
                    }
                }
            }
            switch (s.charAt(i)) {
                case 'c':
                case 'd':
                case 'i':
                case 'o':
                case 'u':
                case 'x':
                case 'X':
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G':
                case 'q':
                case 's':
                    this._type = s.charCodeAt(i);
                    length = i + 1;
                    return;
            }
            this._L.error("invalid option to 'format'");
        }
        get length() {
            return this._length;
        }
        set length(length) {
            this._length = length;
        }
        get type() {
            return this._type;
        }
        set type(type) {
            this._type = type;
        }
        /**
         * Format the converted string according to width, and left.
         * zero padding is handled in either {@link FormatItem#formatInteger}
         * or {@link FormatItem#formatFloat}
         * (and width is fixed to 0 in such cases).  Therefore we can ignore
         * zero.
         */
        format(b, s) {
            var l = s.length;
            if (l >= this._width) {
                b.appendString(s);
                return;
            }
            var pad = new StringBuffer_1.StringBuffer();
            while (l < this._width) {
                pad.append(' '.charCodeAt(0));
                ++l;
            }
            if (this._left) {
                b.appendString(s);
                b.appendStringBuffer(pad);
            }
            else {
                b.appendStringBuffer(pad);
                b.appendString(s);
            }
        }
        // All the format* methods take a StringBuffer and append the
        // formatted representation of the value to it.
        // Sadly after a format* method has been invoked the object is left in
        // an unusable state and should not be used again.
        formatChar(b, c) {
            var s = String.fromCharCode(c); //TODO:
            this.format(b, s);
        }
        formatInteger(b, i) {
            // :todo: improve inefficient use of implicit StringBuffer
            if (this._left)
                this._zero = false;
            if (this._precision >= 0)
                this._zero = false;
            var radix = 10;
            switch (String.fromCharCode(this.type)) {
                case 'o':
                    radix = 8;
                    break;
                case 'd':
                case 'i':
                case 'u':
                    radix = 10;
                    break;
                case 'x':
                case 'X':
                    radix = 16;
                    break;
                default:
                    this._L.error("invalid format");
            }
            var s = i.toString(radix); //Long.toString(i, radix);
            if (this._type == 'X'.charCodeAt(0))
                s = s.toUpperCase();
            if (this._precision == 0 && s == "0")
                s = "";
            // form a prefix by strippping possible leading '-',
            // pad to precision,
            // add prefix,
            // pad to width.
            // extra wart: padding with '0' is implemented using precision
            // because this makes handling the prefix easier.
            var prefix = "";
            if (s.substr(0, 1) == "-") {
                prefix = "-";
                s = s.substring(1);
            }
            if (this._alt && radix == 16)
                prefix = "0x";
            if (prefix == "") {
                if (this._sign)
                    prefix = "+";
                else if (this._space)
                    prefix = " ";
            }
            if (this._alt && radix == 8 && s.substr(0, 1) != "0")
                s = "0" + s;
            var l = s.length;
            if (this._zero) {
                this._precision = this._width - prefix.length;
                this._width = 0;
            }
            if (l < this._precision) {
                var p = new StringBuffer_1.StringBuffer();
                while (l < this._precision) {
                    p.append('0'.charCodeAt(0));
                    ++l;
                }
                p.appendString(s);
                s = p.toString();
            }
            s = prefix + s;
            this.format(b, s);
        }
        formatFloat(b, d) {
            switch (String.fromCharCode(this._type)) {
                case 'g':
                case 'G':
                    this.formatFloatG(b, d);
                    return;
                case 'f':
                    this.formatFloatF(b, d);
                    return;
                case 'e':
                case 'E':
                    this.formatFloatE(b, d);
                    return;
            }
        }
        formatFloatE(b, d) {
            var s = this.formatFloatRawE(d);
            this.format(b, s);
        }
        /**
         * Returns the formatted string for the number without any padding
         * (which can be added by invoking {@link FormatItem#format} later).
         */
        formatFloatRawE(d) {
            var m = Math.abs(d);
            var offset = 0;
            if (m >= 1e-3 && m < 1e7) {
                d *= 1e10;
                offset = 10;
            }
            //FIXME:如果使用toPrecision会消除掉中间的e指数符号
            var s = d.toPrecision(this._precision); //String(d); //FIXME:整数转浮点问题
            var t = new StringBuffer_1.StringBuffer(s);
            var e; // Exponent value
            if (d == 0) {
                e = 0;
            }
            else {
                var ei = s.indexOf('E');
                e = parseInt(s.substring(ei + 1));
                t._delete(ei, Number.MAX_SAFE_INTEGER); //TODO:
            }
            this.precisionTrim(t);
            e -= offset;
            if (Character_1.Character.isLowerCase(this.type)) {
                t.append(FormatItem.E_LOWER);
            }
            else {
                t.append(FormatItem.E_UPPER);
            }
            if (e >= 0) {
                t.append('+'.charCodeAt(0));
            }
            t.appendString(String(e)); //TODO:
            this.zeroPad(t);
            return t.toString();
        }
        formatFloatF(b, d) {
            var s = this.formatFloatRawF(d);
            this.format(b, s);
        }
        /**
         * Returns the formatted string for the number without any padding
         * (which can be added by invoking {@link FormatItem#format} later).
         */
        formatFloatRawF(d) {
            //toPrecision
            var s = d.toPrecision(this._precision); //String(d); //FIXME:整数转字符串会丢失小数点后1位精度
            if (d % 1 === 0) {
                s = d.toFixed(1);
            }
            var t = new StringBuffer_1.StringBuffer(s);
            var di = s.indexOf('.');
            var ei = s.indexOf('E');
            if (ei >= 0) {
                t._delete(ei, Number.MAX_SAFE_INTEGER); //TODO:
                var e = parseInt(s.substring(ei + 1));
                var z = new StringBuffer_1.StringBuffer();
                for (var i = 0; i < Math.abs(e); ++i) {
                    z.append('0'.charCodeAt(0));
                }
                if (e > 0) {
                    t.deleteCharAt(di);
                    t.appendStringBuffer(z);
                    t.insert(di + e, '.'.charCodeAt(0));
                }
                else {
                    t.deleteCharAt(di);
                    var at = t.charAt(0) == '-'.charCodeAt(0) ? 1 : 0;
                    t.insertStringBuffer(at, z);
                    t.insert(di, '.'.charCodeAt(0));
                }
            }
            this.precisionTrim(t);
            this.zeroPad(t);
            return t.toString();
        }
        formatFloatG(b, d) {
            if (this._precision == 0) {
                this._precision = 1;
            }
            if (this._precision < 0) {
                this._precision = 6;
            }
            var s;
            // Decide whether to use %e or %f style.
            var m = Math.abs(d);
            if (m == 0) {
                // :todo: Could test for -0 and use "-0" appropriately.
                s = "0";
            }
            else if (m < 1e-4 || m >= Lua_1.Lua.iNumpow(10, this._precision)) {
                // %e style
                --this._precision;
                s = this.formatFloatRawE(d);
                var di = s.indexOf('.');
                if (di >= 0) {
                    // Trim trailing zeroes from fractional part
                    var ei = s.indexOf('E');
                    if (ei < 0) {
                        ei = s.indexOf('e');
                    }
                    var i = ei - 1;
                    while (s.charAt(i) == '0') {
                        --i;
                    }
                    if (s.charAt(i) != '.') {
                        ++i;
                    }
                    var a = new StringBuffer_1.StringBuffer(s);
                    a._delete(i, ei); //TODO:
                    s = a.toString();
                }
            }
            else {
                // %f style
                // For %g precision specifies the number of significant digits,
                // for %f precision specifies the number of fractional digits.
                // There is a problem because it's not obvious how many fractional
                // digits to format, it could be more than precision
                // (when .0001 <= m < 1) or it could be less than precision
                // (when m >= 1).
                // Instead of trying to work out the correct precision to use for
                // %f formatting we use a worse case to get at least all the
                // necessary digits, then we trim using string editing.  The worst
                // case is that 3 zeroes come after the decimal point before there
                // are any significant digits.
                // Save the required number of significant digits
                var required = this._precision;
                this._precision += 3;
                s = this.formatFloatRawF(d);
                var fsd = 0; // First Significant Digit
                while (s.charAt(fsd) == '0' || s.charAt(fsd) == '.') {
                    ++fsd;
                }
                // Note that all the digits to the left of the decimal point in
                // the formatted number are required digits (either significant
                // when m >= 1 or 0 when m < 1).  We know this because otherwise 
                // m >= (10**precision) and so formatting falls under the %e case.
                // That means that we can always trim the string at fsd+required
                // (this will remove the decimal point when m >=
                // (10**(precision-1)).
                var a2 = new StringBuffer_1.StringBuffer(s);
                a2._delete(fsd + required, Number.MAX_SAFE_INTEGER); //TODO:
                if (s.indexOf('.') < a2.length()) {
                    // Trim trailing zeroes
                    var i2 = a2.length() - 1;
                    while (a2.charAt(i2) == '0'.charCodeAt(0)) {
                        a2.deleteCharAt(i2);
                        --i2;
                    }
                    if (a2.charAt(i2) == '.'.charCodeAt(0)) {
                        a2.deleteCharAt(i2);
                    }
                }
                s = a2.toString();
            }
            this.format(b, s);
        }
        formatString(b, s) {
            var p = s;
            if (this._precision >= 0 && this._precision < s.length) {
                p = s.substring(0, this._precision);
            }
            this.format(b, p);
        }
        precisionTrim(t) {
            if (this._precision < 0) {
                this._precision = 6;
            }
            var s = t.toString();
            var di = s.indexOf('.');
            var l = t.length();
            if (0 == this._precision) {
                t._delete(di, Number.MAX_SAFE_INTEGER); //TODO:
            }
            else if (l > di + this._precision) {
                t._delete(di + this._precision + 1, Number.MAX_SAFE_INTEGER); //TODO:
            }
            else {
                for (; l <= di + this._precision; ++l) {
                    t.append('0'.charCodeAt(0));
                }
            }
        }
        zeroPad(t) {
            if (this._zero && t.length() < this._width) {
                var at = t.charAt(0) == '-'.charCodeAt(0) ? 1 : 0;
                while (t.length() < this._width) {
                    t.insert(at, '0'.charCodeAt(0));
                }
            }
        }
    }
    exports.FormatItem = FormatItem;
    /**
     * Character used in formatted output when %e or %g format is used.
     */
    FormatItem.E_LOWER = 'E'.charCodeAt(0);
    /**
     * Character used in formatted output when %E or %G format is used.
     */
    FormatItem.E_UPPER = 'E'.charCodeAt(0);
});

},{"../java/Character":5,"../java/NumberFormatException":17,"../java/StringBuffer":26,"./Lua":45,"./Syntax":60}],40:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/InputStream"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FromReader = void 0;
    const InputStream_1 = require("../java/InputStream");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/FromReader.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Takes a {@link Reader} and converts to an {@link InputStream} by
     * reversing the transformation performed by <code>string.dump</code>.
     * Similar to {@link DumpedInput} which does the same job for {@link
     * String}.  This class is used by {@link BaseLib}'s load in order to
     * load binary chunks.
     */
    class FromReader extends InputStream_1.InputStream {
        constructor(reader) {
            super();
            this._reader = reader;
        }
        mark(readahead) {
            this._reader.mark(readahead);
        }
        reset() {
            this._reader.reset();
        }
        read() {
            var c = this._reader.read();
            if (c == -1) {
                return c;
            }
            return c & 0xff;
        }
    }
    exports.FromReader = FromReader;
});

},{"../java/InputStream":13}],41:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/Hashtable", "../java/IllegalArgumentException", "./Expdesc", "./Lua", "./Proto", "./Syntax"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FuncState = void 0;
    const Hashtable_1 = require("../java/Hashtable");
    const IllegalArgumentException_1 = require("../java/IllegalArgumentException");
    const Expdesc_1 = require("./Expdesc");
    const Lua_1 = require("./Lua");
    const Proto_1 = require("./Proto");
    const Syntax_1 = require("./Syntax");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/FuncState.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Used to model a function during compilation.  Code generation uses
     * this structure extensively.  Most of the PUC-Rio functions from
     * lcode.c have moved into this class, alongwith a few functions from
     * lparser.c
     */
    class FuncState {
        /**
         * Constructor.  Much of this is taken from <code>open_func</code> in
         * <code>lparser.c</code>.
         */
        constructor(ls) {
            /**
            * Table to find (and reuse) elements in <var>f.k</var>.  Maps from
            * Object (a constant Lua value) to an index into <var>f.k</var>.
            */
            this._h = new Hashtable_1.Hashtable();
            /** Enclosing function. */
            this._prev = null;
            /** chain of current blocks */
            this._bl = null; // = null;
            /** next position to code. */
            this._pc = 0; // = 0;
            /** pc of last jump target. */
            this._lasttarget = -1;
            /** List of pending jumps to <var>pc</var>. */
            this._jpc = FuncState.NO_JUMP;
            /** First free register. */
            this._freereg = 0; // = 0;
            /** number of elements in <var>k</var>. */
            this._nk = 0; // = 0;
            /** number of elements in <var>p</var>. */
            this._np = 0; // = 0;
            /** number of elements in <var>locvars</var>. */
            this._nlocvars = 0; // = 0;
            /** number of active local variables. */
            this._nactvar = 0; // = 0;
            /** upvalues as 8-bit k and 8-bit info */
            this._upvalues = new Array(Lua_1.Lua.MAXUPVALUES); //int [] 
            /** declared-variable stack. */
            this._actvar = new Array(Lua_1.Lua.MAXVARS); //short[] 
            this._f = new Proto_1.Proto();
            this._f.init2(ls.source, 2); // default value for maxstacksize=2
            this._L = ls.L;
            this._ls = ls;
            //    prev = ls.linkfs(this);
        }
        /** Equivalent to <code>close_func</code> from <code>lparser.c</code>. */
        close() {
            this._f.closeCode(this._pc);
            this._f.closeLineinfo(this._pc);
            this._f.closeK(this._nk);
            this._f.closeP(this._np);
            this._f.closeLocvars(this._nlocvars);
            this._f.closeUpvalues();
            var checks = this._L.gCheckcode(this._f);
            //# assert checks
            //# assert bl == null
        }
        /** Equivalent to getlocvar from lparser.c.
        * Accesses <code>LocVar</code>s of the {@link Proto}.
        */
        getlocvar(idx) {
            return this._f.locvars[this._actvar[idx]];
        }
        // Functions from lcode.c
        /** Equivalent to luaK_checkstack. */
        kCheckstack(n) {
            var newstack = this._freereg + n;
            if (newstack > this._f.maxstacksize) {
                if (newstack >= Lua_1.Lua.MAXSTACK) {
                    this._ls.xSyntaxerror("function or expression too complex");
                }
                this._f.maxstacksize = newstack;
            }
        }
        /** Equivalent to luaK_code. */
        kCode(i, line) {
            this.dischargejpc();
            // Put new instruction in code array.
            this._f.codeAppend(this._L, this._pc, i, line);
            return this._pc++;
        }
        /** Equivalent to luaK_codeABC. */
        kCodeABC(o, a, b, c) {
            // assert getOpMode(o) == iABC;
            // assert getBMode(o) != OP_ARG_N || b == 0;
            // assert getCMode(o) != OP_ARG_N || c == 0;
            return this.kCode(Lua_1.Lua.CREATE_ABC(o, a, b, c), this._ls.lastline);
        }
        /** Equivalent to luaK_codeABx. */
        kCodeABx(o, a, bc) {
            // assert getOpMode(o) == iABx || getOpMode(o) == iAsBx);
            // assert getCMode(o) == OP_ARG_N);
            return this.kCode(Lua_1.Lua.CREATE_ABx(o, a, bc), this._ls.lastline);
        }
        /** Equivalent to luaK_codeAsBx. */
        kCodeAsBx(o, a, bc) {
            return this.kCodeABx(o, a, bc + Lua_1.Lua.MAXARG_sBx);
        }
        /** Equivalent to luaK_dischargevars. */
        kDischargevars(e) {
            switch (e.kind) {
                case Expdesc_1.Expdesc.VLOCAL:
                    e.kind = Expdesc_1.Expdesc.VNONRELOC;
                    break;
                case Expdesc_1.Expdesc.VUPVAL:
                    e.reloc(this.kCodeABC(Lua_1.Lua.OP_GETUPVAL, 0, e.info, 0));
                    break;
                case Expdesc_1.Expdesc.VGLOBAL:
                    e.reloc(this.kCodeABx(Lua_1.Lua.OP_GETGLOBAL, 0, e.info));
                    break;
                case Expdesc_1.Expdesc.VINDEXED:
                    this.__freereg(e.aux); //TODO:
                    this.__freereg(e.info); //TODO:
                    e.reloc(this.kCodeABC(Lua_1.Lua.OP_GETTABLE, 0, e.info, e.aux));
                    break;
                case Expdesc_1.Expdesc.VVARARG:
                case Expdesc_1.Expdesc.VCALL:
                    this.kSetoneret(e);
                    break;
                default:
                    break; // there is one value available (somewhere)
            }
        }
        /** Equivalent to luaK_exp2anyreg. */
        kExp2anyreg(e) {
            this.kDischargevars(e);
            if (e.k == Expdesc_1.Expdesc.VNONRELOC) {
                if (!e.hasjumps()) {
                    return e.info;
                }
                if (e.info >= this._nactvar) // reg is not a local?
                 {
                    this.exp2reg(e, e.info); // put value on it
                    return e.info;
                }
            }
            this.kExp2nextreg(e); // default
            return e.info;
        }
        /** Equivalent to luaK_exp2nextreg. */
        kExp2nextreg(e) {
            this.kDischargevars(e);
            this.freeexp(e);
            this.kReserveregs(1);
            this.exp2reg(e, this._freereg - 1);
        }
        /** Equivalent to luaK_fixline. */
        kFixline(line) {
            this._f.setLineinfo(this._pc - 1, line);
        }
        /** Equivalent to luaK_infix. */
        kInfix(op, v) {
            switch (op) {
                case Syntax_1.Syntax.OPR_AND:
                    this.kGoiftrue(v);
                    break;
                case Syntax_1.Syntax.OPR_OR:
                    this.kGoiffalse(v);
                    break;
                case Syntax_1.Syntax.OPR_CONCAT:
                    this.kExp2nextreg(v); /* operand must be on the `stack' */
                    break;
                default:
                    if (!this.isnumeral(v))
                        this.kExp2RK(v);
                    break;
            }
        }
        isnumeral(e) {
            return e.k == Expdesc_1.Expdesc.VKNUM &&
                e.t == FuncState.NO_JUMP &&
                e.f == FuncState.NO_JUMP;
        }
        /** Equivalent to luaK_nil. */
        kNil(from, n) {
            var previous;
            if (this._pc > this._lasttarget) /* no jumps to current position? */ {
                if (this._pc == 0) /* function start? */
                    return; /* positions are already clean */
                previous = this._pc - 1;
                var instr = this._f.code[previous];
                if (Lua_1.Lua.OPCODE(instr) == Lua_1.Lua.OP_LOADNIL) {
                    var pfrom = Lua_1.Lua.ARGA(instr);
                    var pto = Lua_1.Lua.ARGB(instr);
                    if (pfrom <= from && from <= pto + 1) /* can connect both? */ {
                        if (from + n - 1 > pto)
                            this._f.code[previous] = Lua_1.Lua.SETARG_B(instr, from + n - 1);
                        return;
                    }
                }
            }
            this.kCodeABC(Lua_1.Lua.OP_LOADNIL, from, from + n - 1, 0);
        }
        /** Equivalent to luaK_numberK. */
        kNumberK(r) {
            return this.addk(Lua_1.Lua.valueOfNumber(r)); //TODO:L->Lua
        }
        /** Equivalent to luaK_posfix. */
        kPosfix(op, e1, e2) {
            switch (op) {
                case Syntax_1.Syntax.OPR_AND:
                    /* list must be closed */
                    //# assert e1.t == NO_JUMP
                    this.kDischargevars(e2);
                    e2.f = this.kConcat(e2.f, e1.f);
                    e1.copy(e2); //TODO:
                    break;
                case Syntax_1.Syntax.OPR_OR:
                    /* list must be closed */
                    //# assert e1.f == NO_JUMP
                    this.kDischargevars(e2);
                    e2.t = this.kConcat(e2.t, e1.t);
                    e1.copy(e2); //TODO:
                    break;
                case Syntax_1.Syntax.OPR_CONCAT:
                    this.kExp2val(e2);
                    if (e2.k == Expdesc_1.Expdesc.VRELOCABLE && Lua_1.Lua.OPCODE(this.getcode(e2)) == Lua_1.Lua.OP_CONCAT) {
                        //# assert e1.info == Lua.ARGB(getcode(e2))-1
                        this.freeexp(e1);
                        this.setcode(e2, Lua_1.Lua.SETARG_B(this.getcode(e2), e1.info));
                        e1.k = e2.k;
                        e1.info = e2.info;
                    }
                    else {
                        this.kExp2nextreg(e2); /* operand must be on the 'stack' */
                        this.codearith(Lua_1.Lua.OP_CONCAT, e1, e2);
                    }
                    break;
                case Syntax_1.Syntax.OPR_ADD:
                    this.codearith(Lua_1.Lua.OP_ADD, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_SUB:
                    this.codearith(Lua_1.Lua.OP_SUB, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_MUL:
                    this.codearith(Lua_1.Lua.OP_MUL, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_DIV:
                    this.codearith(Lua_1.Lua.OP_DIV, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_MOD:
                    this.codearith(Lua_1.Lua.OP_MOD, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_POW:
                    this.codearith(Lua_1.Lua.OP_POW, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_EQ:
                    this.codecomp(Lua_1.Lua.OP_EQ, true, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_NE:
                    this.codecomp(Lua_1.Lua.OP_EQ, false, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_LT:
                    this.codecomp(Lua_1.Lua.OP_LT, true, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_LE:
                    this.codecomp(Lua_1.Lua.OP_LE, true, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_GT:
                    this.codecomp(Lua_1.Lua.OP_LT, false, e1, e2);
                    break;
                case Syntax_1.Syntax.OPR_GE:
                    this.codecomp(Lua_1.Lua.OP_LE, false, e1, e2);
                    break;
                default:
                //# assert false
            }
        }
        /** Equivalent to luaK_prefix. */
        kPrefix(op, e) {
            var e2 = new Expdesc_1.Expdesc(); // TODO:
            e2.init(Expdesc_1.Expdesc.VKNUM, 0);
            switch (op) {
                case Syntax_1.Syntax.OPR_MINUS:
                    if (e.kind == Expdesc_1.Expdesc.VK) {
                        this.kExp2anyreg(e);
                    }
                    this.codearith(Lua_1.Lua.OP_UNM, e, e2);
                    break;
                case Syntax_1.Syntax.OPR_NOT:
                    this.codenot(e);
                    break;
                case Syntax_1.Syntax.OPR_LEN:
                    this.kExp2anyreg(e);
                    this.codearith(Lua_1.Lua.OP_LEN, e, e2);
                    break;
                default:
                    throw new IllegalArgumentException_1.IllegalArgumentException();
            }
        }
        /** Equivalent to luaK_reserveregs. */
        kReserveregs(n) {
            this.kCheckstack(n);
            this._freereg += n;
        }
        /** Equivalent to luaK_ret. */
        kRet(first, nret) {
            this.kCodeABC(Lua_1.Lua.OP_RETURN, first, nret + 1, 0);
        }
        /** Equivalent to luaK_setmultret (in lcode.h). */
        kSetmultret(e) {
            this.kSetreturns(e, Lua_1.Lua.MULTRET);
        }
        /** Equivalent to luaK_setoneret. */
        kSetoneret(e) {
            if (e.kind == Expdesc_1.Expdesc.VCALL) // expression is an open function call?
             {
                e.nonreloc(Lua_1.Lua.ARGA(this.getcode(e)));
            }
            else if (e.kind == Expdesc_1.Expdesc.VVARARG) {
                this.setargb(e, 2);
                e.kind = Expdesc_1.Expdesc.VRELOCABLE;
            }
        }
        /** Equivalent to luaK_setreturns. */
        kSetreturns(e, nresults) {
            if (e.kind == Expdesc_1.Expdesc.VCALL) // expression is an open function call?
             {
                this.setargc(e, nresults + 1);
            }
            else if (e.kind == Expdesc_1.Expdesc.VVARARG) {
                this.setargb(e, nresults + 1);
                this.setarga(e, this._freereg);
                this.kReserveregs(1);
            }
        }
        /** Equivalent to luaK_stringK. */
        kStringK(s) {
            return this.addk(s /*.intern()*/);
        }
        addk(o) {
            var hash = o;
            var v = this._h._get(hash); //TODO:get
            if (v != null) {
                // :todo: assert
                return v; //TODO:
            }
            // constant not found; create a new entry
            this._f.constantAppend(this._nk, o);
            this._h.put(hash, new Number(this._nk)); //TODO:
            return this._nk++;
        }
        codearith(op, e1, e2) {
            if (this.constfolding(op, e1, e2))
                return;
            else {
                var o1 = this.kExp2RK(e1);
                var o2 = (op != Lua_1.Lua.OP_UNM && op != Lua_1.Lua.OP_LEN) ? this.kExp2RK(e2) : 0;
                this.freeexp(e2);
                this.freeexp(e1);
                e1.info = this.kCodeABC(op, 0, o1, o2);
                e1.k = Expdesc_1.Expdesc.VRELOCABLE;
            }
        }
        constfolding(op, e1, e2) {
            var r = 0;
            if (!this.isnumeral(e1) || !this.isnumeral(e2))
                return false;
            var v1 = e1.nval;
            var v2 = e2.nval;
            switch (op) {
                case Lua_1.Lua.OP_ADD:
                    r = v1 + v2;
                    break;
                case Lua_1.Lua.OP_SUB:
                    r = v1 - v2;
                    break;
                case Lua_1.Lua.OP_MUL:
                    r = v1 * v2;
                    break;
                case Lua_1.Lua.OP_DIV:
                    if (v2 == 0.0)
                        return false; /* do not attempt to divide by 0 */
                    r = v1 / v2;
                    break;
                case Lua_1.Lua.OP_MOD:
                    if (v2 == 0.0)
                        return false; /* do not attempt to divide by 0 */
                    r = v1 % v2;
                    break;
                case Lua_1.Lua.OP_POW:
                    r = Lua_1.Lua.iNumpow(v1, v2); //TODO:L->Lua
                    break;
                case Lua_1.Lua.OP_UNM:
                    r = -v1;
                    break;
                case Lua_1.Lua.OP_LEN:
                    return false; /* no constant folding for 'len' */
                default:
                    //# assert false
                    r = 0.0;
                    break;
            }
            if (isNaN(r))
                return false; /* do not attempt to produce NaN */
            e1.nval = r;
            return true;
        }
        codenot(e) {
            this.kDischargevars(e);
            switch (e.k) {
                case Expdesc_1.Expdesc.VNIL:
                case Expdesc_1.Expdesc.VFALSE:
                    e.k = Expdesc_1.Expdesc.VTRUE;
                    break;
                case Expdesc_1.Expdesc.VK:
                case Expdesc_1.Expdesc.VKNUM:
                case Expdesc_1.Expdesc.VTRUE:
                    e.k = Expdesc_1.Expdesc.VFALSE;
                    break;
                case Expdesc_1.Expdesc.VJMP:
                    this.invertjump(e);
                    break;
                case Expdesc_1.Expdesc.VRELOCABLE:
                case Expdesc_1.Expdesc.VNONRELOC:
                    this.discharge2anyreg(e);
                    this.freeexp(e);
                    e.info = this.kCodeABC(Lua_1.Lua.OP_NOT, 0, e.info, 0);
                    e.k = Expdesc_1.Expdesc.VRELOCABLE;
                    break;
                default:
                    //# assert false
                    break;
            }
            /* interchange true and false lists */
            {
                var temp = e.f;
                e.f = e.t;
                e.t = temp;
            }
            this.removevalues(e.f);
            this.removevalues(e.t);
        }
        removevalues(list) {
            for (; list != FuncState.NO_JUMP; list = this.getjump(list))
                this.patchtestreg(list, Lua_1.Lua.NO_REG);
        }
        dischargejpc() {
            this.patchlistaux(this._jpc, this._pc, Lua_1.Lua.NO_REG, this._pc);
            this._jpc = FuncState.NO_JUMP;
        }
        discharge2reg(e, reg) {
            this.kDischargevars(e);
            switch (e.k) {
                case Expdesc_1.Expdesc.VNIL:
                    this.kNil(reg, 1);
                    break;
                case Expdesc_1.Expdesc.VFALSE:
                case Expdesc_1.Expdesc.VTRUE:
                    this.kCodeABC(Lua_1.Lua.OP_LOADBOOL, reg, (e.k == Expdesc_1.Expdesc.VTRUE ? 1 : 0), 0);
                    break;
                case Expdesc_1.Expdesc.VK:
                    this.kCodeABx(Lua_1.Lua.OP_LOADK, reg, e.info);
                    break;
                case Expdesc_1.Expdesc.VKNUM:
                    this.kCodeABx(Lua_1.Lua.OP_LOADK, reg, this.kNumberK(e.nval));
                    break;
                case Expdesc_1.Expdesc.VRELOCABLE:
                    this.setarga(e, reg);
                    break;
                case Expdesc_1.Expdesc.VNONRELOC:
                    if (reg != e.info) {
                        this.kCodeABC(Lua_1.Lua.OP_MOVE, reg, e.info, 0);
                    }
                    break;
                case Expdesc_1.Expdesc.VVOID:
                case Expdesc_1.Expdesc.VJMP:
                    return;
                default:
                //# assert false
            }
            e.nonreloc(reg);
        }
        exp2reg(e, reg) {
            this.discharge2reg(e, reg);
            if (e.k == Expdesc_1.Expdesc.VJMP) {
                e.t = this.kConcat(e.t, e.info); /* put this jump in `t' list */
            }
            if (e.hasjumps()) {
                var p_f = FuncState.NO_JUMP; /* position of an eventual LOAD false */
                var p_t = FuncState.NO_JUMP; /* position of an eventual LOAD true */
                if (this.need_value(e.t) || this.need_value(e.f)) {
                    var fj = (e.k == Expdesc_1.Expdesc.VJMP) ? FuncState.NO_JUMP : this.kJump();
                    p_f = this.code_label(reg, 0, 1);
                    p_t = this.code_label(reg, 1, 0);
                    this.kPatchtohere(fj);
                }
                var finalpos = this.kGetlabel(); /* position after whole expression */
                this.patchlistaux(e.f, finalpos, reg, p_f);
                this.patchlistaux(e.t, finalpos, reg, p_t);
            }
            e.init(Expdesc_1.Expdesc.VNONRELOC, reg);
        }
        code_label(a, b, jump) {
            this.kGetlabel(); /* those instructions may be jump targets */
            return this.kCodeABC(Lua_1.Lua.OP_LOADBOOL, a, b, jump);
        }
        /**
         * check whether list has any jump that do not produce a value
         * (or produce an inverted value)
         */
        need_value(list) {
            for (; list != FuncState.NO_JUMP; list = this.getjump(list)) {
                var i = this.getjumpcontrol(list);
                var instr = this._f.code[i];
                if (Lua_1.Lua.OPCODE(instr) != Lua_1.Lua.OP_TESTSET)
                    return true;
            }
            return false; /* not found */
        }
        freeexp(e) {
            if (e.kind == Expdesc_1.Expdesc.VNONRELOC) {
                this.__freereg(e.info);
            }
        }
        set freereg(freereg) {
            this._freereg = freereg;
        }
        get freereg() {
            return this._freereg;
        }
        __freereg(reg) {
            if (!Lua_1.Lua.ISK(reg) && reg >= this._nactvar) {
                --this._freereg;
                // assert reg == freereg;
            }
        }
        getcode(e) {
            return this._f.code[e.info];
        }
        setcode(e, code) {
            this._f.code[e.info] = code;
        }
        /** Equivalent to searchvar from lparser.c */
        searchvar(n) {
            // caution: descending loop (in emulation of PUC-Rio).
            for (var i = this._nactvar - 1; i >= 0; i--) {
                if (n == this.getlocvar(i).varname)
                    return i;
            }
            return -1; // not found
        }
        setarga(e, a) {
            var at = e.info;
            var code = this._f.code; //int[] 
            code[at] = Lua_1.Lua.SETARG_A(code[at], a);
        }
        setargb(e, b) {
            var at = e.info;
            var code = this._f.code; //int[] 
            code[at] = Lua_1.Lua.SETARG_B(code[at], b);
        }
        setargc(e, c) {
            var at = e.info;
            var code = this._f.code; //int[]
            code[at] = Lua_1.Lua.SETARG_C(code[at], c);
        }
        /** Equivalent to <code>luaK_getlabel</code>. */
        kGetlabel() {
            this._lasttarget = this._pc;
            return this._pc;
        }
        /**
        * Equivalent to <code>luaK_concat</code>.
        * l1 was an int*, now passing back as result.
        */
        kConcat(l1, l2) {
            if (l2 == FuncState.NO_JUMP)
                return l1;
            else if (l1 == FuncState.NO_JUMP)
                return l2;
            else {
                var list = l1;
                var next;
                while ((next = this.getjump(list)) != FuncState.NO_JUMP) /* find last element */
                    list = next;
                this.fixjump(list, l2);
                return l1;
            }
        }
        /** Equivalent to <code>luaK_patchlist</code>. */
        kPatchlist(list, target) {
            if (target == this._pc)
                this.kPatchtohere(list);
            else {
                //# assert target < pc
                this.patchlistaux(list, target, Lua_1.Lua.NO_REG, target);
            }
        }
        patchlistaux(list, vtarget, reg, dtarget) {
            while (list != FuncState.NO_JUMP) {
                var next = this.getjump(list);
                if (this.patchtestreg(list, reg))
                    this.fixjump(list, vtarget);
                else
                    this.fixjump(list, dtarget); /* jump to default target */
                list = next;
            }
        }
        patchtestreg(node, reg) {
            var i = this.getjumpcontrol(node);
            var code = this._f.code; //int [] 
            var instr = code[i];
            if (Lua_1.Lua.OPCODE(instr) != Lua_1.Lua.OP_TESTSET)
                return false; /* cannot patch other instructions */
            if (reg != Lua_1.Lua.NO_REG && reg != Lua_1.Lua.ARGB(instr))
                code[i] = Lua_1.Lua.SETARG_A(instr, reg);
            else /* no register to put value or register already has the value */
                code[i] = Lua_1.Lua.CREATE_ABC(Lua_1.Lua.OP_TEST, Lua_1.Lua.ARGB(instr), 0, Lua_1.Lua.ARGC(instr));
            return true;
        }
        getjumpcontrol(at) {
            var code = this._f.code; //int []
            if (at >= 1 && this.testTMode(Lua_1.Lua.OPCODE(code[at - 1])))
                return at - 1;
            else
                return at;
        }
        static opmode(t, a, b, c, m) {
            return ((t << 7) | (a << 6) | (b << 4) | (c << 2) | m);
        }
        getOpMode(m) {
            return FuncState.OPMODE[m] & 3;
        }
        testAMode(m) {
            return (FuncState.OPMODE[m] & (1 << 6)) != 0;
        }
        testTMode(m) {
            return (FuncState.OPMODE[m] & (1 << 7)) != 0;
        }
        /** Equivalent to <code>luaK_patchtohere</code>. */
        kPatchtohere(list) {
            this.kGetlabel();
            this._jpc = this.kConcat(this._jpc, list);
        }
        fixjump(at, dest) {
            var jmp = this._f.code[at];
            var offset = dest - (at + 1);
            //# assert dest != NO_JUMP
            if (Math.abs(offset) > Lua_1.Lua.MAXARG_sBx)
                this._ls.xSyntaxerror("control structure too long");
            this._f.code[at] = Lua_1.Lua.SETARG_sBx(jmp, offset);
        }
        getjump(at) {
            var offset = Lua_1.Lua.ARGsBx(this._f.code[at]);
            if (offset == FuncState.NO_JUMP) /* point to itself represents end of list */
                return FuncState.NO_JUMP; /* end of list */
            else
                return (at + 1) + offset; /* turn offset into absolute position */
        }
        /** Equivalent to <code>luaK_jump</code>. */
        kJump() {
            var old_jpc = this._jpc; /* save list of jumps to here */
            this._jpc = FuncState.NO_JUMP;
            var j = this.kCodeAsBx(Lua_1.Lua.OP_JMP, 0, FuncState.NO_JUMP);
            j = this.kConcat(j, old_jpc); /* keep them on hold */
            return j;
        }
        /** Equivalent to <code>luaK_storevar</code>. */
        kStorevar(_var, ex) {
            switch (_var.k) {
                case Expdesc_1.Expdesc.VLOCAL:
                    {
                        this.freeexp(ex);
                        this.exp2reg(ex, _var.info);
                        return;
                    }
                case Expdesc_1.Expdesc.VUPVAL:
                    {
                        var e = this.kExp2anyreg(ex);
                        this.kCodeABC(Lua_1.Lua.OP_SETUPVAL, e, _var.info, 0);
                        break;
                    }
                case Expdesc_1.Expdesc.VGLOBAL:
                    {
                        var e2 = this.kExp2anyreg(ex);
                        this.kCodeABx(Lua_1.Lua.OP_SETGLOBAL, e2, _var.info);
                        break;
                    }
                case Expdesc_1.Expdesc.VINDEXED:
                    {
                        var e3 = this.kExp2RK(ex);
                        this.kCodeABC(Lua_1.Lua.OP_SETTABLE, _var.info, _var.aux, e3);
                        break;
                    }
                default:
                    {
                        /* invalid var kind to store */
                        //# assert false
                        break;
                    }
            }
            this.freeexp(ex);
        }
        /** Equivalent to <code>luaK_indexed</code>. */
        kIndexed(t, k) {
            t.aux = this.kExp2RK(k);
            t.k = Expdesc_1.Expdesc.VINDEXED;
        }
        /** Equivalent to <code>luaK_exp2RK</code>. */
        kExp2RK(e) {
            this.kExp2val(e);
            switch (e.k) {
                case Expdesc_1.Expdesc.VKNUM:
                case Expdesc_1.Expdesc.VTRUE:
                case Expdesc_1.Expdesc.VFALSE:
                case Expdesc_1.Expdesc.VNIL:
                    if (this._nk <= Lua_1.Lua.MAXINDEXRK) /* constant fit in RK operand? */ {
                        e.info = (e.k == Expdesc_1.Expdesc.VNIL) ? this.nilK() :
                            (e.k == Expdesc_1.Expdesc.VKNUM) ? this.kNumberK(e.nval) :
                                this.boolK(e.k == Expdesc_1.Expdesc.VTRUE);
                        e.k = Expdesc_1.Expdesc.VK;
                        return e.info | Lua_1.Lua.BITRK;
                    }
                    else
                        break;
                case Expdesc_1.Expdesc.VK:
                    if (e.info <= Lua_1.Lua.MAXINDEXRK) /* constant fit in argC? */
                        return e.info | Lua_1.Lua.BITRK;
                    else
                        break;
                default:
                    break;
            }
            /* not a constant in the right range: put it in a register */
            return this.kExp2anyreg(e);
        }
        /** Equivalent to <code>luaK_exp2val</code>. */
        kExp2val(e) {
            if (e.hasjumps())
                this.kExp2anyreg(e);
            else
                this.kDischargevars(e);
        }
        boolK(b) {
            return this.addk(Lua_1.Lua.valueOfBoolean(b));
        }
        nilK() {
            return this.addk(Lua_1.Lua.NIL);
        }
        /** Equivalent to <code>luaK_goiffalse</code>. */
        kGoiffalse(e) {
            var lj; /* pc of last jump */
            this.kDischargevars(e);
            switch (e.k) {
                case Expdesc_1.Expdesc.VNIL:
                case Expdesc_1.Expdesc.VFALSE:
                    lj = FuncState.NO_JUMP; /* always false; do nothing */
                    break;
                case Expdesc_1.Expdesc.VTRUE:
                    lj = this.kJump(); /* always jump */
                    break;
                case Expdesc_1.Expdesc.VJMP:
                    lj = e.info;
                    break;
                default:
                    lj = this.jumponcond(e, true);
                    break;
            }
            e.t = this.kConcat(e.t, lj); /* insert last jump in `t' list */
            this.kPatchtohere(e.f);
            e.f = FuncState.NO_JUMP;
        }
        /** Equivalent to <code>luaK_goiftrue</code>. */
        kGoiftrue(e) {
            var lj; /* pc of last jump */
            this.kDischargevars(e);
            switch (e.k) {
                case Expdesc_1.Expdesc.VK:
                case Expdesc_1.Expdesc.VKNUM:
                case Expdesc_1.Expdesc.VTRUE:
                    lj = FuncState.NO_JUMP; /* always true; do nothing */
                    break;
                case Expdesc_1.Expdesc.VFALSE:
                    lj = this.kJump(); /* always jump */
                    break;
                case Expdesc_1.Expdesc.VJMP:
                    this.invertjump(e);
                    lj = e.info;
                    break;
                default:
                    lj = this.jumponcond(e, false);
                    break;
            }
            e.f = this.kConcat(e.f, lj); /* insert last jump in `f' list */
            this.kPatchtohere(e.t);
            e.t = FuncState.NO_JUMP;
        }
        invertjump(e) {
            var at = this.getjumpcontrol(e.info);
            var code = this._f.code; //int []
            var instr = code[at];
            //# assert testTMode(Lua.OPCODE(instr)) && Lua.OPCODE(instr) != Lua.OP_TESTSET && Lua.OPCODE(instr) != Lua.OP_TEST
            code[at] = Lua_1.Lua.SETARG_A(instr, (Lua_1.Lua.ARGA(instr) == 0 ? 1 : 0));
        }
        jumponcond(e, cond) {
            if (e.k == Expdesc_1.Expdesc.VRELOCABLE) {
                var ie = this.getcode(e);
                if (Lua_1.Lua.OPCODE(ie) == Lua_1.Lua.OP_NOT) {
                    this._pc--; /* remove previous OP_NOT */
                    return this.condjump(Lua_1.Lua.OP_TEST, Lua_1.Lua.ARGB(ie), 0, cond ? 0 : 1);
                }
                /* else go through */
            }
            this.discharge2anyreg(e);
            this.freeexp(e);
            return this.condjump(Lua_1.Lua.OP_TESTSET, Lua_1.Lua.NO_REG, e.info, cond ? 1 : 0);
        }
        condjump(op, a, b, c) {
            this.kCodeABC(op, a, b, c);
            return this.kJump();
        }
        discharge2anyreg(e) {
            if (e.k != Expdesc_1.Expdesc.VNONRELOC) {
                this.kReserveregs(1);
                this.discharge2reg(e, this._freereg - 1);
            }
        }
        kSelf(e, key) {
            this.kExp2anyreg(e);
            this.freeexp(e);
            var func = this._freereg;
            this.kReserveregs(2);
            this.kCodeABC(Lua_1.Lua.OP_SELF, func, e.info, this.kExp2RK(key));
            this.freeexp(key);
            e.info = func;
            e.k = Expdesc_1.Expdesc.VNONRELOC;
        }
        kSetlist(base, nelems, tostore) {
            var c = (nelems - 1) / Lua_1.Lua.LFIELDS_PER_FLUSH + 1;
            var b = (tostore == Lua_1.Lua.MULTRET) ? 0 : tostore;
            //# assert tostore != 0
            if (c <= Lua_1.Lua.MAXARG_C)
                this.kCodeABC(Lua_1.Lua.OP_SETLIST, base, b, c);
            else {
                this.kCodeABC(Lua_1.Lua.OP_SETLIST, base, b, 0);
                this.kCode(c, this._ls.lastline);
            }
            this._freereg = base + 1; /* free registers with list values */
        }
        codecomp(op, cond, e1, e2) {
            var o1 = this.kExp2RK(e1);
            var o2 = this.kExp2RK(e2);
            this.freeexp(e2);
            this.freeexp(e1);
            if ((!cond) && op != Lua_1.Lua.OP_EQ) {
                /* exchange args to replace by `<' or `<=' */
                var temp = o1;
                o1 = o2;
                o2 = temp; /* o1 <==> o2 */
                cond = true;
            }
            e1.info = this.condjump(op, (cond ? 1 : 0), o1, o2);
            e1.k = Expdesc_1.Expdesc.VJMP;
        }
        markupval(level) {
            var b = this.bl;
            while (b != null && b.nactvar > level)
                b = b.previous;
            if (b != null)
                b.upval = true;
        }
        //新增
        get f() {
            return this._f;
        }
        //新增
        set f(f) {
            this._f = f;
        }
        //新增
        get prev() {
            return this._prev;
        }
        //新增
        set prev(prev) {
            this._prev = prev;
        }
        //新增
        set ls(ls) {
            this._ls = ls;
        }
        //新增
        set L(L) {
            this._L = L;
        }
        //新增
        get bl() {
            return this._bl;
        }
        //新增
        set bl(bl) {
            this._bl = bl;
        }
        //新增
        get pc() {
            return this._pc;
        }
        //新增
        get np() {
            return this._np;
        }
        //新增
        set np(np) {
            this._np = np;
        }
        //新增
        get nlocvars() {
            return this._nlocvars;
        }
        //新增
        set nlocvars(nlocvars) {
            this._nlocvars = nlocvars;
        }
        //新增
        get nactvar() {
            return this._nactvar;
        }
        //新增
        set nactvar(nactvar) {
            this._nactvar = nactvar;
        }
        //新增
        get upvalues() {
            return this._upvalues;
        }
        //新增
        get actvar() {
            return this._actvar;
        }
    }
    exports.FuncState = FuncState;
    /** See NO_JUMP in lcode.h. */
    FuncState.NO_JUMP = -1;
    /*
    ** masks for instruction properties. The format is:
    ** bits 0-1: op mode
    ** bits 2-3: C arg mode
    ** bits 4-5: B arg mode
    ** bit 6: instruction set register A
    ** bit 7: operator is a test
    */
    /** arg modes */
    FuncState.OP_ARG_N = 0;
    FuncState.OP_ARG_U = 1;
    FuncState.OP_ARG_R = 2;
    FuncState.OP_ARG_K = 3;
    /** op modes */
    FuncState.iABC = 0;
    FuncState.iABx = 1;
    FuncState.iAsBx = 2;
    FuncState.OPMODE = [
        /*      T  A  B         C         mode                opcode  */
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iABC) /* OP_MOVE */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_N, FuncState.iABx) /* OP_LOADK */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_U, FuncState.OP_ARG_U, FuncState.iABC) /* OP_LOADBOOL */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iABC) /* OP_LOADNIL */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_U, FuncState.OP_ARG_N, FuncState.iABC) /* OP_GETUPVAL */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_N, FuncState.iABx) /* OP_GETGLOBAL */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_K, FuncState.iABC) /* OP_GETTABLE */,
        FuncState.opmode(0, 0, FuncState.OP_ARG_K, FuncState.OP_ARG_N, FuncState.iABx) /* OP_SETGLOBAL */,
        FuncState.opmode(0, 0, FuncState.OP_ARG_U, FuncState.OP_ARG_N, FuncState.iABC) /* OP_SETUPVAL */,
        FuncState.opmode(0, 0, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_SETTABLE */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_U, FuncState.OP_ARG_U, FuncState.iABC) /* OP_NEWTABLE */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_K, FuncState.iABC) /* OP_SELF */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_ADD */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_SUB */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_MUL */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_DIV */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_MOD */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_POW */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iABC) /* OP_UNM */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iABC) /* OP_NOT */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iABC) /* OP_LEN */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_R, FuncState.iABC) /* OP_CONCAT */,
        FuncState.opmode(0, 0, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iAsBx) /* OP_JMP */,
        FuncState.opmode(1, 0, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_EQ */,
        FuncState.opmode(1, 0, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_LT */,
        FuncState.opmode(1, 0, FuncState.OP_ARG_K, FuncState.OP_ARG_K, FuncState.iABC) /* OP_LE */,
        FuncState.opmode(1, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_U, FuncState.iABC) /* OP_TEST */,
        FuncState.opmode(1, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_U, FuncState.iABC) /* OP_TESTSET */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_U, FuncState.OP_ARG_U, FuncState.iABC) /* OP_CALL */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_U, FuncState.OP_ARG_U, FuncState.iABC) /* OP_TAILCALL */,
        FuncState.opmode(0, 0, FuncState.OP_ARG_U, FuncState.OP_ARG_N, FuncState.iABC) /* OP_RETURN */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iAsBx) /* OP_FORLOOP */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_R, FuncState.OP_ARG_N, FuncState.iAsBx) /* OP_FORPREP */,
        FuncState.opmode(1, 0, FuncState.OP_ARG_N, FuncState.OP_ARG_U, FuncState.iABC) /* OP_TFORLOOP */,
        FuncState.opmode(0, 0, FuncState.OP_ARG_U, FuncState.OP_ARG_U, FuncState.iABC) /* OP_SETLIST */,
        FuncState.opmode(0, 0, FuncState.OP_ARG_N, FuncState.OP_ARG_N, FuncState.iABC) /* OP_CLOSE */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_U, FuncState.OP_ARG_N, FuncState.iABx) /* OP_CLOSURE */,
        FuncState.opmode(0, 1, FuncState.OP_ARG_U, FuncState.OP_ARG_N, FuncState.iABC) /* OP_VARARG */
    ];
});

},{"../java/Hashtable":9,"../java/IllegalArgumentException":12,"./Expdesc":38,"./Lua":45,"./Proto":56,"./Syntax":60}],42:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Expdesc"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LHSAssign = void 0;
    const Expdesc_1 = require("./Expdesc");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Syntax.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class LHSAssign {
        //TODO:
        constructor() {
            this._prev = null;
            this._v = new Expdesc_1.Expdesc();
        }
        init(prev) {
            this._prev = prev;
        }
        //新增
        get prev() {
            return this._prev;
        }
        //新增
        set prev(prev) {
            this._prev = prev;
        }
        //新增
        get v() {
            return this._v;
        }
    }
    exports.LHSAssign = LHSAssign;
});

},{"./Expdesc":38}],43:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/EOFException", "../java/IOException", "../java/NullPointerException", "../java/ByteArray", "./Proto", "./Slot", "./LocVar", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Loader = void 0;
    const EOFException_1 = require("../java/EOFException");
    const IOException_1 = require("../java/IOException");
    const NullPointerException_1 = require("../java/NullPointerException");
    const ByteArray_1 = require("../java/ByteArray");
    const Proto_1 = require("./Proto");
    const Slot_1 = require("./Slot");
    const LocVar_1 = require("./LocVar");
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Loader.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Loads Lua 5.1 binary chunks.
     * This loader is restricted to loading Lua 5.1 binary chunks where:
     * <ul>
     * <li><code>LUAC_VERSION</code> is <code>0x51</code>.</li>
     * <li><code>int</code> is 32 bits.</li>
     * <li><code>size_t</code> is 32 bits.</li>
     * <li><code>Instruction</code> is 32 bits (this is a type defined in
     * the PUC-Rio Lua).</li>
     * <li><code>lua_Number</code> is an IEEE 754 64-bit double.  Suitable
     * for passing to {@link java.lang.Double#longBitsToDouble}.</li>
     * <li>endianness does not matter (the loader swabs as appropriate).</li>
     * </ul>
     * Any Lua chunk compiled by a stock Lua 5.1 running on a 32-bit Windows
     * PC or at 32-bit OS X machine should be fine.
     */
    class Loader {
        /**
        * A new chunk loader.  The <code>InputStream</code> must be
        * positioned at the beginning of the <code>LUA_SIGNATURE</code> that
        * marks the beginning of a Lua binary chunk.
        * @param in    The binary stream from which the chunk is read.
        * @param name  The name of the chunk.
        */
        constructor(_in, name) {
            /**
             * Whether integers in the binary chunk are stored big-endian or
             * little-endian.  Recall that the number 0x12345678 is stored: 0x12
             * 0x34 0x56 0x78 in big-endian format; and, 0x78 0x56 0x34 0x12 in
             * little-endian format.
             */
            this._bigendian = false;
            //TODO:这里有问题
            // auxiliary for reading ints/numbers
            this._intbuf = new ByteArray_1.ByteArray(); //new Array(4) ; //byte [] 
            this._longbuf = new ByteArray_1.ByteArray(); //new Array(8) ; //byte [] 
            if (null == _in) {
                throw new NullPointerException_1.NullPointerException();
            }
            this._in = _in;
            // The name is treated slightly.  See lundump.c in the PUC-Rio
            // source for details.
            if (name.substr(0, 1) == "@" || name.substr(0, 1) == "=") {
                this._name = name.substring(1);
            }
            else if (false) {
                // :todo: Select some equivalent for the binary string case.
                this._name = "binary string";
            }
            else {
                this._name = name;
            }
        }
        /**
         * Loads (undumps) a dumped binary chunk.
         * @throws IOException  if chunk is malformed or unacceptable.
         */
        undump() {
            this.header();
            return this._function(null);
        }
        /**
         * Primitive reader for undumping.
         * Reads exactly enough bytes from <code>this.in</code> to fill the
         * array <code>b</code>.  If there aren't enough to fill
         * <code>b</code> then an exception is thrown.  Similar to
         * <code>LoadBlock</code> from PUC-Rio's <code>lundump.c</code>.
         * @param b  byte array to fill.
         * @throws EOFException when the stream is exhausted too early.
         * @throws IOException when the underlying stream does.
         */
        block(b) {
            var n = this._in.readBytes(b);
            if (n != b.length)
                throw new EOFException_1.EOFException();
        }
        /**
         * Undumps a byte as an 8 bit unsigned number.  Returns
         * an int to accommodate the range.
         */
        byteLoad() {
            var c = this._in.read();
            if (c == -1)
                throw new EOFException_1.EOFException();
            else
                return c & 0xFF; // paranoia
        }
        /**
         * Undumps the code for a <code>Proto</code>.  The code is an array of
         * VM instructions.
         */
        code() {
            var n = this.intLoad();
            var code = new Array(n); //int[] 
            for (var i = 0; i < n; ++i) {
                // :Instruction:size  Here we assume that a dumped Instruction is
                // the same size as a dumped int.
                code[i] = this.intLoad();
            }
            return code;
        }
        /**
         * Undumps the constant array contained inside a <code>Proto</code>
         * object.  First half of <code>LoadConstants</code>, see
         * <code>proto</code> for the second half of
         * <code>LoadConstants</code>.
         */
        constant() {
            var n = this.intLoad();
            var k = new Array(n); //Slot[] 
            // Load each constant one by one.  We use the following values for
            // the Lua tagtypes (taken from <code>lua.h</code> from the PUC-Rio
            // Lua 5.1 distribution):
            // LUA_TNIL         0
            // LUA_TBOOLEAN     1
            // LUA_TNUMBER      3
            // LUA_TSTRING      4
            // All other tagtypes are invalid
            // :todo: Currently a new Slot is created for each constant.
            // Consider a space optimisation whereby identical constants have
            // the same Slot.  Constants are pooled per function anyway (so a
            // function never has 2 identical constants), so would have to work
            // across functions.  The easy cases of nil, true, false, might be
            // worth doing since that doesn't require a global table.
            // 
            for (var i = 0; i < n; ++i) {
                var t = this.byteLoad();
                switch (t) {
                    case 0: // LUA_TNIL
                        k[i] = new Slot_1.Slot();
                        k[i].init2(Lua_1.Lua.NIL); //TODO:
                        break;
                    case 1: // LUA_TBOOLEAN
                        var b = this.byteLoad();
                        // assert b >= 0;
                        if (b > 1)
                            throw new IOException_1.IOException();
                        k[i] = new Slot_1.Slot();
                        k[i].init2(Lua_1.Lua.valueOfBoolean(b != 0));
                        break;
                    case 3: // LUA_TNUMBER
                        k[i] = new Slot_1.Slot();
                        k[i].init2(this.number());
                        break;
                    case 4: // LUA_TSTRING
                        k[i] = new Slot_1.Slot();
                        k[i].init2(this.string());
                        break;
                    default:
                        throw new IOException_1.IOException();
                }
            }
            return k;
        }
        /**
         * Undumps the debug info for a <code>Proto</code>.
         * @param proto  The Proto instance to which debug info will be added.
         */
        debug(proto) {
            // lineinfo
            var n = this.intLoad();
            var lineinfo = new Array(n); //int[] 
            for (var i = 0; i < n; ++i) {
                lineinfo[i] = this.intLoad();
            }
            // locvars
            n = this.intLoad();
            var locvar = new Array(n); //LocVar[] 
            for (i = 0; i < n; ++i) {
                var s = this.string();
                var start = this.intLoad();
                var end = this.intLoad();
                locvar[i] = new LocVar_1.LocVar();
                locvar[i].init(s, start, end);
            }
            // upvalue (names)
            n = this.intLoad();
            var upvalue = new Array(n); //String[]
            for (i = 0; i < n; ++i) {
                upvalue[i] = this.string();
            }
            proto.debug(lineinfo, locvar, upvalue);
            return;
        }
        /**
         * Undumps a Proto object.  This is named 'function' after
         * <code>LoadFunction</code> in PUC-Rio's <code>lundump.c</code>.
         * @param parentSource  Name of parent source "file".
         * @throws IOException  when binary is malformed.
         */
        _function(parentSource) {
            var source;
            var linedefined;
            var lastlinedefined;
            var nups;
            var numparams;
            var varargByte;
            var vararg;
            var maxstacksize;
            var code; //int[] 
            var constant; //Slot[] 
            var proto; //Proto[] 
            source = this.string();
            if (null == source) {
                source = parentSource;
            }
            linedefined = this.intLoad();
            lastlinedefined = this.intLoad();
            nups = this.byteLoad();
            numparams = this.byteLoad();
            varargByte = this.byteLoad();
            // "is_vararg" is a 3-bit field, with the following bit meanings
            // (see "lobject.h"):
            // 1 - VARARG_HASARG
            // 2 - VARARG_ISVARARG
            // 4 - VARARG_NEEDSARG
            // Values 1 and 4 (bits 0 and 2) are only used for 5.0
            // compatibility.
            // HASARG indicates that a function was compiled in 5.0
            // compatibility mode and is declared to have ... in its parameter
            // list.
            // NEEDSARG indicates that a function was compiled in 5.0
            // compatibility mode and is declared to have ... in its parameter
            // list and does _not_ use the 5.1 style of vararg access (using ...
            // as an expression).  It is assumed to use 5.0 style vararg access
            // (the local 'arg' variable).  This is not supported in Jill.
            // ISVARARG indicates that a function has ... in its parameter list
            // (whether compiled in 5.0 compatibility mode or not).
            //
            // At runtime NEEDSARG changes the protocol for calling a vararg
            // function.  We don't support this, so we check that it is absent
            // here in the loader.
            //
            // That means that the legal values for this field ar 0,1,2,3.
            if (varargByte < 0 || varargByte > 3) {
                throw new IOException_1.IOException();
            }
            vararg = (0 != varargByte);
            maxstacksize = this.byteLoad();
            code = this.code();
            constant = this.constant();
            proto = this.proto(source);
            var newProto = new Proto_1.Proto();
            newProto.init1(constant, code, proto, nups, numparams, vararg, maxstacksize); //TODO:
            newProto.source = source;
            newProto.linedefined = linedefined;
            newProto.lastlinedefined = lastlinedefined;
            this.debug(newProto);
            // :todo: call code verifier
            return newProto;
        }
        /**
         * Loads and checks the binary chunk header.  Sets
         * <code>this.bigendian</code> accordingly.
         *
         * A Lua 5.1 header looks like this:
         * <pre>
             * b[0]    0x33
             * b[1..3] "Lua";
             * b[4]    0x51 (LUAC_VERSION)
             * b[5]    0 (LUAC_FORMAT)
             * b[6]    0 big-endian, 1 little-endian
             * b[7]    4 (sizeof(int))
             * b[8]    4 (sizeof(size_t))
             * b[9]    4 (sizeof(Instruction))
             * b[10]   8 (sizeof(lua_Number))
             * b[11]   0 (floating point)
             * </pre>
             *
             * To conserve JVM bytecodes the sizes of the types <code>int</code>,
             * <code>size_t</code>, <code>Instruction</code>,
             * <code>lua_Number</code> are assumed by the code to be 4, 4, 4, and
             * 8, respectively.  Where this assumption is made the tags :int:size,
             * :size_t:size :Instruction:size :lua_Number:size will appear so that
             * you can grep for them, should you wish to modify this loader to
             * load binary chunks from different architectures.
             *
             * @throws IOException  when header is malformed or not suitable.
             */
        header() {
            //TODO:Java to AS3
            var buf = new ByteArray_1.ByteArray(); // (HEADERSIZE); //byte[]
            var arrBuf = new Array(Loader.HEADERSIZE);
            for (var i = 0; i < Loader.HEADERSIZE; i++) {
                arrBuf[i] = 0;
            }
            var n;
            this.block(buf);
            for (i = 0; i < Loader.HEADERSIZE; i++) {
                arrBuf[i] = buf.readByte();
            }
            // poke the HEADER's endianness byte and compare.
            Loader.HEADER[6] = arrBuf[6];
            if (buf.get(6) < 0 || buf.get(6) > 1 || !Loader.arrayEquals(Loader.HEADER, arrBuf)) {
                throw new IOException_1.IOException();
            }
            this._bigendian = (buf.get(6) == 0);
        }
        /**
         * Undumps an int.  This method swabs accordingly.
         * size_t and Instruction need swabbing too, but the code
         * simply uses this method to load size_t and Instruction.
         */
        intLoad() {
            // :int:size  Here we assume an int is 4 bytes.
            this.block(this._intbuf);
            var i;
            // Caution: byte is signed so "&0xff" converts to unsigned value.
            if (this._bigendian) {
                i = ((this._intbuf.get(0) & 0xff) << 24) | ((this._intbuf.get(1) & 0xff) << 16) |
                    ((this._intbuf.get(2) & 0xff) << 8) | (this._intbuf.get(3) & 0xff);
            }
            else {
                i = ((this._intbuf.get(3) & 0xff) << 24) | ((this._intbuf.get(2) & 0xff) << 16) |
                    ((this._intbuf.get(1) & 0xff) << 8) | (this._intbuf.get(0) & 0xff);
            }
            return i;
            /* minimum footprint version?
            int result = 0 ;
            for (int shift = 0 ; shift < 32 ; shift+=8)
            {
                int byt = byteLoad () ;
                if (bigendian)
                result = (result << 8) | byt ;
                else
                result |= byt << shift ;
            }
            return result ;
            */
            /* another version?
            if (bigendian)
            {
                int result = byteLoad() << 24 ;
                result |= byteLoad () << 16 ;
                result |= byteLoad () << 8 ;
                result |= byteLoad () ;
                return result;
            }
            else
            {
                int result = byteLoad() ;
                result |= byteLoad () << 8 ;
                result |= byteLoad () << 16 ;
                result |= byteLoad () << 24 ;
                return result ;
            }
            */
        }
        /**
         * Undumps a Lua number.  Which is assumed to be a 64-bit IEEE double.
         */
        number() {
            // :lua_Number:size  Here we assume that the size is 8.
            this.block(this._longbuf);
            // Big-endian architectures store doubles with the sign bit first;
            // little-endian is the other way around.
            var l = 0;
            for (var i = 0; i < 8; ++i) {
                if (this._bigendian)
                    l = (l << 8) | (this._longbuf.get(i) & 0xff);
                else
                    l = (l >>> 8) | ((this._longbuf.get(i) & 0xff) << 56);
            }
            //TODO:
            var d = l; //Double.longBitsToDouble(l);
            return Lua_1.Lua.valueOfNumber(d);
        }
        /**
         * Undumps the <code>Proto</code> array contained inside a
         * <code>Proto</code> object.  These are the <code>Proto</code>
         * objects for all inner functions defined inside an existing
         * function.  Corresponds to the second half of PUC-Rio's
         * <code>LoadConstants</code> function.  See <code>constant</code> for
         * the first half.
         */
        proto(source) {
            var n = this.intLoad();
            var p = new Array(n); //Proto[] 
            for (var i = 0; i < n; ++i) {
                p[i] = this._function(source);
            }
            return p;
        }
        /**
         * Undumps a {@link String} or <code>null</code>.  As per
         * <code>LoadString</code> in
         * PUC-Rio's lundump.c.  Strings are converted from the binary
         * using the UTF-8 encoding, using the {@link
         * java.lang.String#String(byte[], String) String(byte[], String)}
         * constructor.
         */
        string() {
            // :size_t:size we assume that size_t is same size as int.
            var size = this.intLoad();
            if (size == 0) {
                return null;
            }
            //var buf:Array = new Array(size - 1); //byte[]
            var buf = new ByteArray_1.ByteArray();
            this.block(buf);
            // Discard trailing NUL byte
            if (this._in.read() == -1)
                throw new EOFException_1.EOFException();
            return buf.readUTFBytes(size - 1); //(new String(buf, "UTF-8")).intern();
        }
        /**
         * CLDC 1.1 does not provide <code>java.util.Arrays</code> so we make
         * do with this.
         */
        static arrayEquals(x, y) {
            if (x.length != y.length) {
                return false;
            }
            for (var i = 0; i < x.length; ++i) {
                if (x[i] != y[i]) {
                    return false;
                }
            }
            return true;
        }
    }
    exports.Loader = Loader;
    Loader.HEADERSIZE = 12;
    /** A chunk header that is correct.  Except for the endian byte, at
     * index 6, which is always overwritten with the one from the file,
     * before comparison.  We cope with either endianness.
     * Default access so that {@link Lua#load} can read the first entry.
     * On no account should anyone except {@link #header} modify
     * this array.
     */
    Loader.HEADER = [
        parseInt("033", 8), ('L'.charCodeAt(0)), ('u'.charCodeAt(0)), ('a'.charCodeAt(0)),
        0x51, 0, 99, 4,
        4, 4, 8, 0
    ];
});

},{"../java/ByteArray":2,"../java/EOFException":7,"../java/IOException":11,"../java/NullPointerException":16,"./LocVar":44,"./Lua":45,"./Proto":56,"./Slot":57}],44:[function(require,module,exports){
/*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/LocVar.java#1 $
 * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocVar = void 0;
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class LocVar {
        constructor() {
            this._varname = null;
            this._startpc = 0;
            this._endpc = 0;
        }
        init(varname, startpc, endpc) {
            this._varname = varname;
            this._startpc = startpc;
            this._endpc = endpc;
        }
        //新增
        get varname() {
            return this._varname;
        }
        //新增
        set varname(varname) {
            this._varname = varname;
        }
        //新增
        get startpc() {
            return this._startpc;
        }
        //新增
        set startpc(startpc) {
            this._startpc = startpc;
        }
        //新增
        get endpc() {
            return this._endpc;
        }
        //新增
        set endpc(endpc) {
            this._endpc = endpc;
        }
    }
    exports.LocVar = LocVar;
});

},{}],45:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/DataOutputStream", "../java/IOException", "../java/IllegalArgumentException", "../java/NullPointerException", "../java/NumberFormatException", "../java/OutOfMemoryError", "../java/Runtime", "../java/RuntimeException", "../java/Stack", "../java/StringBuffer", "../java/SystemUtil", "./Slot", "./LuaTable", "./CallInfo", "./LuaFunction", "./LuaJavaCallback", "./LuaUserdata", "./LuaError", "./Debug", "./StringReader", "./LuaInternal", "./UpVal", "./FormatItem", "./DumpState"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lua = void 0;
    const DataOutputStream_1 = require("../java/DataOutputStream");
    const IOException_1 = require("../java/IOException");
    const IllegalArgumentException_1 = require("../java/IllegalArgumentException");
    const NullPointerException_1 = require("../java/NullPointerException");
    const NumberFormatException_1 = require("../java/NumberFormatException");
    const OutOfMemoryError_1 = require("../java/OutOfMemoryError");
    const Runtime_1 = require("../java/Runtime");
    const RuntimeException_1 = require("../java/RuntimeException");
    const Stack_1 = require("../java/Stack");
    const StringBuffer_1 = require("../java/StringBuffer");
    const SystemUtil_1 = require("../java/SystemUtil");
    const Slot_1 = require("./Slot");
    const LuaTable_1 = require("./LuaTable");
    const CallInfo_1 = require("./CallInfo");
    const LuaFunction_1 = require("./LuaFunction");
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    const LuaUserdata_1 = require("./LuaUserdata");
    const LuaError_1 = require("./LuaError");
    const Debug_1 = require("./Debug");
    const StringReader_1 = require("./StringReader");
    const LuaInternal_1 = require("./LuaInternal");
    const UpVal_1 = require("./UpVal");
    const FormatItem_1 = require("./FormatItem");
    const DumpState_1 = require("./DumpState");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Lua.java#3 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * <p>
     * Encapsulates a Lua execution environment.  A lot of Jill's public API
     * manifests as public methods in this class.  A key part of the API is
     * the ability to call Lua functions from Java (ultimately, all Lua code
     * is executed in this manner).
     * </p>
     *
     * <p>
     * The Stack
     * </p>
     *
     * <p>
     * All arguments to Lua functions and all results returned by Lua
     * functions are placed onto a stack.  The stack can be indexed by an
     * integer in the same way as the PUC-Rio implementation.  A positive
     * index is an absolute index and ranges from 1 (the bottom-most
     * element) through to <var>n</var> (the top-most element),
     * where <var>n</var> is the number of elements on the stack.  Negative
     * indexes are relative indexes, -1 is the top-most element, -2 is the
     * element underneath that, and so on.  0 is not used.
     * </p>
     *
     * <p>
     * Note that in Jill the stack is used only for passing arguments and
     * returning results, unlike PUC-Rio.
     * </p>
     *
     * <p>
     * The protocol for calling a function is described in the {@link #call}
     * method.  In brief: push the function onto the stack, then push the
     * arguments to the call.
     * </p>
     *
     * <p>
     * The methods {@link #push}, {@link #pop}, {@link #value},
     * {@link #getTop}, {@link #setTop} are used to manipulate the stack.
     * </p>
     */
    class Lua {
        /**
         * Used to construct a Lua thread that shares its global state with
         * another Lua state.
         */
        constructor(L) {
            /** VM data stack.
            */
            this._stack = new Array(); //TODO:=0? Slot[] 
            /**
            * One more than the highest stack slot that has been written to
            * (ever).
            * Used by {@link #stacksetsize} to determine which stack slots
            * need nilling when growing the stack.
            */
            this._stackhighwater = 0; // = 0;
            /**
            * Number of active elemements in the VM stack.  Should always be
            * <code><= stack.length</code>.
            */
            this._stackSize = 0; // = 0;
            /**
            * The base stack element for this stack frame.  If in a Lua function
            * then this is the element indexed by operand field 0; if in a Java
            * functipn then this is the element indexed by Lua.value(1).
            */
            this._base = 0; // = 0;
            //TODO:public
            this._nCcalls = 0; // = 0;
            /** Instruction to resume execution at.  Index into code array. */
            this._savedpc = 0; // = 0;
            /**
            * Vector of CallInfo records.  Actually it's a Stack which is a
            * subclass of Vector, but it mostly the Vector methods that are used.
            */
            this._civ = new Stack_1.Stack();
            /** Open Upvalues.  All UpVal objects that reference the VM stack.
            * openupval is a java.util.Vector of UpVal stored in order of stack
            * slot index: higher stack indexes are stored at higher Vector
            * positions.
            */
            this._openupval = new Array(); //Vector = new Vector();
            this._hookcount = 0;
            this._basehookcount = 0;
            this._allowhook = true;
            this._hook = null;
            this._hookmask = 0;
            /**
            * The current error handler (set by {@link #pcall}).  A Lua
            * function to call.
            */
            this._errfunc = null;
            /**
            * thread activation status.
            */
            this._status = 0;
            if (L == null) {
                //Creates a fresh Lua state.
                this._global = new LuaTable_1.LuaTable();
                this._registry = new LuaTable_1.LuaTable();
                this._metatable = new Array(Lua.NUM_TAGS); //LuaTable[]
                this._main = this;
            }
            else {
                // Copy the global state, that's shared across all threads that
                // share the same main thread, into the new Lua thread.
                // Any more than this and the global state should be shunted to a
                // separate object (as it is in PUC-Rio).
                this._global = L._global;
                this._registry = L._registry;
                this._metatable = L._metatable;
                this._main = (L == null ? L : this);
            }
            //TODO:附加操作，初始化CallInfo堆栈
            this.initCiv();
        }
        //TODO:
        initCiv() {
            this._civ.addElement(new CallInfo_1.CallInfo());
        }
        /** CallInfo record for currently active function. */
        __ci() {
            return this._civ.lastElement();
        }
        /**
         * Calls a Lua value.  Normally this is called on functions, but the
         * semantics of Lua permit calls on any value as long as its metatable
         * permits it.
         *
         * In order to call a function, the function must be
         * pushed onto the stack, then its arguments must be
         * {@link #push pushed} onto the stack; the first argument is pushed
         * directly after the function,
         * then the following arguments are pushed in order (direct
         * order).  The parameter <var>nargs</var> specifies the number of
         * arguments (which may be 0).
         *
         * When the function returns the function value on the stack and all
         * the arguments are removed from the stack and replaced with the
         * results of the function, adjusted to the number specified by
         * <var>nresults</var>.  So the first result from the function call will
         * be at the same index where the function was immediately prior to
         * calling this method.
         *
         * @param nargs     The number of arguments in this function call.
         * @param nresults  The number of results required.
         */
        call(nargs, nresults) {
            this.apiChecknelems(nargs + 1);
            var func = this._stackSize - (nargs + 1);
            this.vmCall(func, nresults);
        }
        /**
         * Closes a Lua state.  In this implementation, this method does
         * nothing.
         */
        close() {
        }
        /**
         * Concatenate values (usually strings) on the stack.
         * <var>n</var> values from the top of the stack are concatenated, as
         * strings, and replaced with the resulting string.
         * @param n  the number of values to concatenate.
         */
        concat(n) {
            this.apiChecknelems(n);
            if (n >= 2) {
                this.vmConcat(n, (this._stackSize - this._base) - 1);
                this.pop(n - 1);
            }
            else if (n == 0) // push empty string
             {
                this.pushString("");
            } // else n == 1; nothing to do
        }
        /**
        * Creates a new empty table and returns it.
        * @param narr  number of array elements to pre-allocate.
        * @param nrec  number of non-array elements to pre-allocate.
        * @return a fresh table.
        * @see #newTable
        */
        createTable(narr, nrec) {
            var t = new LuaTable_1.LuaTable();
            t.init(narr, nrec);
            return t;
        }
        /**
         * Dumps a function as a binary chunk.
         * @param function  the Lua function to dump.
         * @param writer    the stream that receives the dumped binary.
         * @throws IOException when writer does.
         */
        static dump(_function, writer) {
            if (!(_function instanceof LuaFunction_1.LuaFunction)) {
                throw new IOException_1.IOException("Cannot dump " + this.typeName(this.____type(_function)));
            }
            var f = _function;
            this.uDump(f.proto, writer, false);
        }
        /**
         * Tests for equality according to the semantics of Lua's
         * <code>==</code> operator (so may call metamethods).
         * @param o1  a Lua value.
         * @param o2  another Lua value.
         * @return true when equal.
         */
        equal(o1, o2) {
            if (o1 instanceof Number || typeof (o1) == 'number') {
                return o1 === (o2);
            }
            return this.vmEqualRef(o1, o2);
        }
        /**
         * Generates a Lua error using the error message.
         * @param message  the error message.
         * @return never.
         */
        error(message) {
            return this.gErrormsg(message);
        }
        /**
        * Control garbage collector.  Note that in Jill most of the options
        * to this function make no sense and they will not do anything.
        * @param what  specifies what GC action to take.
        * @param data  data that may be used by the action.
        * @return varies.
        */
        gc(what, data) {
            var rt;
            switch (what) {
                case Lua.GCSTOP:
                    return 0;
                case Lua.GCRESTART:
                case Lua.GCCOLLECT:
                case Lua.GCSTEP:
                    SystemUtil_1.SystemUtil.gc();
                    return 0;
                case Lua.GCCOUNT:
                    rt = Runtime_1.Runtime.getRuntime();
                    return ((rt.totalMemory() - rt.freeMemory()) / 1024);
                case Lua.GCCOUNTB:
                    rt = Runtime_1.Runtime.getRuntime();
                    return ((rt.totalMemory() - rt.freeMemory()) % 1024);
                case Lua.GCSETPAUSE:
                case Lua.GCSETSTEPMUL:
                    return 0;
            }
            return 0;
        }
        /**
        * Returns the environment table of the Lua value.
        * @param o  the Lua value.
        * @return its environment table.
        */
        getFenv(o) {
            if (o instanceof LuaFunction_1.LuaFunction) {
                var f1 = o;
                return f1.env;
            }
            if (o instanceof LuaJavaCallback_1.LuaJavaCallback) {
                var f2 = o;
                // :todo: implement this case.
                return null;
            }
            if (o instanceof LuaUserdata_1.LuaUserdata) {
                var u = o;
                return u.env;
            }
            if (o instanceof Lua) {
                var l = o;
                return l.global;
            }
            return null;
        }
        /**
         * Get a field from a table (or other object).
         * @param t      The object whose field to retrieve.
         * @param field  The name of the field.
         * @return  the Lua value
         */
        getField(t, field) {
            return this.getTable(t, field);
        }
        /**
         * Get a global variable.
         * @param name  The name of the global variable.
         * @return  The value of the global variable.
         */
        getGlobal(name) {
            return this.getField(this._global, name);
        }
        /**
         * Gets the global environment.  The global environment, where global
         * variables live, is returned as a <code>LuaTable</code>.  Note that
         * modifying this table has exactly the same effect as creating or
         * changing global variables from within Lua.
         * @return  The global environment as a table.
         */
        getGlobals() {
            return this._global;
        }
        /** Get metatable.
         * @param o  the Lua value whose metatable to retrieve.
         * @return The metatable, or null if there is no metatable.
         */
        getMetatable(o) {
            var mt;
            if (o instanceof LuaTable_1.LuaTable) {
                var t = o;
                mt = t.metatable;
            }
            else if (o instanceof LuaUserdata_1.LuaUserdata) {
                var u = o;
                mt = u.metatable;
            }
            else {
                mt = this._metatable[Lua.____type(o)];
            }
            return mt;
        }
        /**
         * Gets the registry table.
         */
        getRegistry() {
            return this._registry;
        }
        /**
         * Indexes into a table and returns the value.
         * @param t  the Lua value to index.
         * @param k  the key whose value to return.
         * @return the value t[k].
         */
        getTable(t, k) {
            var s = new Slot_1.Slot();
            s.init2(k);
            var v = new Slot_1.Slot();
            this.vmGettable(t, s, v);
            return v.asObject();
        }
        /**
         * Gets the number of elements in the stack.  If the stack is not
         * empty then this is the index of the top-most element.
         * @return number of stack elements.
        */
        getTop() {
            return this._stackSize - this._base;
        }
        /**
         * Insert Lua value into stack immediately at specified index.  Values
         * in stack at that index and higher get pushed up.
         * @param o    the Lua value to insert into the stack.
         * @param idx  the stack index at which to insert.
         */
        insert(o, idx) {
            idx = this.absIndexUnclamped(idx);
            this.stackInsertAt(o, idx);
        }
        /**
         * Tests that an object is a Lua boolean.
         * @param o  the Object to test.
         * @return true if and only if the object is a Lua boolean.
         */
        static isBoolean(o) {
            return o instanceof Boolean || typeof (o) == 'boolean';
        }
        /**
         * Tests that an object is a Lua function implementated in Java (a Lua
         * Java Function).
         * @param o  the Object to test.
         * @return true if and only if the object is a Lua Java Function.
         */
        static isJavaFunction(o) {
            return o instanceof LuaJavaCallback_1.LuaJavaCallback;
        }
        /**
         * Tests that an object is a Lua function (implemented in Lua or
         * Java).
         * @param o  the Object to test.
         * @return true if and only if the object is a function.
         */
        static isFunction(o) {
            return o instanceof LuaFunction_1.LuaFunction ||
                o instanceof LuaJavaCallback_1.LuaJavaCallback;
        }
        /**
         * Tests that a Lua thread is the main thread.
         * @return true if and only if is the main thread.
         */
        isMain() {
            return this == this._main;
        }
        /**
         * Tests that an object is Lua <code>nil</code>.
         * @param o  the Object to test.
         * @return true if and only if the object is Lua <code>nil</code>.
         */
        static isNil(o) {
            return Lua.NIL == o;
        }
        /**
         * Tests that an object is a Lua number or a string convertible to a
         * number.
         * @param o  the Object to test.
         * @return true if and only if the object is a number or a convertible string.
         */
        static isNumber(o) {
            Lua.SPARE_SLOT.setObject(o);
            return Lua.tonumber(Lua.SPARE_SLOT, Lua.NUMOP);
        }
        /**
         * Tests that an object is a Lua string or a number (which is always
         * convertible to a string).
         * @param o  the Object to test.
         * @return true if and only if object is a string or number.
         */
        static isString(o) {
            return o instanceof String || o instanceof Number || typeof (o) == 'string' || typeof (o) == 'number';
        }
        /**
         * Tests that an object is a Lua table.
         * @param o  the Object to test.
         * @return <code>true</code> if and only if the object is a Lua table.
         */
        static isTable(o) {
            return o instanceof LuaTable_1.LuaTable;
        }
        /**
         * Tests that an object is a Lua thread.
         * @param o  the Object to test.
         * @return <code>true</code> if and only if the object is a Lua thread.
         */
        static isThread(o) {
            return o instanceof Lua;
        }
        /**
         * Tests that an object is a Lua userdata.
         * @param o  the Object to test.
         * @return true if and only if the object is a Lua userdata.
         */
        static isUserdata(o) {
            return o instanceof LuaUserdata_1.LuaUserdata;
        }
        /**
         * <p>
         * Tests that an object is a Lua value.  Returns <code>true</code> for
         * an argument that is a Jill representation of a Lua value,
         * <code>false</code> for Java references that are not Lua values.
         * For example <code>isValue(new LuaTable())</code> is
         * <code>true</code>, but <code>isValue(new Object[] { })</code> is
         * <code>false</code> because Java arrays are not a representation of
         * any Lua value.
         * </p>
         * <p>
         * PUC-Rio Lua provides no
         * counterpart for this method because in their implementation it is
         * impossible to get non Lua values on the stack, whereas in Jill it
         * is common to mix Lua values with ordinary, non Lua, Java objects.
         * </p>
         * @param o  the Object to test.
         * @return true if and if it represents a Lua value.
         */
        static isValue(o) {
            return o == Lua.NIL ||
                o instanceof Boolean || typeof (o) == 'boolean';
            o instanceof String || typeof (o) == 'string';
            o instanceof Number || typeof (o) == 'number';
            o instanceof LuaFunction_1.LuaFunction ||
                o instanceof LuaJavaCallback_1.LuaJavaCallback ||
                o instanceof LuaTable_1.LuaTable ||
                o instanceof LuaUserdata_1.LuaUserdata;
        }
        /**
         * Compares two Lua values according to the semantics of Lua's
         * <code>&lt;</code> operator, so may call metamethods.
         * @param o1  the left-hand operand.
         * @param o2  the right-hand operand.
         * @return true when <code>o1 < o2</code>.
         */
        lessThan(o1, o2) {
            var a = new Slot_1.Slot();
            a.init2(o1);
            var b = new Slot_1.Slot();
            b.init2(o2);
            return this.vmLessthan(a, b);
        }
        /**
         * <p>
         * Loads a Lua chunk in binary or source form.
         * Comparable to C's lua_load.  If the chunk is determined to be
         * binary then it is loaded directly.  Otherwise the chunk is assumed
         * to be a Lua source chunk and compilation is required first; the
         * <code>InputStream</code> is used to create a <code>Reader</code>
         * using the UTF-8 encoding
         * (using a second argument of <code>"UTF-8"</code> to the
         * {@link java.io.InputStreamReader#InputStreamReader(java.io.InputStream,
         * java.lang.String)}
         * constructor) and the Lua source is compiled.
         * </p>
         * <p>
         * If successful, The compiled chunk, a Lua function, is pushed onto
         * the stack and a zero status code is returned.  Otherwise a non-zero
         * status code is returned to indicate an error and the error message
         * is pushed onto the stack.
         * </p>
         * @param in         The binary chunk as an InputStream, for example from
         *                   {@link Class#getResourceAsStream}.
         * @param chunkname  The name of the chunk.
         * @return           A status code.
         */
        load(_in, chunkname) {
            var li = new LuaInternal_1.LuaInternal();
            li.init1(_in, chunkname);
            this.pushObject(li);
            return this.pcall(0, 1, null);
        }
        /**
         * Loads a Lua chunk in source form.
         * Comparable to C's lua_load.  This method takes a {@link
         * java.io.Reader} parameter,
         * and is normally used to load Lua chunks in source form.
         * However, it if the input looks like it is the output from Lua's
         * <code>string.dump</code> function then it will be processed as a
         * binary chunk.
         * In every other respect this method is just like {@link
         * #load(InputStream, String)}.
         * 废弃，合并入load
         * @param in         The source chunk as a Reader, for example from
         *                   <code>java.io.InputStreamReader(Class.getResourceAsStream())</code>.
         * @param chunkname  The name of the chunk.
         * @return           A status code.
         * @see java.io.InputStreamReader
         */
        __load(_in, chunkname) {
            var li = new LuaInternal_1.LuaInternal();
            li.init2(_in, chunkname);
            this.pushObject(li);
            return this.pcall(0, 1, null);
        }
        /**
         * Slowly get the next key from a table.  Unlike most other functions
         * in the API this one uses the stack.  The top-of-stack is popped and
         * used to find the next key in the table at the position specified by
         * index.  If there is a next key then the key and its value are
         * pushed onto the stack and <code>true</code> is returned.
         * Otherwise (the end of the table has been reached)
         * <code>false</code> is returned.
         * @param idx  stack index of table.
         * @return  true if and only if there are more keys in the table.
         * @deprecated Use {@link #tableKeys} enumeration protocol instead.
         */
        next(idx) {
            var o = this.value(idx);
            // :todo: api check
            var t = o;
            var key = this.value(-1);
            this.pop(1);
            var e = t.keys();
            if (key == Lua.NIL) {
                if (e.hasMoreElements()) {
                    key = e.nextElement();
                    this.pushObject(key);
                    this.pushObject(t.getlua(key));
                    return true;
                }
                return false;
            }
            while (e.hasMoreElements()) {
                var k = e.nextElement();
                if (k === (key)) {
                    if (e.hasMoreElements()) {
                        key = e.nextElement();
                        this.pushObject(key);
                        this.pushObject(t.getlua(key));
                        return true;
                    }
                    return false;
                }
            }
            // protocol error which we could potentially diagnose.
            return false;
        }
        /**
         * Creates a new empty table and returns it.
         * @return a fresh table.
         * @see #createTable
         */
        newTable() {
            return new LuaTable_1.LuaTable();
        }
        /**
         * Creates a new Lua thread and returns it.
         * @return a new Lua thread.
         */
        newThread() {
            return new Lua(this);
        }
        /**
         * Wraps an arbitrary Java reference in a Lua userdata and returns it.
         * @param ref  the Java reference to wrap.
         * @return the new LuaUserdata.
         */
        newUserdata(ref) {
            return new LuaUserdata_1.LuaUserdata(ref);
        }
        /**
         * Return the <em>length</em> of a Lua value.  For strings this is
         * the string length; for tables, this is result of the <code>#</code>
         * operator; for other values it is 0.
         * @param o  a Lua value.
         * @return its length.
         */
        static objLen(o) {
            if (o instanceof String || typeof (o) == 'string') {
                var s = o;
                return s.length;
            }
            if (o instanceof LuaTable_1.LuaTable) {
                var t = o;
                return t.getn();
            }
            if (o instanceof Number || typeof (o) == 'number') {
                return this.vmTostring(o).length;
            }
            return 0;
        }
        /**
         * <p>
         * Protected {@link #call}.  <var>nargs</var> and
         * <var>nresults</var> have the same meaning as in {@link #call}.
         * If there are no errors during the call, this method behaves as
         * {@link #call}.  Any errors are caught, the error object (usually
         * a message) is pushed onto the stack, and a non-zero error code is
         * returned.
         * </p>
         * <p>
         * If <var>er</var> is <code>null</code> then the error object that is
         * on the stack is the original error object.  Otherwise
         * <var>ef</var> specifies an <em>error handling function</em> which
         * is called when the original error is generated; its return value
         * becomes the error object left on the stack by <code>pcall</code>.
         * </p>
         * @param nargs     number of arguments.
         * @param nresults  number of result required.
         * @param ef        error function to call in case of error.
         * @return 0 if successful, else a non-zero error code.
         */
        pcall(nargs, nresults, ef) {
            this.apiChecknelems(nargs + 1);
            var restoreStack = this._stackSize - (nargs + 1);
            // Most of this code comes from luaD_pcall
            var restoreCi = this._civ.size;
            var oldnCcalls = this._nCcalls;
            var old_errfunc = this._errfunc;
            this._errfunc = ef;
            var old_allowhook = this._allowhook;
            var errorStatus = 0;
            try {
                this.call(nargs, nresults);
            }
            catch (e) {
                if (e instanceof LuaError_1.LuaError) {
                    console.log(e.stack);
                    this.fClose(restoreStack); // close eventual pending closures
                    this.dSeterrorobj(e.errorStatus, restoreStack);
                    this._nCcalls = oldnCcalls;
                    this._civ.size = restoreCi;
                    var ci = this.__ci();
                    this._base = ci.base;
                    this._savedpc = ci.savedpc;
                    this._allowhook = old_allowhook;
                    errorStatus = e.errorStatus;
                }
                else if (e instanceof OutOfMemoryError_1.OutOfMemoryError) {
                    console.log(e.stack);
                    this.fClose(restoreStack); // close eventual pending closures
                    this.dSeterrorobj(Lua.ERRMEM, restoreStack);
                    this._nCcalls = oldnCcalls;
                    this._civ.size = restoreCi;
                    var ci2 = this.__ci();
                    this._base = ci2.base;
                    this._savedpc = ci2.savedpc;
                    this._allowhook = old_allowhook;
                    errorStatus = Lua.ERRMEM;
                }
            }
            /**/
            this._errfunc = old_errfunc;
            return errorStatus;
        }
        /**
         * Removes (and discards) the top-most <var>n</var> elements from the stack.
         * @param n  the number of elements to remove.
         */
        pop(n) {
            if (n < 0) {
                throw new IllegalArgumentException_1.IllegalArgumentException();
            }
            this.stacksetsize(this._stackSize - n);
        }
        /**
         * Pushes a value onto the stack in preparation for calling a
         * function (or returning from one).  See {@link #call} for
         * the protocol to be used for calling functions.  See {@link
         * #pushNumber} for pushing numbers, and {@link #pushValue} for
         * pushing a value that is already on the stack.
         * @param o  the Lua value to push.
         */
        pushObject(o) {
            // see also a private overloaded version of this for Slot.
            this.stackAdd(o);
        }
        /**
         * Push boolean onto the stack.
         * @param b  the boolean to push.
         */
        pushBoolean(b) {
            this.pushObject(Lua.valueOfBoolean(b));
        }
        /**
         * Push literal string onto the stack.
         * @param s  the string to push.
         */
        pushLiteral(s) {
            this.pushObject(s);
        }
        /** Push nil onto the stack. */
        pushNil() {
            this.pushObject(Lua.NIL);
        }
        /**
        * Pushes a number onto the stack.  See also {@link #push}.
        * @param d  the number to push.
        */
        pushNumber(d) {
            // :todo: optimise to avoid creating Double instance
            this.pushObject(new Number(d));
        }
        /**
         * Push string onto the stack.
         * @param s  the string to push.
         */
        pushString(s) {
            this.pushObject(s);
        }
        /**
         * Copies a stack element onto the top of the stack.
         * Equivalent to <code>L.push(L.value(idx))</code>.
         * @param idx  stack index of value to push.
         */
        pushValue(idx) {
            // :todo: optimised to avoid creating Double instance
            this.pushObject(this.value(idx));
        }
        /**
         * Implements equality without metamethods.
         * @param o1  the first Lua value to compare.
         * @param o2  the other Lua value.
         * @return  true if and only if they compare equal.
         */
        static rawEqual(o1, o2) {
            return Lua.oRawequal(o1, o2);
        }
        /**
         * Gets an element from a table, without using metamethods.
         * @param t  The table to access.
         * @param k  The index (key) into the table.
         * @return The value at the specified index.
         */
        static rawGet(t, k) {
            var table = t;
            return table.getlua(k);
        }
        /**
        * Gets an element from an array, without using metamethods.
        * @param t  the array (table).
        * @param i  the index of the element to retrieve.
        * @return  the value at the specified index.
        */
        static rawGetI(t, i) {
            var table = t;
            return table.getnum(i);
        }
        /**
         * Sets an element in a table, without using metamethods.
         * @param t  The table to modify.
         * @param k  The index into the table.
         * @param v  The new value to be stored at index <var>k</var>.
         */
        rawSet(t, k, v) {
            var table = t;
            table.putluaObj(this, k, v);
        }
        /**
        * Sets an element in an array, without using metamethods.
        * @param t  the array (table).
        * @param i  the index of the element to set.
        * @param v  the new value to be stored at index <var>i</var>.
        */
        rawSetI(t, i, v) {
            this.apiCheck(t instanceof LuaTable_1.LuaTable);
            var h = t;
            h.putnum(i, v);
        }
        /**
         * Register a {@link LuaJavaCallback} as the new value of the global
         * <var>name</var>.
         * @param name  the name of the global.
         * @param f     the LuaJavaCallback to register.
         */
        register(name, f) {
            this.setGlobal(name, f);
        }
        /**
         * Starts and resumes a Lua thread.  Threads can be created using
         * {@link #newThread}.  Once a thread has begun executing it will
         * run until it either completes (with error or normally) or has been
         * suspended by invoking {@link #yield}.
         * @param narg  Number of values to pass to thread.
         * @return Lua.YIELD, 0, or an error code.
         */
        resume(narg) {
            if (this.status != Lua.YIELD) {
                if (this.status != 0)
                    return this.resume_error("cannot resume dead coroutine");
                else if (this._civ.size != 1)
                    return this.resume_error("cannot resume non-suspended coroutine");
            }
            // assert errfunc == 0 && nCcalls == 0;
            var errorStatus = 0;
            protect: try {
                // This block is equivalent to resume from ldo.c
                var firstArg = this._stackSize - narg;
                if (this.status == 0) // start coroutine?
                 {
                    // assert civ.size() == 1 && firstArg > base);
                    if (this.vmPrecall(firstArg - 1, Lua.MULTRET) != Lua.PCRLUA)
                        break protect;
                }
                else // resuming from previous yield
                 {
                    // assert status == YIELD;
                    this.status = 0;
                    if (!this.isLua(this.__ci())) // 'common' yield
                     {
                        // finish interrupted execution of 'OP_CALL'
                        // assert ...
                        if (this.vmPoscall(firstArg)) // complete it...
                            this.stacksetsize(this.__ci().top); // and correct top
                    }
                    else // yielded inside a hook: just continue its execution
                        this._base = this.__ci().base;
                }
                this.vmExecute(this._civ.size - 1);
            }
            catch (e) {
                if (e instanceof LuaError_1.LuaError) {
                    console.log(e.stack);
                    this.status = e.errorStatus; // mark thread as 'dead'
                    this.dSeterrorobj(e.errorStatus, this._stackSize);
                    this.__ci().top = this._stackSize;
                }
            }
            return this.status;
        }
        /**
        * Set the environment for a function, thread, or userdata.
        * @param o      Object whose environment will be set.
        * @param table  Environment table to use.
        * @return true if the object had its environment set, false otherwise.
        */
        setFenv(o, table) {
            // :todo: consider implementing common env interface for
            // LuaFunction, LuaJavaCallback, LuaUserdata, Lua.  One cast to an
            // interface and an interface method call may be shorter
            // than this mess.
            var t = table;
            if (o instanceof LuaFunction_1.LuaFunction) {
                var f1 = o;
                f1.env = t;
                return true;
            }
            if (o instanceof LuaJavaCallback_1.LuaJavaCallback) {
                var f2 = o;
                // :todo: implement this case.
                return false;
            }
            if (o instanceof LuaUserdata_1.LuaUserdata) {
                var u = o;
                u.env = t;
                return true;
            }
            if (o instanceof Lua) {
                var l = o;
                l.global = t;
                return true;
            }
            return false;
        }
        /**
         * Set a field in a Lua value.
         * @param t     Lua value of which to set a field.
         * @param name  Name of field to set.
         * @param v     new Lua value for field.
         */
        setField(t, name, v) {
            var s = new Slot_1.Slot();
            s.init2(name);
            this.vmSettable(t, s, v);
        }
        /**
        * Sets the metatable for a Lua value.
        * @param o   Lua value of which to set metatable.
        * @param mt  The new metatable.
        */
        setMetatable(o, mt) {
            if (Lua.isNil(mt)) {
                mt = null;
            }
            else {
                this.apiCheck(mt instanceof LuaTable_1.LuaTable);
            }
            var mtt = mt;
            if (o instanceof LuaTable_1.LuaTable) {
                var t = o;
                t.setMetatable(mtt);
            }
            else if (o instanceof LuaUserdata_1.LuaUserdata) {
                var u = o;
                u.metatable = mtt;
            }
            else {
                this._metatable[Lua.____type(o)] = mtt;
            }
        }
        /**
         * Set a global variable.
         * @param name   name of the global variable to set.
         * @param value  desired new value for the variable.
         */
        setGlobal(name, value) {
            var s = new Slot_1.Slot();
            s.init2(name);
            this.vmSettable(this._global, s, value);
        }
        /**
         * Does the equivalent of <code>t[k] = v</code>.
         * @param t  the table to modify.
         * @param k  the index to modify.
         * @param v  the new value at index <var>k</var>.
         */
        setTable(t, k, v) {
            var s = new Slot_1.Slot();
            s.init2(k);
            this.vmSettable(t, s, v);
        }
        /**
        * Set the stack top.
        * @param n  the desired size of the stack (in elements).
        */
        setTop(n) {
            if (n < 0) {
                throw new IllegalArgumentException_1.IllegalArgumentException();
            }
            this.stacksetsize(this._base + n);
        }
        /**
         * Status of a Lua thread.
         * @return 0, an error code, or Lua.YIELD.
         */
        get status() {
            return this._status;
        }
        set status(status) {
            this._status = status;
        }
        /**
         * Returns an {@link java.util.Enumeration} for the keys of a table.
         * @param t  a Lua table.
         * @return an Enumeration object.
         */
        tableKeys(t) {
            if (!(t instanceof LuaTable_1.LuaTable)) {
                this.error("table required");
                // NOTREACHED
            }
            return t.keys();
        }
        /**
         * Convert to boolean.
         * @param o  Lua value to convert.
         * @return  the resulting primitive boolean.
         */
        toBoolean(o) {
            return !(o == Lua.NIL || o == false);
        }
        /**
         * Convert to integer and return it.  Returns 0 if cannot be
         * converted.
         * @param o  Lua value to convert.
         * @return  the resulting int.
         */
        toInteger(o) {
            return this.toNumber(o);
        }
        /**
         * Convert to number and return it.  Returns 0 if cannot be
         * converted.
         * @param o  Lua value to convert.
         * @return  The resulting number.
         */
        toNumber(o) {
            Lua.SPARE_SLOT.setObject(o);
            if (Lua.tonumber(Lua.SPARE_SLOT, Lua.NUMOP)) {
                return Lua.NUMOP[0];
            }
            return 0;
        }
        /**
         * Convert to string and return it.  If value cannot be converted then
         * <code>null</code> is returned.  Note that unlike
         * <code>lua_tostring</code> this
         * does not modify the Lua value.
         * @param o  Lua value to convert.
         * @return  The resulting string.
         */
        toString_(o) {
            return Lua.vmTostring(o);
        }
        /**
         * Convert to Lua thread and return it or <code>null</code>.
         * @param o  Lua value to convert.
         * @return  The resulting Lua instance.
         */
        toThread(o) {
            if (!(o instanceof Lua)) {
                return null;
            }
            return o;
        }
        /**
         * Convert to userdata or <code>null</code>.  If value is a {@link
         * LuaUserdata} then it is returned, otherwise, <code>null</code> is
         * returned.
         * @param o  Lua value.
         * @return  value as userdata or <code>null</code>.
         */
        toUserdata(o) {
            if (o instanceof LuaUserdata_1.LuaUserdata) {
                return o;
            }
            return null;
        }
        /**
         * Type of the Lua value at the specified stack index.
         * @param idx  stack index to type.
         * @return  the type, or {@link #TNONE} if there is no value at <var>idx</var>
         */
        type(idx) {
            idx = this.absIndex(idx);
            if (idx < 0) {
                return Lua.TNONE;
            }
            return this.___type(this._stack[idx]);
        }
        /**
         * 废弃，并入type
         * @param	s
         * @return
         */
        ___type(s) {
            if (s.r == Lua.NUMBER) {
                return Lua.TNUMBER;
            }
            return Lua.____type(s.r);
        }
        /**
         * Type of a Lua value.
         * 废弃，并入type
         * @param o  the Lua value whose type to return.
         * @return  the Lua type from an enumeration.
         */
        static ____type(o) {
            if (o == Lua.NIL) {
                return Lua.TNIL;
            }
            else if (o instanceof Number || (typeof (o) == 'string')) {
                return Lua.TNUMBER;
            }
            else if (o instanceof Boolean || (typeof (o) == 'boolean')) {
                return Lua.TBOOLEAN;
            }
            else if (o instanceof String) {
                return Lua.TSTRING;
            }
            else if (o instanceof LuaTable_1.LuaTable) {
                return Lua.TTABLE;
            }
            else if (o instanceof LuaFunction_1.LuaFunction || o instanceof LuaJavaCallback_1.LuaJavaCallback) {
                return Lua.TFUNCTION;
            }
            else if (o instanceof LuaUserdata_1.LuaUserdata) {
                return Lua.TUSERDATA;
            }
            else if (o instanceof Lua) {
                return Lua.TTHREAD;
            }
            return Lua.TNONE;
        }
        /**
         * Name of type.
         * @param type  a Lua type from, for example, {@link #type}.
         * @return  the type's name.
         */
        static typeName(type) {
            if (Lua.TNONE == type) {
                return "no value";
            }
            return Lua.TYPENAME[type];
        }
        /**
         * Gets a value from the stack.
         * If <var>idx</var> is positive and exceeds
         * the size of the stack, {@link #NIL} is returned.
         * @param idx  the stack index of the value to retrieve.
         * @return  the Lua value from the stack.
         */
        value(idx) {
            idx = this.absIndex(idx);
            if (idx < 0) {
                return Lua.NIL;
            }
            return this._stack[idx].asObject();
        }
        /**
        * Converts primitive boolean into a Lua value.
        * @param b  the boolean to convert.
        * @return  the resulting Lua value.
        */
        static valueOfBoolean(b) {
            // If CLDC 1.1 had
            // <code>java.lang.Boolean.valueOf(boolean);</code> then I probably
            // wouldn't have written this.  This does have a small advantage:
            // code that uses this method does not need to assume that Lua booleans in
            // Jill are represented using Java.lang.Boolean.
            if (b) {
                return true;
            }
            else {
                return false;
            }
        }
        /**
         * Converts primitive number into a Lua value.
         * @param d  the number to convert.
         * @return  the resulting Lua value.
         */
        static valueOfNumber(d) {
            // :todo: consider interning "common" numbers, like 0, 1, -1, etc.
            return new Number(d);
        }
        /**
        * Exchange values between different threads.
        * @param to  destination Lua thread.
        * @param n   numbers of stack items to move.
        */
        xmove(to, n) {
            if (this == to) {
                return;
            }
            this.apiChecknelems(n);
            // L.apiCheck(from.G() == to.G());
            for (var i = 0; i < n; ++i) {
                to.pushObject(this.value(-n + i));
            }
            this.pop(n);
        }
        /**
         * Yields a thread.  Should only be called as the return expression
         * of a Lua Java function: <code>return L.yield(nresults);</code>.
         * A {@link RuntimeException} can also be thrown to yield.  If the
         * Java code that is executing throws an instance of {@link
         * RuntimeException} (direct or indirect) then this causes the Lua
         * thread to be suspended, as if <code>L.yield(0);</code> had been
         * executed, and the exception is re-thrown to the code that invoked
         * {@link #resume}.
         * @param nresults  Number of results to return to {@link #resume}.
         * @return  a secret value.
         */
        yield(nresults) {
            if (this._nCcalls > 0)
                this.gRunerror("attempt to yield across metamethod/Java-call boundary");
            this._base = this._stackSize - nresults; // protect stack slots below
            this.status = Lua.YIELD;
            return -1;
        }
        // Miscellaneous private functions.
        /** Convert from Java API stack index to absolute index.
         * @return an index into <code>this.stack</code> or -1 if out of range.
         */
        absIndex(idx) {
            var s = this._stackSize;
            if (idx == 0) {
                return -1;
            }
            if (idx > 0) {
                if (idx + this._base > s) {
                    return -1;
                }
                return this._base + idx - 1;
            }
            // idx < 0
            if (s + idx < this._base) {
                return -1;
            }
            return s + idx;
        }
        /**
        * As {@link #absIndex} but does not return -1 for out of range
        * indexes.  Essential for {@link #insert} because an index equal
        * to the size of the stack is valid for that call.
        */
        absIndexUnclamped(idx) {
            if (idx == 0) {
                return -1;
            }
            if (idx > 0) {
                return this._base + idx - 1;
            }
            // idx < 0
            return this._stackSize + idx;
        }
        //////////////////////////////////////////////////////////////////////
        // Auxiliary API
        // :todo: consider placing in separate class (or macroised) so that we
        // can change its definition (to remove the check for example).
        apiCheck(cond) {
            if (!cond) {
                throw new IllegalArgumentException_1.IllegalArgumentException();
            }
        }
        apiChecknelems(n) {
            this.apiCheck(n <= this._stackSize - this._base);
        }
        /**
         * Checks a general condition and raises error if false.
         * @param cond      the (evaluated) condition to check.
         * @param numarg    argument index.
         * @param extramsg  extra error message to append.
         */
        argCheck(cond, numarg, extramsg) {
            if (cond) {
                return;
            }
            this.argError(numarg, extramsg);
        }
        /**
         * Raise a general error for an argument.
         * @param narg      argument index.
         * @param extramsg  extra message string to append.
         * @return never (used idiomatically in <code>return argError(...)</code>)
         */
        argError(narg, extramsg) {
            // :todo: use debug API as per PUC-Rio
            if (true) {
                return this.error("bad argument " + narg + " (" + extramsg + ")");
            }
            return 0;
        }
        /**
         * Calls a metamethod.  Pushes 1 result onto stack if method called.
         * @param obj    stack index of object whose metamethod to call
         * @param event  metamethod (event) name.
         * @return  true if and only if metamethod was found and called.
         */
        callMeta(obj, event) {
            var o = this.value(obj);
            var ev = this.getMetafield(o, event);
            if (ev == Lua.NIL) {
                return false;
            }
            this.pushObject(ev);
            this.pushObject(o);
            this.call(1, 1);
            return true;
        }
        /**
         * Checks that an argument is present (can be anything).
         * Raises error if not.
         * @param narg  argument index.
         */
        checkAny(narg) {
            if (this.type(narg) == Lua.TNONE) {
                this.argError(narg, "value expected");
            }
        }
        /**
         * Checks is a number and returns it as an integer.  Raises error if
         * not a number.
         * @param narg  argument index.
         * @return  the argument as an int.
         */
        checkInt(narg) {
            return this.checkNumber(narg);
        }
        /**
         * Checks is a number.  Raises error if not a number.
         * @param narg  argument index.
         * @return  the argument as a double.
         */
        checkNumber(narg) {
            var o = this.value(narg);
            var d = this.toNumber(o);
            if (d == 0 && !Lua.isNumber(o)) {
                this.tagError(narg, Lua.TNUMBER);
            }
            return d;
        }
        /**
         * Checks that an optional string argument is an element from a set of
         * strings.  Raises error if not.
         * @param narg  argument index.
         * @param def   default string to use if argument not present.
         * @param lst   the set of strings to match against.
         * @return an index into <var>lst</var> specifying the matching string.
         */
        checkOption(narg, def, lst /*String[] */) {
            var name;
            if (def == null) {
                name = this.checkString(narg);
            }
            else {
                name = this.optString(narg, def);
            }
            for (var i = 0; i < lst.length; ++i) {
                if (lst[i] === (name)) {
                    return i;
                }
            }
            return this.argError(narg, "invalid option '" + name + "'");
        }
        /**
         * Checks argument is a string and returns it.  Raises error if not a
         * string.
         * @param narg  argument index.
         * @return  the argument as a string.
         */
        checkString(narg) {
            var s = this.toString_(this.value(narg));
            if (s == null) {
                this.tagError(narg, Lua.TSTRING);
            }
            return s;
        }
        /**
         * Checks the type of an argument, raises error if not matching.
         * @param narg  argument index.
         * @param t     typecode (from {@link #type} for example).
         */
        checkType(narg, t) {
            if (this.type(narg) != t) {
                this.tagError(narg, t);
            }
        }
        /**
         * Loads and runs the given string.
         * @param s  the string to run.
         * @return  a status code, as per {@link #load}.
         */
        doString(s) {
            var status = this.__load(Lua.stringReader(s), s);
            if (status == 0) {
                status = this.pcall(0, Lua.MULTRET, null);
            }
            return status;
        }
        errfile(what, fname, e) {
            this.pushString("cannot " + what + " " + fname + ": " + e.toString());
            return Lua.ERRFILE;
        }
        /**
         * Equivalent to luaL_findtable.  Instead of the table being passed on
         * the stack, it is passed as the argument <var>t</var>.
         * Likes its PUC-Rio equivalent however, this method leaves a table on
         * the Lua stack.
         */
        findTable(t, fname, szhint) {
            var e = 0;
            var i = 0;
            do {
                e = fname.indexOf('.', i);
                var part;
                if (e < 0) {
                    part = fname.substring(i);
                }
                else {
                    part = fname.substring(i, e);
                }
                var v = Lua.rawGet(t, part);
                if (Lua.isNil(v)) // no such field?
                 {
                    v = this.createTable(0, (e >= 0) ? 1 : szhint); // new table for field
                    this.setTable(t, part, v);
                }
                else if (!Lua.isTable(v)) // field has a non-table value?
                 {
                    return part;
                }
                t = v;
                i = e + 1;
            } while (e >= 0);
            this.pushObject(t);
            return null;
        }
        /**
         * Get a field (event) from an Lua value's metatable.  Returns Lua
         * <code>nil</code> if there is either no metatable or no field.
         * @param o           Lua value to get metafield for.
         * @param event       name of metafield (event).
         * @return            the field from the metatable, or nil.
         */
        getMetafield(o, event) {
            var mt = this.getMetatable(o);
            if (mt == null) {
                return Lua.NIL;
            }
            return mt.getlua(event);
        }
        isNoneOrNil(narg) {
            return this.type(narg) <= Lua.TNIL;
        }
        /**
         * Loads a Lua chunk from a file.  The <var>filename</var> argument is
         * used in a call to {@link Class#getResourceAsStream} where
         * <code>this</code> is the {@link Lua} instance, thus relative
         * pathnames will be relative to the location of the
         * <code>Lua.class</code> file.  Pushes compiled chunk, or error
         * message, onto stack.
         * @param filename  location of file.
         * @return status code, as per {@link #load}.
         */
        loadFile(filename) {
            if (filename == null) {
                throw new NullPointerException_1.NullPointerException();
            }
            var _in = SystemUtil_1.SystemUtil.getResourceAsStream(filename); //TODO:
            if (_in == null) {
                return this.errfile("open", filename, new IOException_1.IOException());
            }
            var status = 0;
            try {
                _in.mark(1);
                var c = _in.read();
                if (c == '#'.charCodeAt(0)) // Unix exec. file?
                 {
                    // :todo: handle this case
                }
                _in.reset();
                status = this.load(_in, "@" + filename);
            }
            catch (e) {
                if (e instanceof IOException_1.IOException) {
                    console.log(e.stack);
                    return this.errfile("read", filename, e);
                }
            }
            return status;
        }
        /**
         * Loads a Lua chunk from a string.  Pushes compiled chunk, or error
         * message, onto stack.
         * @param s           the string to load.
         * @param chunkname   the name of the chunk.
         * @return status code, as per {@link #load}.
         */
        loadString(s, chunkname) {
            return this.__load(Lua.stringReader(s), chunkname);
        }
        /**
         * Get optional integer argument.  Raises error if non-number
         * supplied.
         * @param narg  argument index.
         * @param def   default value for integer.
         * @return an int.
         */
        optInt(narg, def) {
            if (this.isNoneOrNil(narg)) {
                return def;
            }
            return this.checkInt(narg);
        }
        /**
         * Get optional number argument.  Raises error if non-number supplied.
         * @param narg  argument index.
         * @param def   default value for number.
         * @return a double.
         */
        optNumber(narg, def) {
            if (this.isNoneOrNil(narg)) {
                return def;
            }
            return this.checkNumber(narg);
        }
        /**
         * Get optional string argument.  Raises error if non-string supplied.
         * @param narg  argument index.
         * @param def   default value for string.
         * @return a string.
         */
        optString(narg, def) {
            if (this.isNoneOrNil(narg)) {
                return def;
            }
            return this.checkString(narg);
        }
        /**
         * Creates a table in the global namespace and registers it as a loaded
         * module.
         * @return the new table
         */
        __register(name) {
            this.findTable(this._registry, Lua.LOADED, 1);
            var loaded = this.value(-1);
            this.pop(1);
            var t = this.getField(loaded, name);
            if (!Lua.isTable(t)) // not found?
             {
                // try global variable (and create one if it does not exist)
                if (this.findTable(this.getGlobals(), name, 0) != null) {
                    this.error("name conflict for module '" + name + "'");
                }
                t = this.value(-1);
                this.pop(1);
                this.setField(loaded, name, t); // _LOADED[name] = new table
            }
            return t;
        }
        tagError(narg, tag) {
            this.typerror(narg, Lua.typeName(tag));
        }
        /**
         * Name of type of value at <var>idx</var>.
         * @param idx  stack index.
         * @return  the name of the value's type.
         */
        typeNameOfIndex(idx) {
            return Lua.TYPENAME[this.type(idx)];
        }
        /**
         * Declare type error in argument.
         * @param narg   Index of argument.
         * @param tname  Name of type expected.
         */
        typerror(narg, tname) {
            this.argError(narg, tname + " expected, got " + this.typeNameOfIndex(narg));
        }
        /**
         * Return string identifying current position of the control at level
         * <var>level</var>.
         * @param level  specifies the call-stack level.
         * @return a description for that level.
         */
        where(level) {
            var ar = this.getStack(level); // check function at level
            if (ar != null) {
                this.getInfo("Sl", ar); // get info about it
                if (ar.currentline > 0) // is there info?
                 {
                    return ar.shortsrc + ":" + ar.currentline + ": ";
                }
            }
            return ""; // else, no information available...
        }
        /**
         * Provide {@link java.io.Reader} interface over a <code>String</code>.
         * Equivalent of {@link java.io.StringReader#StringReader} from J2SE.
         * The ability to convert a <code>String</code> to a
         * <code>Reader</code> is required internally,
         * to provide the Lua function <code>loadstring</code>; exposed
         * externally as a convenience.
         * @param s  the string from which to read.
         * @return a {@link java.io.Reader} that reads successive chars from <var>s</var>.
         */
        static stringReader(s) {
            return new StringReader_1.StringReader(s);
        }
        //////////////////////////////////////////////////////////////////////
        // Debug
        // Methods equivalent to debug API.  In PUC-Rio most of these are in
        // ldebug.c
        getInfo(what, ar) {
            var f = null;
            var callinfo = null;
            // :todo: complete me
            if (ar.ici > 0) // no tail call?
             {
                callinfo = this._civ.elementAt(ar.ici);
                f = this._stack[callinfo.func].r;
                //# assert isFunction(f)
            }
            var status = this.auxgetinfo(what, ar, f, callinfo);
            if (what.indexOf('f') >= 0) {
                if (f == null) {
                    this.pushObject(Lua.NIL);
                }
                else {
                    this.pushObject(f);
                }
            }
            return status;
        }
        /**
         * Locates function activation at specified call level and returns a
         * {@link Debug}
         * record for it, or <code>null</code> if level is too high.
         * May become public.
         * @param level  the call level.
         * @return a {@link Debug} instance describing the activation record.
         */
        getStack(level) {
            var ici; // Index of CallInfo
            for (ici = this._civ.size - 1; level > 0 && ici > 0; --ici) {
                var ci = this._civ.elementAt(ici);
                --level;
                if (this.isLua(ci)) // Lua function?
                 {
                    level -= ci.tailcalls; // skip lost tail calls
                }
            }
            if (level == 0 && ici > 0) // level found?
             {
                return new Debug_1.Debug(ici);
            }
            else if (level < 0) // level is of a lost tail call?
             {
                return new Debug_1.Debug(0);
            }
            return null;
        }
        /**
         * Sets the debug hook.
         */
        setHook(func, mask, count) {
            if (func == null || mask == 0) // turn off hooks?
             {
                mask = 0;
                func = null;
            }
            this._hook = func;
            this._basehookcount = count;
            this.resethookcount();
            this._hookmask = mask;
        }
        /**
         * @return true is okay, false otherwise (for example, error).
         */
        auxgetinfo(what, ar, f, ci) {
            var status = true;
            if (f == null) {
                // :todo: implement me
                return status;
            }
            for (var i = 0; i < what.length; ++i) {
                switch (what.charAt(i)) {
                    case 'S':
                        this.funcinfo(ar, f);
                        break;
                    case 'l':
                        ar.currentline = (ci != null) ? this.currentline(ci) : -1;
                        break;
                    case 'f': // handled by getInfo
                        break;
                    // :todo: more cases.
                    default:
                        status = false;
                }
            }
            return status;
        }
        currentline(ci) {
            var pc = this.currentpc(ci);
            if (pc < 0) {
                return -1; // only active Lua functions have current-line info
            }
            else {
                var faso = this._stack[ci.func].r;
                var f = faso;
                return f.proto.getline(pc);
            }
        }
        currentpc(ci) {
            if (!this.isLua(ci)) // function is not a Lua function?
             {
                return -1;
            }
            if (ci == this.__ci()) {
                ci.savedpc = this._savedpc;
            }
            return Lua.pcRel(ci.savedpc);
        }
        funcinfo(ar, cl) {
            if (cl instanceof LuaJavaCallback_1.LuaJavaCallback) {
                ar.source = "=[Java]";
                ar.linedefined = -1;
                ar.lastlinedefined = -1;
                ar.what = "Java";
            }
            else {
                var p = cl.proto;
                ar.source = p.source;
                ar.linedefined = p.linedefined;
                ar.lastlinedefined = p.lastlinedefined;
                ar.what = ar.linedefined == 0 ? "main" : "Lua";
            }
        }
        /** Equivalent to macro isLua _and_ f_isLua from lstate.h. */
        isLua(callinfo) {
            var f = this._stack[callinfo.func].r;
            return f instanceof LuaFunction_1.LuaFunction;
        }
        static pcRel(pc) {
            return pc - 1;
        }
        //////////////////////////////////////////////////////////////////////
        // Do
        // Methods equivalent to the file ldo.c.  Prefixed with d.
        // Some of these are in vm* instead.
        /**
        * Equivalent to luaD_callhook.
        */
        dCallhook(event, line) {
            var hook = this._hook;
            if (hook != null && this._allowhook) {
                var top = this._stackSize;
                var ci_top = this.__ci().top;
                var ici = this._civ.size - 1;
                if (event == Lua.HOOKTAILRET) // not supported yet
                 {
                    ici = 0;
                }
                var ar = new Debug_1.Debug(ici);
                ar.event = event;
                ar.currentline = line;
                this.__ci().top = this._stackSize;
                this._allowhook = false; // cannot call hooks inside a hook
                hook.luaHook(this, ar);
                //# assert !allowhook
                this._allowhook = true;
                this.__ci().top = ci_top;
                this.stacksetsize(top);
            }
        }
        /** Equivalent to luaD_seterrorobj.  It is valid for oldtop to be
        * equal to the current stack size (<code>stackSize</code>).
        * {@link #resume} uses this value for oldtop.
        */
        dSeterrorobj(errcode, oldtop) {
            var msg = this.objectAt(this._stackSize - 1);
            if (this._stackSize == oldtop) {
                this.stacksetsize(oldtop + 1);
            }
            switch (errcode) {
                case Lua.ERRMEM:
                    this._stack[oldtop].r = Lua.MEMERRMSG;
                    break;
                case Lua.ERRERR:
                    this._stack[oldtop].r = "error in error handling";
                    break;
                case Lua.ERRFILE:
                case Lua.ERRRUN:
                case Lua.ERRSYNTAX:
                    this.setObjectAt(msg, oldtop);
                    break;
            }
            this.stacksetsize(oldtop + 1);
        }
        dThrow(status) {
            throw new LuaError_1.LuaError(status);
        }
        //////////////////////////////////////////////////////////////////////
        // Func
        // Methods equivalent to the file lfunc.c.  Prefixed with f.
        /** Equivalent of luaF_close.  All open upvalues referencing stack
         * slots level or higher are closed.
         * @param level  Absolute stack index.
         */
        fClose(level) {
            var i = this._openupval.length;
            while (--i >= 0) {
                var uv = this._openupval[i]; //FIXME:var uv:UpVal = this._openupval.elementAt(i) as UpVal;
                if (uv.offset < level) {
                    break;
                }
                uv.close();
            }
            this._openupval.length = i + 1;
            //openupval.setSize(i+1);
            return;
        }
        fFindupval(idx) {
            /*
                * We search from the end of the Vector towards the beginning,
                * looking for an UpVal for the required stack-slot.
                */
            var i = this._openupval.length; //FIXME:.size();
            while (--i >= 0) {
                var uv2 = this._openupval[i]; //FIXME:var uv2:UpVal = this._openupval.elementAt(i) as UpVal;
                if (uv2.offset == idx) {
                    return uv2;
                }
                if (uv2.offset < idx) {
                    break;
                }
            }
            // i points to be position _after_ which we want to insert a new
            // UpVal (it's -1 when we want to insert at the beginning).
            var uv = new UpVal_1.UpVal(idx, this._stack[idx]);
            this._openupval.splice(i + 1, 0, uv); //FIXME:this._openupval.insertElementAt(uv, i+1);
            return uv;
        }
        //////////////////////////////////////////////////////////////////////
        // Debug
        // Methods equivalent to the file ldebug.c.  Prefixed with g.
        /** <var>p1</var> and <var>p2</var> are operands to a numeric opcode.
         * Corrupts <code>NUMOP[0]</code>.
         * There is the possibility of using <var>p1</var> and <var>p2</var> to
         * identify (for example) for local variable being used in the
         * computation (consider the error message for code like <code>local
         * y='a'; return y+1</code> for example).  Currently the debug info is
         * not used, and this opportunity is wasted (it would require changing
         * or overloading gTypeerror).
         */
        gAritherror(p1, p2) {
            if (!Lua.tonumber(p1, Lua.NUMOP)) {
                p2 = p1; // first operand is wrong
            }
            this.gTypeerror(p2, "perform arithmetic on");
        }
        /** <var>p1</var> and <var>p2</var> are absolute stack indexes. */
        gConcaterror(p1, p2) {
            if (this._stack[p1].r instanceof String || typeof (this._stack[p1].r) == 'string') {
                p1 = p2;
            }
            // assert !(p1 instanceof String);
            this.gTypeerror(this._stack[p1], "concatenate");
        }
        gCheckcode(p) {
            // :todo: implement me.
            return true;
        }
        gErrormsg(message) {
            this.pushObject(message);
            if (this._errfunc != null) // is there an error handling function
             {
                if (!Lua.isFunction(this._errfunc)) {
                    this.dThrow(Lua.ERRERR);
                }
                this.insert(this._errfunc, this.getTop()); // push function (under error arg)
                this.vmCall(this._stackSize - 2, 1); // call it
            }
            this.dThrow(Lua.ERRRUN);
            // NOTREACHED
            return 0;
        }
        gOrdererror(p1, p2) {
            var t1 = Lua.typeName(this.___type(p1));
            var t2 = Lua.typeName(this.___type(p2));
            if (t1.charAt(2) == t2.charAt(2)) {
                this.gRunerror("attempt to compare two " + t1 + "values");
            }
            else {
                this.gRunerror("attempt to compare " + t1 + " with " + t2);
            }
            // NOTREACHED
            return false;
        }
        gRunerror(s) {
            this.gErrormsg(s);
        }
        gTypeerror(o, op) {
            var t = Lua.typeName(Lua.____type(o));
            this.gRunerror("attempt to " + op + " a " + t + " value");
        }
        __gTypeerror(p, op) {
            // :todo: PUC-Rio searches the stack to see if the value (which may
            // be a reference to stack cell) is a local variable.
            // For now we cop out and just call gTypeerror(Object, String)
            this.gTypeerror(p.asObject(), op);
        }
        /**
         * @return a string no longer than IDSIZE.
         */
        static oChunkid(source) {
            var len = Lua.IDSIZE;
            if (source.charAt(0) == "=") {
                if (source.length < Lua.IDSIZE + 1) {
                    return source.substring(1);
                }
                else {
                    return source.substring(1, 1 + len);
                }
            }
            // else  "source" or "...source"
            if (source.charAt(0) == "@") {
                source = source.substring(1);
                len -= " '...' ".length;
                var l2 = source.length;
                if (l2 > len) {
                    return "..." + // get last part of file name
                        source.substring(source.length - len, source.length);
                }
                return source;
            }
            // else  [string "string"]
            var l = source.indexOf('\n');
            if (l == -1) {
                l = source.length;
            }
            len -= " [string \"...\"] ".length;
            if (l > len) {
                l = len;
            }
            var buf = new StringBuffer_1.StringBuffer();
            buf.appendString("[string \"");
            buf.appendString(source.substring(0, l));
            if (source.length > l) // must truncate
             {
                buf.appendString("...");
            }
            buf.appendString("\"]");
            return buf.toString();
        }
        /**
         * Equivalent to luaO_fb2int.
         * @see Syntax#oInt2fb
         */
        static oFb2int(x) {
            var e = (x >>> 3) & 31;
            if (e == 0) {
                return x;
            }
            return ((x & 7) + 8) << (e - 1);
        }
        /** Equivalent to luaO_rawequalObj. */
        static oRawequal(a, b) {
            // see also vmEqual
            if (Lua.NIL == a) {
                return Lua.NIL == b;
            }
            // Now a is not null, so a.equals() is a valid call.
            // Numbers (Doubles), Booleans, Strings all get compared by value,
            // as they should; tables, functions, get compared by identity as
            // they should.
            return a === (b);
        }
        /** Equivalent to luaO_str2d. */
        static oStr2d(s, out /*double[] */) {
            // :todo: using try/catch may be too slow.  In which case we'll have
            // to recognise the valid formats first.
            try {
                out[0] = Number(s);
                return true;
            }
            catch (e0_) {
                if (e0_ instanceof NumberFormatException_1.NumberFormatException) {
                    console.log(e0_.stack);
                }
                try {
                    // Attempt hexadecimal conversion.
                    // :todo: using String.trim is not strictly accurate, because it
                    // trims other ASCII control characters as well as whitespace.
                    s = s.replace(/ /g, "").toUpperCase(); //TODO:
                    if (s.substr(0, 2) == "0X") {
                        s = s.substring(2);
                    }
                    else if (s.substr(0, 3) == ("-0X")) {
                        s = "-" + s.substring(3);
                    }
                    else {
                        return false;
                    }
                    out[0] = parseInt(s); // TODO:16进制 16);
                    return true;
                }
                catch (e1_) {
                    if (e1_ instanceof NumberFormatException_1.NumberFormatException) {
                        console.log(e1_.stack);
                        return false;
                    }
                }
            }
            //unreachable
            return false;
        }
        // Hardwired values for speed.
        /** Equivalent of macro GET_OPCODE */
        static OPCODE(instruction) {
            // POS_OP == 0 (shift amount)
            // SIZE_OP == 6 (opcode width)
            return instruction & 0x3f;
        }
        /** Equivalent of macro GET_OPCODE */
        static SET_OPCODE(i, op) {
            // POS_OP == 0 (shift amount)
            // SIZE_OP == 6 (opcode width)
            return (i & ~0x3F) | (op & 0x3F);
        }
        /** Equivalent of macro GETARG_A */
        static ARGA(instruction) {
            // POS_A == POS_OP + SIZE_OP == 6 (shift amount)
            // SIZE_A == 8 (operand width)
            return (instruction >>> 6) & 0xff;
        }
        static SETARG_A(i, u) {
            return (i & ~(0xff << 6)) | ((u & 0xff) << 6);
        }
        /** Equivalent of macro GETARG_B */
        static ARGB(instruction) {
            // POS_B == POS_OP + SIZE_OP + SIZE_A + SIZE_C == 23 (shift amount)
            // SIZE_B == 9 (operand width)
            /* No mask required as field occupies the most significant bits of a
                * 32-bit int. */
            return (instruction >>> 23);
        }
        static SETARG_B(i, b) {
            return (i & ~(0x1ff << 23)) | ((b & 0x1ff) << 23);
        }
        /** Equivalent of macro GETARG_C */
        static ARGC(instruction) {
            // POS_C == POS_OP + SIZE_OP + SIZE_A == 14 (shift amount)
            // SIZE_C == 9 (operand width)
            return (instruction >>> 14) & 0x1ff;
        }
        static SETARG_C(i, c) {
            return (i & ~(0x1ff << 14)) | ((c & 0x1ff) << 14);
        }
        /** Equivalent of macro GETARG_Bx */
        static ARGBx(instruction) {
            // POS_Bx = POS_C == 14
            // SIZE_Bx == SIZE_C + SIZE_B == 18
            /* No mask required as field occupies the most significant bits of a
                * 32 bit int. */
            return (instruction >>> 14);
        }
        static SETARG_Bx(i, bx) {
            return (i & 0x3fff) | (bx << 14);
        }
        /** Equivalent of macro GETARG_sBx */
        static ARGsBx(instruction) {
            // As ARGBx but with (2**17-1) subtracted.
            return (instruction >>> 14) - Lua.MAXARG_sBx;
        }
        static SETARG_sBx(i, bx) {
            return (i & 0x3fff) | ((bx + Lua.MAXARG_sBx) << 14); // CHECK THIS IS RIGHT
        }
        static ISK(field) {
            // The "is constant" bit position depends on the size of the B and C
            // fields (required to be the same width).
            // SIZE_B == 9
            return field >= 0x100;
        }
        /**
        * Near equivalent of macros RKB and RKC.  Note: non-static as it
        * requires stack and base instance members.  Stands for "Register or
        * Konstant" by the way, it gets value from either the register file
        * (stack) or the constant array (k).
        */
        RK(k /*Slot[] */, field) {
            if (Lua.ISK(field)) {
                return k[field & 0xff];
            }
            return this._stack[this._base + field];
        }
        /**
        * Slower version of RK that does not receive the constant array.  Not
        * recommend for routine use, but is used by some error handling code
        * to avoid having a constant array passed around too much.
        */
        __RK(field) {
            var _function = this._stack[this.__ci().func].r;
            var k = _function.proto.constant; //Slot[]
            return this.RK(k, field);
        }
        // CREATE functions are required by FuncState, so default access.
        static CREATE_ABC(o, a, b, c) {
            // POS_OP == 0
            // POS_A == 6
            // POS_B == 23
            // POS_C == 14
            return o | (a << 6) | (b << 23) | (c << 14);
        }
        static CREATE_ABx(o, a, bc) {
            // POS_OP == 0
            // POS_A == 6
            // POS_Bx == POS_C == 14
            return o | (a << 6) | (bc << 14);
        }
        /**
         * Equivalent of luaD_call.
         * @param func  absolute stack index of function to call.
         * @param r     number of required results.
         */
        vmCall(func, r) {
            ++this._nCcalls;
            if (this.vmPrecall(func, r) == Lua.PCRLUA) {
                this.vmExecute(1);
            }
            --this._nCcalls;
        }
        /** Equivalent of luaV_concat. */
        vmConcat(total, last) {
            do {
                var top = this._base + last + 1;
                var n = 2; // number of elements handled in this pass (at least 2)
                if (!this.tostring(top - 2) || !this.tostring(top - 1)) {
                    if (!this.call_binTM(this._stack[top - 2], this._stack[top - 1], this._stack[top - 2], "__concat")) {
                        this.gConcaterror(top - 2, top - 1);
                    }
                }
                else if (this._stack[top - 1].r.length > 0) {
                    var tl = this._stack[top - 1].r.length;
                    for (n = 1; n < total && this.tostring(top - n - 1); ++n) {
                        tl += this._stack[top - n - 1].r.length;
                        if (tl < 0) {
                            this.gRunerror("string length overflow");
                        }
                    }
                    var buffer = new StringBuffer_1.StringBuffer();
                    buffer.init(tl);
                    for (var i = n; i > 0; i--) // concat all strings
                     {
                        buffer.appendString(this._stack[top - i].r);
                    }
                    this._stack[top - n].r = buffer.toString();
                }
                total -= n - 1; // got n strings to create 1 new
                last -= n - 1;
            } while (total > 1); // repeat until only 1 result left
        }
        /**
         * Primitive for testing Lua equality of two values.  Equivalent of
         * PUC-Rio's <code>equalobj</code> macro.
         * In the loosest sense, this is the equivalent of
         * <code>luaV_equalval</code>.
         */
        vmEqual(a, b) {
            // Deal with number case first
            if (Lua.NUMBER == a.r) {
                if (Lua.NUMBER != b.r) {
                    return false;
                }
                return a.d == b.d;
            }
            // Now we're only concerned with the .r field.
            return this.vmEqualRef(a.r, b.r);
        }
        /**
         * Part of {@link #vmEqual}.  Compares the reference part of two
         * Slot instances.  That is, compares two Lua values, as long as
         * neither is a number.
         */
        vmEqualRef(a, b) {
            if (a === (b)) {
                return true;
            }
            //TODO:
            //if (a.getClass != b.getClass())
            if (typeof (a) != typeof (b)) {
                return false;
            }
            // Same class, but different objects.
            if (a instanceof LuaJavaCallback_1.LuaJavaCallback ||
                a instanceof LuaTable_1.LuaTable) {
                // Resort to metamethods.
                var tm = this.get_compTM(this.getMetatable(a), this.getMetatable(b), "__eq");
                if (Lua.NIL == tm) // no TM?
                 {
                    return false;
                }
                var s = new Slot_1.Slot();
                this.__callTMres(s, tm, a, b); // call TM   //TODO:
                return !this.isFalse(s.r);
            }
            return false;
        }
        static getOpcodeName(code) {
            var name = "";
            switch (code) {
                case Lua.OP_MOVE:
                    name = "OP_MOVE";
                    break;
                case Lua.OP_LOADK:
                    name = "OP_LOADK";
                    break;
                case Lua.OP_LOADBOOL:
                    name = "OP_LOADBOOL";
                    break;
                case Lua.OP_LOADNIL:
                    name = "OP_LOADNIL";
                    break;
                case Lua.OP_GETUPVAL:
                    name = "OP_GETUPVAL";
                    break;
                case Lua.OP_GETGLOBAL:
                    name = "OP_GETGLOBAL";
                    break;
                case Lua.OP_GETTABLE:
                    name = "OP_GETTABLE";
                    break;
                case Lua.OP_SETGLOBAL:
                    name = "OP_SETGLOBAL";
                    break;
                case Lua.OP_SETUPVAL:
                    name = "OP_SETUPVAL";
                    break;
                case Lua.OP_SETTABLE:
                    name = "OP_SETTABLE";
                    break;
                case Lua.OP_NEWTABLE:
                    name = "OP_NEWTABLE";
                    break;
                case Lua.OP_SELF:
                    name = "OP_SELF";
                    break;
                case Lua.OP_ADD:
                    name = "OP_ADD";
                    break;
                case Lua.OP_SUB:
                    name = "OP_SUB";
                    break;
                case Lua.OP_MUL:
                    name = "OP_MUL";
                    break;
                case Lua.OP_DIV:
                    name = "OP_DIV";
                    break;
                case Lua.OP_MOD:
                    name = "OP_MOD";
                    break;
                case Lua.OP_POW:
                    name = "OP_POW";
                    break;
                case Lua.OP_UNM:
                    name = "OP_UNM";
                    break;
                case Lua.OP_NOT:
                    name = "OP_NOT";
                    break;
                case Lua.OP_LEN:
                    name = "OP_LEN";
                    break;
                case Lua.OP_CONCAT:
                    name = "OP_CONCAT";
                    break;
                case Lua.OP_JMP:
                    name = "OP_JMP";
                    break;
                case Lua.OP_EQ:
                    name = "OP_EQ";
                    break;
                case Lua.OP_LT:
                    name = "OP_LT";
                    break;
                case Lua.OP_LE:
                    name = "OP_LE";
                    break;
                case Lua.OP_TEST:
                    name = "OP_TEST";
                    break;
                case Lua.OP_TESTSET:
                    name = "OP_TESTSET";
                    break;
                case Lua.OP_CALL:
                    name = "OP_CALL";
                    break;
                case Lua.OP_TAILCALL:
                    name = "OP_TAILCALL";
                    break;
                case Lua.OP_RETURN:
                    name = "OP_RETURN";
                    break;
                case Lua.OP_FORLOOP:
                    name = "OP_FORLOOP";
                    break;
                case Lua.OP_FORPREP:
                    name = "OP_FORPREP";
                    break;
                case Lua.OP_TFORLOOP:
                    name = "OP_TFORLOOP";
                    break;
                case Lua.OP_SETLIST:
                    name = "OP_SETLIST";
                    break;
                case Lua.OP_CLOSE:
                    name = "OP_CLOSE";
                    break;
                case Lua.OP_CLOSURE:
                    name = "OP_CLOSURE";
                    break;
                case Lua.OP_VARARG:
                    name = "OP_VARARG";
                    break;
            }
            return name;
        }
        /** The core VM execution engine. */
        vmExecute(nexeccalls) {
            // This labelled while loop is used to simulate the effect of C's
            // goto.  The end of the while loop is never reached.  The beginning
            // of the while loop is branched to using a "continue reentry;"
            // statement (when a Lua function is called or returns).
            reentry: while (true) {
                // assert stack[ci.function()].r instanceof LuaFunction;
                var _function = this._stack[this.__ci().func].r;
                var proto = _function.proto;
                var code = proto.code; //int[]
                var k = proto.constant; //Slot[] 
                var pc = this._savedpc;
                //20170402:added
                if (Lua.D) {
                    //usage:luac -p -l cf.lua
                    for (var i_test = 0; i_test < code.length; i_test++) {
                        var name1 = Lua.getOpcodeName(Lua.OPCODE(code[i_test]));
                        console.log(">>>OPCODE(code(" + (i_test + 1) + ")) == " + name1);
                    }
                }
                while (true) // main loop of interpreter
                 {
                    // Where the PUC-Rio code used the Protect macro, this has been
                    // replaced with "savedpc = pc" and a "// Protect" comment.
                    // Where the PUC-Rio code used the dojump macro, this has been
                    // replaced with the equivalent increment of the pc and a
                    // "//dojump" comment.
                    var i = code[pc++]; // VM instruction.
                    // :todo: line hook
                    if ((this._hookmask & Lua.MASKCOUNT) != 0 && --this._hookcount == 0) {
                        this.traceexec(pc);
                        if (this.status == Lua.YIELD) // did hook yield?
                         {
                            this._savedpc = pc - 1;
                            return;
                        }
                        // base = this.base
                    }
                    var a = Lua.ARGA(i); // its A field.
                    var rb;
                    var rc;
                    //20170402:added
                    if (Lua.D) {
                        var name2 = Lua.getOpcodeName(Lua.OPCODE(i));
                        console.log(">>>pc == " + pc + ", name == " + name2);
                    }
                    switch (Lua.OPCODE(i)) {
                        case Lua.OP_MOVE:
                            this._stack[this._base + a].r = this._stack[this._base + Lua.ARGB(i)].r;
                            this._stack[this._base + a].d = this._stack[this._base + Lua.ARGB(i)].d;
                            continue;
                        case Lua.OP_LOADK:
                            this._stack[this._base + a].r = k[Lua.ARGBx(i)].r;
                            this._stack[this._base + a].d = k[Lua.ARGBx(i)].d;
                            if (Lua.D) {
                                console.log("OP_LOADK:stack[" + (this._base + a) +
                                    "]=k[" + Lua.ARGBx(i) + "]=" + k[Lua.ARGBx(i)].d);
                            }
                            continue;
                        case Lua.OP_LOADBOOL:
                            this._stack[this._base + a].r = Lua.valueOfBoolean(Lua.ARGB(i) != 0);
                            if (Lua.ARGC(i) != 0) {
                                ++pc;
                            }
                            continue;
                        case Lua.OP_LOADNIL:
                            {
                                var b = this._base + Lua.ARGB(i);
                                do {
                                    this._stack[b--].r = Lua.NIL;
                                } while (b >= this._base + a);
                                continue;
                            }
                        case Lua.OP_GETUPVAL:
                            {
                                var b2 = Lua.ARGB(i);
                                // :todo: optimise path
                                this.setObjectAt(_function.upVal(b2).value, this._base + a);
                                continue;
                            }
                        case Lua.OP_GETGLOBAL:
                            rb = k[Lua.ARGBx(i)];
                            // assert rb instance of String;
                            this._savedpc = pc; // Protect
                            this.vmGettable(_function.env, rb, this._stack[this._base + a]);
                            continue;
                        case Lua.OP_GETTABLE:
                            {
                                this._savedpc = pc; // Protect
                                var h = this._stack[this._base + Lua.ARGB(i)].asObject();
                                if (Lua.D) {
                                    console.log("OP_GETTABLE index = " + (this._base + Lua.ARGB(i)) +
                                        ", size = " + this._stack.length +
                                        ", h = " + h);
                                }
                                this.vmGettable(h, this.RK(k, Lua.ARGC(i)), this._stack[this._base + a]);
                                continue;
                            }
                        case Lua.OP_SETUPVAL:
                            {
                                var uv = _function.upVal(Lua.ARGB(i));
                                uv.value = this.objectAt(this._base + a);
                                continue;
                            }
                        case Lua.OP_SETGLOBAL:
                            this._savedpc = pc; // Protect
                            // :todo: consider inlining objectAt
                            this.vmSettable(_function.env, k[Lua.ARGBx(i)], this.objectAt(this._base + a));
                            continue;
                        case Lua.OP_SETTABLE:
                            {
                                this._savedpc = pc; // Protect
                                var t = this._stack[this._base + a].asObject();
                                this.vmSettable(t, this.RK(k, Lua.ARGB(i)), this.RK(k, Lua.ARGC(i)).asObject());
                                continue;
                            }
                        case Lua.OP_NEWTABLE:
                            {
                                var b3 = Lua.ARGB(i);
                                var c = Lua.ARGC(i);
                                this._stack[this._base + a].r = new LuaTable_1.LuaTable();
                                this._stack[this._base + a].r.init(Lua.oFb2int(b3), Lua.oFb2int(c));
                                continue;
                            }
                        case Lua.OP_SELF:
                            {
                                var b4 = Lua.ARGB(i);
                                rb = this._stack[this._base + b4];
                                this._stack[this._base + a + 1].r = rb.r;
                                this._stack[this._base + a + 1].d = rb.d;
                                this._savedpc = pc; // Protect
                                this.vmGettable(rb.asObject(), this.RK(k, Lua.ARGC(i)), this._stack[this._base + a]);
                                continue;
                            }
                        case Lua.OP_ADD:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            if (rb.r == Lua.NUMBER && rc.r == Lua.NUMBER) {
                                var sum = rb.d + rc.d;
                                this._stack[this._base + a].d = sum;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (Lua.toNumberPair(rb, rc, Lua.NUMOP)) {
                                var sum2 = Lua.NUMOP[0] + Lua.NUMOP[1];
                                this._stack[this._base + a].d = sum2;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (!this.call_binTM(rb, rc, this._stack[this._base + a], "__add")) {
                                this.gAritherror(rb, rc);
                            }
                            continue;
                        case Lua.OP_SUB:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            if (rb.r == Lua.NUMBER && rc.r == Lua.NUMBER) {
                                var difference = rb.d - rc.d;
                                this._stack[this._base + a].d = difference;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (Lua.toNumberPair(rb, rc, Lua.NUMOP)) {
                                var difference2 = Lua.NUMOP[0] - Lua.NUMOP[1];
                                this._stack[this._base + a].d = difference2;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (!this.call_binTM(rb, rc, this._stack[this._base + a], "__sub")) {
                                this.gAritherror(rb, rc);
                            }
                            continue;
                        case Lua.OP_MUL:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            if (rb.r == Lua.NUMBER && rc.r == Lua.NUMBER) {
                                var product = rb.d * rc.d;
                                this._stack[this._base + a].d = product;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (Lua.toNumberPair(rb, rc, Lua.NUMOP)) {
                                var product2 = Lua.NUMOP[0] * Lua.NUMOP[1];
                                this._stack[this._base + a].d = product2;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (!this.call_binTM(rb, rc, this._stack[this._base + a], "__mul")) {
                                this.gAritherror(rb, rc);
                            }
                            continue;
                        case Lua.OP_DIV:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            if (rb.r == Lua.NUMBER && rc.r == Lua.NUMBER) {
                                var quotient = rb.d / rc.d;
                                this._stack[this._base + a].d = quotient;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (Lua.toNumberPair(rb, rc, Lua.NUMOP)) {
                                var quotient2 = Lua.NUMOP[0] / Lua.NUMOP[1];
                                this._stack[this._base + a].d = quotient2;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (!this.call_binTM(rb, rc, this._stack[this._base + a], "__div")) {
                                this.gAritherror(rb, rc);
                            }
                            continue;
                        case Lua.OP_MOD:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            if (rb.r == Lua.NUMBER && rc.r == Lua.NUMBER) {
                                var modulus = Lua.__modulus(rb.d, rc.d);
                                this._stack[this._base + a].d = modulus;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (Lua.toNumberPair(rb, rc, Lua.NUMOP)) {
                                var modulus2 = Lua.__modulus(Lua.NUMOP[0], Lua.NUMOP[1]);
                                this._stack[this._base + a].d = modulus2;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (!this.call_binTM(rb, rc, this._stack[this._base + a], "__mod")) {
                                this.gAritherror(rb, rc);
                            }
                            continue;
                        case Lua.OP_POW:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            if (rb.r == Lua.NUMBER && rc.r == Lua.NUMBER) {
                                var result = Lua.iNumpow(rb.d, rc.d);
                                this._stack[this._base + a].d = result;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (Lua.toNumberPair(rb, rc, Lua.NUMOP)) {
                                var result2 = Lua.iNumpow(Lua.NUMOP[0], Lua.NUMOP[1]);
                                this._stack[this._base + a].d = result2;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (!this.call_binTM(rb, rc, this._stack[this._base + a], "__pow")) {
                                this.gAritherror(rb, rc);
                            }
                            continue;
                        case Lua.OP_UNM:
                            rb = this._stack[this._base + Lua.ARGB(i)];
                            if (rb.r == Lua.NUMBER) {
                                this._stack[this._base + a].d = -rb.d;
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (Lua.tonumber(rb, Lua.NUMOP)) {
                                this._stack[this._base + a].d = -Lua.NUMOP[0];
                                this._stack[this._base + a].r = Lua.NUMBER;
                            }
                            else if (!this.call_binTM(rb, rb, this._stack[this._base + a], "__unm")) {
                                this.gAritherror(rb, rb);
                            }
                            continue;
                        case Lua.OP_NOT:
                            {
                                // All numbers are treated as true, so no need to examine
                                // the .d field.
                                var ra = this._stack[this._base + Lua.ARGB(i)].r;
                                this._stack[this._base + a].r = Lua.valueOfBoolean(this.isFalse(ra));
                                continue;
                            }
                        case Lua.OP_LEN:
                            rb = this._stack[this._base + Lua.ARGB(i)];
                            if (rb.r instanceof LuaTable_1.LuaTable) {
                                var t2 = rb.r;
                                this._stack[this._base + a].d = t2.getn();
                                this._stack[this._base + a].r = Lua.NUMBER;
                                continue;
                            }
                            else if (rb.r instanceof String || typeof (rb.r) == 'string') {
                                var s = rb.r;
                                this._stack[this._base + a].d = s.length;
                                this._stack[this._base + a].r = Lua.NUMBER;
                                continue;
                            }
                            this._savedpc = pc; // Protect
                            if (!this.call_binTM(rb, rb, this._stack[this._base + a], "__len")) {
                                this.gTypeerror(rb, "get length of");
                            }
                            continue;
                        case Lua.OP_CONCAT:
                            {
                                var b_CONCAT = Lua.ARGB(i);
                                var c_CONCAT = Lua.ARGC(i);
                                this._savedpc = pc; // Protect
                                // :todo: The compiler assumes that all
                                // stack locations _above_ b end up with junk in them.  In
                                // which case we can improve the speed of vmConcat (by not
                                // converting each stack slot, but simply using
                                // StringBuffer.append on whatever is there).
                                this.vmConcat(c_CONCAT - b_CONCAT + 1, c_CONCAT);
                                this._stack[this._base + a].r = this._stack[this._base + b_CONCAT].r;
                                this._stack[this._base + a].d = this._stack[this._base + b_CONCAT].d;
                                continue;
                            }
                        case Lua.OP_JMP:
                            // dojump
                            pc += Lua.ARGsBx(i);
                            continue;
                        case Lua.OP_EQ:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            if (this.vmEqual(rb, rc) == (a != 0)) {
                                // dojump
                                pc += Lua.ARGsBx(code[pc]);
                            }
                            ++pc;
                            continue;
                        case Lua.OP_LT:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            this._savedpc = pc; // Protect
                            if (this.vmLessthan(rb, rc) == (a != 0)) {
                                // dojump
                                pc += Lua.ARGsBx(code[pc]);
                            }
                            ++pc;
                            continue;
                        case Lua.OP_LE:
                            rb = this.RK(k, Lua.ARGB(i));
                            rc = this.RK(k, Lua.ARGC(i));
                            this._savedpc = pc; // Protect
                            if (this.vmLessequal(rb, rc) == (a != 0)) {
                                // dojump
                                pc += Lua.ARGsBx(code[pc]);
                            }
                            ++pc;
                            continue;
                        case Lua.OP_TEST:
                            if (this.isFalse(this._stack[this._base + a].r) != (Lua.ARGC(i) != 0)) {
                                // dojump
                                pc += Lua.ARGsBx(code[pc]);
                            }
                            ++pc;
                            continue;
                        case Lua.OP_TESTSET:
                            rb = this._stack[this._base + Lua.ARGB(i)];
                            if (this.isFalse(rb.r) != (Lua.ARGC(i) != 0)) {
                                this._stack[this._base + a].r = rb.r;
                                this._stack[this._base + a].d = rb.d;
                                // dojump
                                pc += Lua.ARGsBx(code[pc]);
                            }
                            ++pc;
                            continue;
                        case Lua.OP_CALL:
                            {
                                var b_CALL = Lua.ARGB(i);
                                var nresults = Lua.ARGC(i) - 1;
                                if (b_CALL != 0) //FIXME:bug: b->b_CALL
                                 {
                                    this.stacksetsize(this._base + a + b_CALL);
                                }
                                this._savedpc = pc;
                                switch (this.vmPrecall(this._base + a, nresults)) {
                                    case Lua.PCRLUA:
                                        nexeccalls++;
                                        continue reentry;
                                    case Lua.PCRJ:
                                        // Was Java function called by precall, adjust result
                                        if (nresults >= 0) {
                                            this.stacksetsize(this.__ci().top);
                                        }
                                        continue;
                                    default:
                                        return; // yield
                                }
                            }
                        case Lua.OP_TAILCALL:
                            {
                                var b_TAILCALL = Lua.ARGB(i);
                                if (b_TAILCALL != 0) {
                                    this.stacksetsize(this._base + a + b_TAILCALL);
                                }
                                this._savedpc = pc;
                                // assert ARGC(i) - 1 == MULTRET
                                switch (this.vmPrecall(this._base + a, Lua.MULTRET)) {
                                    case Lua.PCRLUA:
                                        {
                                            // tail call: put new frame in place of previous one.
                                            var ci = this._civ.elementAt(this._civ.size - 2);
                                            var func = ci.func;
                                            var fci = this.__ci(); // Fresh CallInfo
                                            var pfunc = fci.func;
                                            this.fClose(ci.base);
                                            this._base = func + (fci.base - pfunc);
                                            var aux; // loop index is used after loop ends
                                            for (aux = 0; pfunc + aux < this._stackSize; ++aux) {
                                                // move frame down
                                                this._stack[func + aux].r = this._stack[pfunc + aux].r;
                                                this._stack[func + aux].d = this._stack[pfunc + aux].d;
                                            }
                                            this.stacksetsize(func + aux); // correct top
                                            // assert stackSize == base + ((LuaFunction)stack[func]).proto().maxstacksize();
                                            ci.tailcall(this._base, this._stackSize);
                                            this.dec_ci(); // remove new frame.
                                            continue reentry;
                                        }
                                    case Lua.PCRJ: // It was a Java function
                                        {
                                            continue;
                                        }
                                    default:
                                        {
                                            return; // yield
                                        }
                                }
                            }
                        case Lua.OP_RETURN:
                            {
                                this.fClose(this._base);
                                var b_RETURN = Lua.ARGB(i);
                                if (b_RETURN != 0) {
                                    var top = a + b_RETURN - 1;
                                    this.stacksetsize(this._base + top);
                                }
                                this._savedpc = pc;
                                // 'adjust' replaces aliased 'b' in PUC-Rio code.
                                var adjust = this.vmPoscall(this._base + a);
                                if (--nexeccalls == 0) {
                                    return;
                                }
                                if (adjust) {
                                    this.stacksetsize(this.__ci().top);
                                }
                                continue reentry;
                            }
                        case Lua.OP_FORLOOP:
                            {
                                var step = this._stack[this._base + a + 2].d;
                                var idx = this._stack[this._base + a].d + step;
                                var limit = this._stack[this._base + a + 1].d;
                                if ((0 < step && idx <= limit) ||
                                    (step <= 0 && limit <= idx)) {
                                    // dojump
                                    pc += Lua.ARGsBx(i);
                                    this._stack[this._base + a].d = idx; // internal index
                                    this._stack[this._base + a].r = Lua.NUMBER;
                                    this._stack[this._base + a + 3].d = idx; // external index
                                    this._stack[this._base + a + 3].r = Lua.NUMBER;
                                }
                                continue;
                            }
                        case Lua.OP_FORPREP:
                            {
                                var init = this._base + a;
                                var plimit = this._base + a + 1;
                                var pstep = this._base + a + 2;
                                this._savedpc = pc; // next steps may throw errors
                                if (!this.tonumber(init)) {
                                    this.gRunerror("'for' initial value must be a number");
                                }
                                else if (!this.tonumber(plimit)) {
                                    this.gRunerror("'for' limit must be a number");
                                }
                                else if (!this.tonumber(pstep)) {
                                    this.gRunerror("'for' step must be a number");
                                }
                                var step_FORPREP = this._stack[pstep].d;
                                var idx_FORPREP = this._stack[init].d - step_FORPREP;
                                this._stack[init].d = idx_FORPREP;
                                this._stack[init].r = Lua.NUMBER;
                                // dojump
                                pc += Lua.ARGsBx(i);
                                continue;
                            }
                        case Lua.OP_TFORLOOP:
                            {
                                var cb = this._base + a + 3; // call base
                                this._stack[cb + 2].r = this._stack[this._base + a + 2].r;
                                this._stack[cb + 2].d = this._stack[this._base + a + 2].d;
                                this._stack[cb + 1].r = this._stack[this._base + a + 1].r;
                                this._stack[cb + 1].d = this._stack[this._base + a + 1].d;
                                this._stack[cb].r = this._stack[this._base + a].r;
                                this._stack[cb].d = this._stack[this._base + a].d;
                                this.stacksetsize(cb + 3);
                                this._savedpc = pc; // Protect
                                this.vmCall(cb, Lua.ARGC(i));
                                this.stacksetsize(this.__ci().top);
                                if (Lua.NIL != this._stack[cb].r) // continue loop
                                 {
                                    this._stack[cb - 1].r = this._stack[cb].r;
                                    this._stack[cb - 1].d = this._stack[cb].d;
                                    // dojump
                                    pc += Lua.ARGsBx(code[pc]);
                                }
                                ++pc;
                                continue;
                            }
                        case Lua.OP_SETLIST:
                            {
                                var n = Lua.ARGB(i);
                                var c_SETLIST = Lua.ARGC(i);
                                var setstack = false;
                                if (0 == n) {
                                    n = (this._stackSize - (this._base + a)) - 1;
                                    setstack = true;
                                }
                                if (0 == c_SETLIST) {
                                    c_SETLIST = code[pc++];
                                }
                                var t3 = this._stack[this._base + a].r;
                                var last = ((c_SETLIST - 1) * Lua.LFIELDS_PER_FLUSH) + n;
                                // :todo: consider expanding space in table
                                for (; n > 0; n--) {
                                    var val = this.objectAt(this._base + a + n);
                                    t3.putnum(last--, val);
                                }
                                if (setstack) {
                                    this.stacksetsize(this.__ci().top);
                                }
                                continue;
                            }
                        case Lua.OP_CLOSE:
                            this.fClose(this._base + a);
                            continue;
                        case Lua.OP_CLOSURE:
                            {
                                var p = _function.proto.proto[Lua.ARGBx(i)];
                                var nup = p.nups;
                                var up = new Array(nup); //UpVal[] 
                                for (var j = 0; j < nup; j++, pc++) {
                                    var _in = code[pc];
                                    if (Lua.OPCODE(_in) == Lua.OP_GETUPVAL) {
                                        up[j] = _function.upVal(Lua.ARGB(_in));
                                    }
                                    else {
                                        // assert OPCODE(in) == OP_MOVE;
                                        up[j] = this.fFindupval(this._base + Lua.ARGB(_in));
                                    }
                                }
                                var nf = new LuaFunction_1.LuaFunction(p, up, _function.env);
                                //up = null;
                                this._stack[this._base + a].r = nf;
                                continue;
                            }
                        case Lua.OP_VARARG:
                            {
                                var b_VARARG = Lua.ARGB(i) - 1;
                                var n_VARARG = (this._base - this.__ci().func) -
                                    _function.proto.numparams - 1;
                                if (b_VARARG == Lua.MULTRET) {
                                    // :todo: Protect
                                    // :todo: check stack
                                    b_VARARG = n_VARARG;
                                    this.stacksetsize(this._base + a + n_VARARG);
                                }
                                for (var j_VARARG = 0; j_VARARG < b_VARARG; ++j_VARARG) {
                                    if (j_VARARG < n_VARARG) {
                                        var src = this._stack[this._base - n_VARARG + j_VARARG];
                                        this._stack[this._base + a + j_VARARG].r = src.r;
                                        this._stack[this._base + a + j_VARARG].d = src.d;
                                    }
                                    else {
                                        this._stack[this._base + a + j_VARARG].r = Lua.NIL;
                                    }
                                }
                                continue;
                            }
                    } /* switch */
                } /* while */
            } /* reentry: while */
        }
        static iNumpow(a, b) {
            // :todo: this needs proper checking for boundary cases
            // EG, is currently wrong for (-0)^2.
            var invert = b < 0.0;
            if (invert)
                b = -b;
            if (a == 0.0)
                return invert ? NaN : a;
            var result = 1.0;
            var ipow = b;
            b -= ipow;
            var t = a;
            while (ipow > 0) {
                if ((ipow & 1) != 0)
                    result *= t;
                ipow >>= 1;
                t = t * t;
            }
            if (b != 0.0) // integer only case, save doing unnecessary work
             {
                if (a < 0.0) // doesn't work if a negative (complex result!)
                    return NaN;
                t = Math.sqrt(a);
                var half = 0.5;
                while (b > 0.0) {
                    if (b >= half) {
                        result = result * t;
                        b -= half;
                    }
                    b = b + b;
                    t = Math.sqrt(t);
                    if (t == 1.0)
                        break;
                }
            }
            return invert ? 1.0 / result : result;
        }
        /** Equivalent of luaV_gettable. */
        vmGettable(t, key, val) {
            var tm;
            for (var loop = 0; loop < Lua.MAXTAGLOOP; ++loop) {
                if (t instanceof LuaTable_1.LuaTable) // 't' is a table?
                 {
                    var h = t;
                    h.__getlua(key, Lua.SPARE_SLOT);
                    if (Lua.SPARE_SLOT.r != Lua.NIL) {
                        val.r = Lua.SPARE_SLOT.r;
                        val.d = Lua.SPARE_SLOT.d;
                        return;
                    }
                    tm = this.tagmethod(h, "__index");
                    if (tm == Lua.NIL) {
                        val.r = Lua.NIL;
                        return;
                    }
                    // else will try the tag method
                }
                else {
                    tm = this.tagmethod(t, "__index");
                    if (tm == Lua.NIL)
                        this.gTypeerror(t, "index");
                }
                if (Lua.isFunction(tm)) {
                    Lua.SPARE_SLOT.setObject(t);
                    this.callTMres(val, tm, Lua.SPARE_SLOT, key);
                    return;
                }
                t = tm; // else repeat with 'tm'
            }
            this.gRunerror("loop in gettable");
        }
        /** Equivalent of luaV_lessthan. */
        vmLessthan(l, r) {
            //TODO:
            //if (l.r.getClass() != r.r.getClass())
            if (typeof (l.r) != typeof (r.r)) {
                this.gOrdererror(l, r);
            }
            else if (l.r == Lua.NUMBER) {
                return l.d < r.d;
            }
            else if (l.r instanceof String || (typeof (l.r) == 'string')) {
                // :todo: PUC-Rio use strcoll, maybe we should use something
                // equivalent.
                return l.r < r.r; //TODO:compareTo
            }
            var res = this.call_orderTM(l, r, "__lt");
            if (res >= 0) {
                return res != 0;
            }
            return this.gOrdererror(l, r);
        }
        /** Equivalent of luaV_lessequal. */
        vmLessequal(l, r) {
            //TODO:
            //if (l.r.getClass() != r.r.getClass())
            if (typeof (l.r) != typeof (r.r)) {
                this.gOrdererror(l, r);
            }
            else if (l.r == Lua.NUMBER) {
                return l.d <= r.d;
            }
            else if (l.r instanceof String || typeof (l.r) == 'string') {
                return l.r <= r.r; //TODO: CompareTo
            }
            var res = this.call_orderTM(l, r, "__le"); // first try 'le'
            if (res >= 0) {
                return res != 0;
            }
            res = this.call_orderTM(r, l, "__lt"); // else try 'lt'
            if (res >= 0) {
                return res == 0;
            }
            return this.gOrdererror(l, r);
        }
        /**
         * Equivalent of luaD_poscall.
         * @param firstResult  stack index (absolute) of the first result
         */
        vmPoscall(firstResult) {
            // :todo: call hook
            var lci; // local copy, for faster access
            lci = this.dec_ci();
            // Now (as a result of the dec_ci call), lci is the CallInfo record
            // for the current function (the function executing an OP_RETURN
            // instruction), and this.ci is the CallInfo record for the function
            // we are returning to.
            var res = lci.res();
            var wanted = lci.nresults; // Caution: wanted could be == MULTRET
            var cci = this.__ci(); // Continuation CallInfo
            this._base = cci.base;
            this._savedpc = cci.savedpc;
            // Move results (and pad with nils to required number if necessary)
            var i = wanted;
            var top = this._stackSize;
            // The movement is always downwards, so copying from the top-most
            // result first is always correct.
            while (i != 0 && firstResult < top) {
                this._stack[res].r = this._stack[firstResult].r;
                this._stack[res].d = this._stack[firstResult].d;
                ++res;
                ++firstResult;
                i--;
            }
            if (i > 0) {
                this.stacksetsize(res + i);
            }
            // :todo: consider using two stacksetsize calls to nil out
            // remaining required results.
            while (i-- > 0) {
                this._stack[res++].r = Lua.NIL;
            }
            this.stacksetsize(res);
            return wanted != Lua.MULTRET;
        }
        /**
        * Equivalent of LuaD_precall.  This method expects that the arguments
        * to the function are placed above the function on the stack.
        * @param func  absolute stack index of the function to call.
        * @param r     number of results expected.
        */
        vmPrecall(func, r) {
            var faso; // Function AS Object
            faso = this._stack[func].r;
            if (!Lua.isFunction(faso)) {
                faso = this.tryfuncTM(func);
            }
            this.__ci().savedpc = this._savedpc;
            if (faso instanceof LuaFunction_1.LuaFunction) {
                var f = faso;
                var p = f.proto;
                // :todo: ensure enough stack
                if (!p.isVararg) {
                    this._base = func + 1;
                    if (this._stackSize > this._base + p.numparams) {
                        // trim stack to the argument list
                        this.stacksetsize(this._base + p.numparams);
                    }
                }
                else {
                    var nargs = (this._stackSize - func) - 1;
                    this._base = this.adjust_varargs(p, nargs);
                }
                var top = this._base + p.maxstacksize;
                this.inc_ci(func, this._base, top, r);
                this._savedpc = 0;
                // expand stack to the function's max stack size.
                this.stacksetsize(top);
                // :todo: implement call hook.
                return Lua.PCRLUA;
            }
            else if (faso instanceof LuaJavaCallback_1.LuaJavaCallback) {
                var fj = faso;
                // :todo: checkstack (not sure it's necessary)
                this._base = func + 1;
                this.inc_ci(func, this._base, this._stackSize + Lua.MINSTACK, r);
                // :todo: call hook
                var n = 99;
                try {
                    n = fj.luaFunction(this);
                }
                catch (e1) {
                    if (e1 instanceof LuaError_1.LuaError) {
                        console.log(e1.stack);
                        throw e1;
                    }
                    else if (e1 instanceof RuntimeException_1.RuntimeException) {
                        console.log(e1.stack);
                        this.yield(0);
                        throw e1;
                    }
                }
                if (n < 0) // yielding?
                 {
                    return Lua.PCRYIELD;
                }
                else {
                    this.vmPoscall(this._stackSize - n);
                    return Lua.PCRJ;
                }
            }
            throw new IllegalArgumentException_1.IllegalArgumentException();
        }
        /** Equivalent of luaV_settable. */
        vmSettable(t, key, val) {
            for (var loop = 0; loop < Lua.MAXTAGLOOP; ++loop) {
                var tm;
                if (t instanceof LuaTable_1.LuaTable) // 't' is a table
                 {
                    var h = t;
                    h.__getlua(key, Lua.SPARE_SLOT);
                    if (Lua.SPARE_SLOT.r != Lua.NIL) // result is not nil?
                     {
                        h.putluaSlot(this, key, val);
                        return;
                    }
                    tm = this.tagmethod(h, "__newindex");
                    if (tm == Lua.NIL) // or no TM?
                     {
                        h.putluaSlot(this, key, val);
                        return;
                    }
                    // else will try the tag method
                }
                else {
                    tm = this.tagmethod(t, "__newindex");
                    if (tm == Lua.NIL)
                        this.gTypeerror(t, "index");
                }
                if (Lua.isFunction(tm)) {
                    this.callTM(tm, t, key, val);
                    return;
                }
                t = tm; // else repeat with 'tm'
            }
            this.gRunerror("loop in settable");
        }
        static vmTostring(o) {
            if (o instanceof String || typeof (o) == 'string') {
                return o;
            }
            if (!(o instanceof Number) || typeof (o) == 'number') {
                return null;
            }
            // Convert number to string.  PUC-Rio abstracts this operation into
            // a macro, lua_number2str.  The macro is only invoked from their
            // equivalent of this code.
            // Formerly this code used Double.toString (and remove any trailing
            // ".0") but this does not give an accurate emulation of the PUC-Rio
            // behaviour which Intuwave require.  So now we use "%.14g" like
            // PUC-Rio.
            // :todo: consider optimisation of making FormatItem an immutable
            // class and keeping a static reference to the required instance
            // (which never changes).  A possible half-way house would be to
            // create a copied instance from an already create prototype
            // instance which would be faster than parsing the format string
            // each time.
            var f = new FormatItem_1.FormatItem(null, Lua.NUMBER_FMT);
            var b = new StringBuffer_1.StringBuffer();
            var d = o;
            f.formatFloat(b, d);
            return b.toString();
        }
        /** Equivalent of adjust_varargs in "ldo.c". */
        adjust_varargs(p, actual) {
            var nfixargs = p.numparams;
            for (; actual < nfixargs; ++actual) {
                this.stackAdd(Lua.NIL);
            }
            // PUC-Rio's LUA_COMPAT_VARARG is not supported here.
            // Move fixed parameters to final position
            var fixed = this._stackSize - actual; // first fixed argument
            var newbase = this._stackSize; // final position of first argument
            for (var i = 0; i < nfixargs; ++i) {
                // :todo: arraycopy?
                this.pushSlot(this._stack[fixed + i]);
                this._stack[fixed + i].r = Lua.NIL;
            }
            return newbase;
        }
        /**
         * Does not modify contents of p1 or p2.  Modifies contents of res.
         * @param p1  left hand operand.
         * @param p2  right hand operand.
         * @param res absolute stack index of result.
         * @return false if no tagmethod, true otherwise
         */
        call_binTM(p1, p2, res, event) {
            var tm = this.tagmethod(p1.asObject(), event); // try first operand
            if (Lua.isNil(tm)) {
                tm = this.tagmethod(p2.asObject(), event); // try second operand
            }
            if (!Lua.isFunction(tm)) {
                return false;
            }
            this.callTMres(res, tm, p1, p2);
            return true;
        }
        /**
        * @return -1 if no tagmethod, 0 false, 1 true
        */
        call_orderTM(p1, p2, event) {
            var tm1 = this.tagmethod(p1.asObject(), event);
            if (tm1 == Lua.NIL) // not metamethod
             {
                return -1;
            }
            var tm2 = this.tagmethod(p2.asObject(), event);
            if (!Lua.oRawequal(tm1, tm2)) // different metamethods?
             {
                return -1;
            }
            var s = new Slot_1.Slot();
            this.callTMres(s, tm1, p1, p2);
            return this.isFalse(s.r) ? 0 : 1;
        }
        callTM(f, p1, p2, p3) {
            this.pushObject(f);
            this.pushObject(p1);
            this.pushSlot(p2);
            this.pushObject(p3);
            this.vmCall(this._stackSize - 4, 0);
        }
        callTMres(res, f, p1, p2) {
            this.pushObject(f);
            this.pushSlot(p1);
            this.pushSlot(p2);
            this.vmCall(this._stackSize - 3, 1);
            res.r = this._stack[this._stackSize - 1].r;
            res.d = this._stack[this._stackSize - 1].d;
            this.pop(1);
        }
        /**
         * Overloaded version of callTMres used by {@link #vmEqualRef}.
         * Textuall identical, but a different (overloaded) push method is
         * invoked.
         */
        __callTMres(res, f, p1, p2) {
            this.pushObject(f);
            this.pushObject(p1);
            this.pushObject(p2);
            this.vmCall(this._stackSize - 3, 1);
            res.r = this._stack[this._stackSize - 1].r;
            res.d = this._stack[this._stackSize - 1].d;
            this.pop(1);
        }
        get_compTM(mt1, mt2, event) {
            if (mt1 == null) {
                return Lua.NIL;
            }
            var tm1 = mt1.getlua(event);
            if (Lua.isNil(tm1)) {
                return Lua.NIL; // no metamethod
            }
            if (mt1 == mt2) {
                return tm1; // same metatables => same metamethods
            }
            if (mt2 == null) {
                return Lua.NIL;
            }
            var tm2 = mt2.getlua(event);
            if (Lua.isNil(tm2)) {
                return Lua.NIL; // no metamethod
            }
            if (Lua.oRawequal(tm1, tm2)) // same metamethods?
             {
                return tm1;
            }
            return Lua.NIL;
        }
        /**
        * Gets tagmethod for object.
        * @return method or nil.
        */
        tagmethod(o, event) {
            return this.getMetafield(o, event);
        }
        /** @deprecated DO NOT CALL */
        __tagmethod(o, event) {
            throw new IllegalArgumentException_1.IllegalArgumentException("tagmethod called");
        }
        /**
        * Computes the result of Lua's modules operator (%).  Note that this
        * modulus operator does not match Java's %.
        */
        static __modulus(x, y) {
            return x - Math.floor(x / y) * y;
        }
        /**
        * Changes the stack size, padding with NIL where necessary, and
        * allocate a new stack array if necessary.
        */
        stacksetsize(n) {
            if (n == 3) {
                if (Lua.D) {
                    console.log("stacksetsize:" + n);
                }
            }
            //20170402:added
            if (n == 7) {
                if (Lua.D) {
                    console.log(">>>stacksetsize:" + n);
                }
            }
            // It is absolutely critical that when the stack changes sizes those
            // elements that are common to both old and new stack are unchanged.
            // First implementation of this simply ensures that the stack array
            // has at least the required size number of elements.
            // :todo: consider policies where the stack may also shrink.
            var old = this._stackSize;
            if (n > this._stack.length) {
                //以2倍速度增加堆栈的深度
                var newLength = Math.max(n, 2 * this._stack.length);
                var newStack = new Array(newLength); //Slot[] 
                // Currently the stack only ever grows, so the number of items to
                // copy is the length of the old stack.
                var toCopy = this._stack.length;
                SystemUtil_1.SystemUtil.arraycopy(this._stack, 0, newStack, 0, toCopy);
                //trace(newStack[0]);
                this._stack = newStack;
            }
            this._stackSize = n;
            // Nilling out.  The VM requires that fresh stack slots allocated
            // for a new function activation are initialised to nil (which is
            // Lua.NIL, which is not Java null).
            // There are basically two approaches: nil out when the stack grows,
            // or nil out when it shrinks.  Nilling out when the stack grows is
            // slightly simpler, but nilling out when the stack shrinks means
            // that semantic garbage is not retained by the GC.
            // We nil out slots when the stack shrinks, but we also need to make
            // sure they are nil initially.
            // In order to avoid nilling the entire array when we allocate one
            // we maintain a stackhighwater which is 1 more than that largest
            // stack slot that has been nilled.  We use this to nil out stacks
            // slow when we grow.
            if (n <= old) {
                // when shrinking
                for (var i = n; i < old; ++i) {
                    this._stack[i].r = Lua.NIL;
                }
            }
            if (n > this._stackhighwater) {
                // when growing above stackhighwater for the first time
                for (i = this._stackhighwater; i < n; ++i) {
                    this._stack[i] = new Slot_1.Slot();
                    this._stack[i].r = Lua.NIL;
                }
                this._stackhighwater = n;
            }
        }
        /**
         * Pushes a Lua value onto the stack.
         * 压入一个Lua值进堆栈
         */
        stackAdd(o) {
            var i = this._stackSize;
            this.stacksetsize(i + 1);
            this._stack[i].setObject(o);
        }
        /**
         * Copies a slot into a new space in the stack.
         */
        pushSlot(p) {
            var i = this._stackSize;
            this.stacksetsize(i + 1);
            this._stack[i].r = p.r;
            this._stack[i].d = p.d;
        }
        stackInsertAt(o, i) {
            var n = this._stackSize - i;
            this.stacksetsize(this._stackSize + 1);
            // Copy each slot N into its neighbour N+1.  Loop proceeds from high
            // index slots to lower index slots.
            // A loop from n to 1 copies n slots.
            for (var j = n; j >= 1; --j) {
                this._stack[i + j].r = this._stack[i + j - 1].r;
                this._stack[i + j].d = this._stack[i + j - 1].d;
            }
            this._stack[i].setObject(o);
        }
        /**
        * Equivalent of macro in ldebug.h.
        */
        resethookcount() {
            this._hookcount = this._basehookcount;
        }
        /**
         * Equivalent of traceexec in lvm.c.
         */
        traceexec(pc) {
            var mask = this._hookmask;
            var oldpc = this._savedpc;
            this._savedpc = pc;
            if (mask > Lua.MASKLINE) // instruction-hook set?
             {
                if (this._hookcount == 0) {
                    this.resethookcount();
                    this.dCallhook(Lua.HOOKCOUNT, -1);
                }
            }
            // :todo: line hook.
        }
        /**
        * Convert to number.  Returns true if the argument <var>o</var> was
        * converted to a number.  Converted number is placed in <var>out[0]</var>.
        * Returns
        * false if the argument <var>o</var> could not be converted to a number.
        * Overloaded.
        */
        static tonumber(o, out /*double[] */) {
            if (o.r == Lua.NUMBER) {
                out[0] = o.d;
                return true;
            }
            if (!(o.r instanceof String || typeof (o.r) == 'string')) {
                return false;
            }
            if (Lua.oStr2d(o.r, out)) {
                return true;
            }
            return false;
        }
        /**
         * Converts a stack slot to number.  Returns true if the element at
         * the specified stack slot was converted to a number.  False
         * otherwise.  Note that this actually modifies the element stored at
         * <var>idx</var> in the stack (in faithful emulation of the PUC-Rio
         * code).  Corrupts <code>NUMOP[0]</code>.  Overloaded.
         * @param idx  absolute stack slot.
         */
        tonumber(idx) {
            if (Lua.tonumber(this._stack[idx], Lua.NUMOP)) {
                this._stack[idx].d = Lua.NUMOP[0];
                this._stack[idx].r = Lua.NUMBER;
                return true;
            }
            return false;
        }
        /**
         * Convert a pair of operands for an arithmetic opcode.  Stores
         * converted results in <code>out[0]</code> and <code>out[1]</code>.
         * @return true if and only if both values converted to number.
         */
        static toNumberPair(x, y, out /*double[] */) {
            if (this.tonumber(y, out)) {
                out[1] = out[0];
                if (this.tonumber(x, out)) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Convert to string.  Returns true if element was number or string
         * (the number will have been converted to a string), false otherwise.
         * Note this actually modifies the element stored at <var>idx</var> in
         * the stack (in faithful emulation of the PUC-Rio code), and when it
         * returns <code>true</code>, <code>stack[idx].r instanceof String</code>
         * is true.
         */
        tostring(idx) {
            // :todo: optimise
            var o = this.objectAt(idx);
            var s = Lua.vmTostring(o);
            if (s == null) {
                return false;
            }
            this._stack[idx].r = s;
            return true;
        }
        /**
         * Equivalent to tryfuncTM from ldo.c.
         * @param func  absolute stack index of the function object.
         */
        tryfuncTM(func) {
            var tm = this.tagmethod(this._stack[func].asObject(), "__call");
            if (!Lua.isFunction(tm)) {
                this.gTypeerror(this._stack[func], "call");
            }
            this.stackInsertAt(tm, func);
            return tm;
        }
        /** Lua's is False predicate. */
        isFalse(o) {
            return o == Lua.NIL || o == false;
        }
        /** @deprecated DO NOT CALL. */
        __isFalse(o) {
            throw new IllegalArgumentException_1.IllegalArgumentException("isFalse called");
        }
        /** Make new CallInfo record. */
        inc_ci(func, baseArg, top, nresults) {
            var ci = new CallInfo_1.CallInfo();
            ci.init(func, baseArg, top, nresults);
            this._civ.addElement(ci);
            return ci;
        }
        /** Pop topmost CallInfo record and return it. */
        dec_ci() {
            var ci = this._civ.pop();
            return ci;
        }
        /** Equivalent to resume_error from ldo.c */
        resume_error(msg) {
            this.stacksetsize(this.__ci().base);
            this.stackAdd(msg);
            return Lua.ERRRUN;
        }
        /**
         * Return the stack element as an Object.  Converts double values into
         * Double objects.
         * @param idx  absolute index into stack (0 <= idx < stackSize).
         */
        objectAt(idx) {
            var r = this._stack[idx].r;
            if (r != Lua.NUMBER) {
                return r;
            }
            return new Number(this._stack[idx].d);
        }
        /**
         * Sets the stack element.  Double instances are converted to double.
         * @param o  Object to store.
         * @param idx  absolute index into stack (0 <= idx < stackSize).
         */
        setObjectAt(o, idx) {
            if (o instanceof Number) {
                this._stack[idx].r = Lua.NUMBER;
                this._stack[idx].d = o;
                return;
            }
            if (Lua.D) {
                console.log("setObjectAt(o, " + idx + ") from " + this._stack);
            }
            this._stack[idx].r = o;
        }
        /**
         * Corresponds to ldump's luaU_dump method, but with data gone and writer
         * replaced by OutputStream.
         */
        static uDump(f, writer, strip) {
            var d = new DumpState_1.DumpState(new DataOutputStream_1.DataOutputStream(writer), strip);
            d.DumpHeader();
            d.DumpFunction(f, null);
            d.writer.flush();
            return 0; // Any errors result in thrown exceptions.
        }
        get global() {
            return this._global;
        }
        set global(global) {
            this._global = global;
        }
        //新增
        set nCcalls(nCcalls) {
            this._nCcalls = nCcalls;
        }
        //新增
        get nCcalls() {
            return this._nCcalls;
        }
    }
    exports.Lua = Lua;
    Lua.D = false;
    /** Version string. */
    Lua.VERSION = "Lua 5.1 (Jill 1.0.1)";
    Lua.RELEASE = "Lua 5.1.4 (Jill 1.0.1)";
    Lua.VERSION_NUM = 501;
    Lua.COPYRIGHT = "Copyright (C) 1994-2008 Lua.org, PUC-Rio (Copyright (C) 2006 Nokia Corporation and/or its subsidiary(-ies))";
    /** http://www.ravenbrook.com */
    Lua.AUTHORS = "R. Ierusalimschy, L. H. de Figueiredo & W. Celes (Ravenbrook Limited)";
    /** Number of list items to accumulate before a SETLIST instruction. */
    Lua.LFIELDS_PER_FLUSH = 50;
    /** Limit for table tag-method chains (to avoid loops) */
    Lua.MAXTAGLOOP = 100;
    /** Nonce object used by pcall and friends (to detect when an
    * exception is a Lua error). */
    Lua.LUA_ERROR = "";
    /**
     * Maximum number of local variables per function.  As per
     * LUAI_MAXVARS from "luaconf.h".  Default access so that {@link
     * FuncState} can see it.
     */
    Lua.MAXVARS = 200;
    Lua.MAXSTACK = 250;
    Lua.MAXUPVALUES = 60;
    /**
     * Stored in Slot.r to denote a numeric value (which is stored at
     * Slot.d).
     */
    Lua.NUMBER = new Object();
    /**
     * Spare Slot used for a temporary.
     */
    Lua.SPARE_SLOT = new Slot_1.Slot();
    /**
    * Registry key for loaded modules.
    */
    Lua.LOADED = "_LOADED";
    //////////////////////////////////////////////////////////////////////
    // Public API
    /**
     * Creates a fresh Lua state.
     */
    /*
    public function Lua()
    {
        this._global = new LuaTable();
        this._registry = new LuaTable();
        this._metatable = new Array(NUM_TAGS); //LuaTable[]
        this._main = this;
    }
    */
    /**
    * Equivalent of LUA_MULTRET.
    */
    // Required, by vmPoscall, to be negative.
    Lua.MULTRET = -1;
    /**
    * The Lua <code>nil</code> value.
    */
    Lua.NIL = new Object();
    // Lua type tags, from lua.h
    /** Lua type tag, representing no stack value. */
    Lua.TNONE = -1;
    /** Lua type tag, representing <code>nil</code>. */
    Lua.TNIL = 0;
    /** Lua type tag, representing boolean. */
    Lua.TBOOLEAN = 1;
    // TLIGHTUSERDATA not available.  :todo: make available?
    /** Lua type tag, representing numbers. */
    Lua.TNUMBER = 3;
    /** Lua type tag, representing strings. */
    Lua.TSTRING = 4;
    /** Lua type tag, representing tables. */
    Lua.TTABLE = 5;
    /** Lua type tag, representing functions. */
    Lua.TFUNCTION = 6;
    /** Lua type tag, representing userdata. */
    Lua.TUSERDATA = 7;
    /** Lua type tag, representing threads. */
    Lua.TTHREAD = 8;
    /**
     * Number of type tags.  Should be one more than the
     * last entry in the list of tags.
     * 类型标签个数
     */
    Lua.NUM_TAGS = 9;
    /** Names for above type tags, starting from {@link #TNIL}.
    * Equivalent to luaT_typenames.
    */
    Lua.TYPENAME = [
        "nil", "boolean", "userdata", "number",
        "string", "table", "function", "userdata", "thread"
    ];
    /**
    * Minimum stack size that Lua Java functions gets.  May turn out to
    * be silly / redundant.
    */
    Lua.MINSTACK = 20;
    /** Status code, returned from pcall and friends, that indicates the
    * thread has yielded.
    */
    Lua.YIELD = 1;
    /** Status code, returned from pcall and friends, that indicates
    * a runtime error.
    */
    Lua.ERRRUN = 2;
    /** Status code, returned from pcall and friends, that indicates
    * a syntax error.
    */
    Lua.ERRSYNTAX = 3;
    /** Status code, returned from pcall and friends, that indicates
    * a memory allocation error.
    */
    Lua.ERRMEM = 4;
    /** Status code, returned from pcall and friends, that indicates
    * an error whilst running the error handler function.
    */
    Lua.ERRERR = 5;
    /** Status code, returned from loadFile and friends, that indicates
    * an IO error.
    */
    Lua.ERRFILE = 6;
    // Enums for gc().
    /** Action, passed to {@link #gc}, that requests the GC to stop. */
    Lua.GCSTOP = 0;
    /** Action, passed to {@link #gc}, that requests the GC to restart. */
    Lua.GCRESTART = 1;
    /** Action, passed to {@link #gc}, that requests a full collection. */
    Lua.GCCOLLECT = 2;
    /** Action, passed to {@link #gc}, that returns amount of memory
     * (in Kibibytes) in use (by the entire Java runtime).
     */
    Lua.GCCOUNT = 3;
    /** Action, passed to {@link #gc}, that returns the remainder of
     * dividing the amount of memory in use by 1024.
     */
    Lua.GCCOUNTB = 4;
    /** Action, passed to {@link #gc}, that requests an incremental
     * garbage collection be performed.
     */
    Lua.GCSTEP = 5;
    /** Action, passed to {@link #gc}, that sets a new value for the
     * <var>pause</var> of the collector.
     */
    Lua.GCSETPAUSE = 6;
    /** Action, passed to {@link #gc}, that sets a new values for the
     * <var>step multiplier</var> of the collector.
     */
    Lua.GCSETSTEPMUL = 7;
    // Some of the hooks, etc, aren't implemented, so remain private.
    Lua.HOOKCALL = 0;
    Lua.HOOKRET = 1;
    Lua.HOOKLINE = 2;
    /**
     * When {@link Hook} callback is called as a line hook, its
     * <var>ar.event</var> field is <code>HOOKCOUNT</code>.
     */
    Lua.HOOKCOUNT = 3;
    Lua.HOOKTAILRET = 4;
    Lua.MASKCALL = 1 << Lua.HOOKCALL;
    Lua.MASKRET = 1 << Lua.HOOKRET;
    Lua.MASKLINE = 1 << Lua.HOOKLINE;
    /**
    * Bitmask that specifies count hook in call to {@link #setHook}.
    */
    Lua.MASKCOUNT = 1 << Lua.HOOKCOUNT;
    Lua.MEMERRMSG = "not enough memory";
    //////////////////////////////////////////////////////////////////////
    // Object
    // Methods equivalent to the file lobject.c.  Prefixed with o.
    Lua.IDSIZE = 60;
    ////////////////////////////////////////////////////////////////////////
    // VM
    // Most of the methods in this section are equivalent to the files
    // lvm.c and ldo.c from PUC-Rio.  They're mostly prefixed with vm as
    // well.
    Lua.PCRLUA = 0;
    Lua.PCRJ = 1;
    Lua.PCRYIELD = 2;
    // Instruction decomposition.
    // There follows a series of methods that extract the various fields
    // from a VM instruction.  See lopcodes.h from PUC-Rio.
    // :todo: Consider replacing with m4 macros (or similar).
    // A brief overview of the instruction format:
    // Logically an instruction has an opcode (6 bits), op, and up to
    // three fields using one of three formats:
    // A B C  (8 bits, 9 bits, 9 bits)
    // A Bx   (8 bits, 18 bits)
    // A sBx  (8 bits, 18 bits signed - excess K)
    // Some instructions do not use all the fields (EG OP_UNM only uses A
    // and B).
    // When packed into a word (an int in Jill) the following layouts are
    // used:
    //  31 (MSB)    23 22          14 13         6 5      0 (LSB)
    // +--------------+--------------+------------+--------+
    // | B            | C            | A          | OPCODE |
    // +--------------+--------------+------------+--------+
    //
    // +--------------+--------------+------------+--------+
    // | Bx                          | A          | OPCODE |
    // +--------------+--------------+------------+--------+
    //
    // +--------------+--------------+------------+--------+
    // | sBx                         | A          | OPCODE |
    // +--------------+--------------+------------+--------+
    Lua.NO_REG = 0xff; // SIZE_A == 8, (1 << 8)-1
    // opcode enumeration.
    // Generated by a script:
    // awk -f opcode.awk < lopcodes.h
    // and then pasted into here.
    // Made default access so that code generation, in FuncState, can see
    // the enumeration as well.
    Lua.OP_MOVE = 0;
    Lua.OP_LOADK = 1;
    Lua.OP_LOADBOOL = 2;
    Lua.OP_LOADNIL = 3;
    Lua.OP_GETUPVAL = 4;
    Lua.OP_GETGLOBAL = 5;
    Lua.OP_GETTABLE = 6;
    Lua.OP_SETGLOBAL = 7;
    Lua.OP_SETUPVAL = 8;
    Lua.OP_SETTABLE = 9;
    Lua.OP_NEWTABLE = 10;
    Lua.OP_SELF = 11;
    Lua.OP_ADD = 12;
    Lua.OP_SUB = 13;
    Lua.OP_MUL = 14;
    Lua.OP_DIV = 15;
    Lua.OP_MOD = 16;
    Lua.OP_POW = 17;
    Lua.OP_UNM = 18;
    Lua.OP_NOT = 19;
    Lua.OP_LEN = 20;
    Lua.OP_CONCAT = 21;
    Lua.OP_JMP = 22;
    Lua.OP_EQ = 23;
    Lua.OP_LT = 24;
    Lua.OP_LE = 25;
    Lua.OP_TEST = 26;
    Lua.OP_TESTSET = 27;
    Lua.OP_CALL = 28;
    Lua.OP_TAILCALL = 29;
    Lua.OP_RETURN = 30;
    Lua.OP_FORLOOP = 31;
    Lua.OP_FORPREP = 32;
    Lua.OP_TFORLOOP = 33;
    Lua.OP_SETLIST = 34;
    Lua.OP_CLOSE = 35;
    Lua.OP_CLOSURE = 36;
    Lua.OP_VARARG = 37;
    // end of instruction decomposition
    Lua.SIZE_C = 9;
    Lua.SIZE_B = 9;
    Lua.SIZE_Bx = Lua.SIZE_C + Lua.SIZE_B;
    Lua.SIZE_A = 8;
    Lua.SIZE_OP = 6;
    Lua.POS_OP = 0;
    Lua.POS_A = Lua.POS_OP + Lua.SIZE_OP;
    Lua.POS_C = Lua.POS_A + Lua.SIZE_A;
    Lua.POS_B = Lua.POS_C + Lua.SIZE_C;
    Lua.POS_Bx = Lua.POS_C;
    Lua.MAXARG_Bx = (1 << Lua.SIZE_Bx) - 1;
    Lua.MAXARG_sBx = Lua.MAXARG_Bx >> 1; // `sBx' is signed
    Lua.MAXARG_A = (1 << Lua.SIZE_A) - 1;
    Lua.MAXARG_B = (1 << Lua.SIZE_B) - 1;
    Lua.MAXARG_C = (1 << Lua.SIZE_C) - 1;
    /* this bit 1 means constant (0 means register) */
    Lua.BITRK = 1 << (Lua.SIZE_B - 1);
    Lua.MAXINDEXRK = Lua.BITRK - 1;
    /**
     * Array of numeric operands.  Used when converting strings to numbers
     * by an arithmetic opcode (ADD, SUB, MUL, DIV, MOD, POW, UNM).
     */
    Lua.NUMOP = new Array(2); //double[]
    /**
    * Printf format item used to convert numbers to strings (in {@link
    * #vmTostring}).  The initial '%' should be not specified.
    */
    Lua.NUMBER_FMT = ".14g";
});

},{"../java/DataOutputStream":6,"../java/IOException":11,"../java/IllegalArgumentException":12,"../java/NullPointerException":16,"../java/NumberFormatException":17,"../java/OutOfMemoryError":18,"../java/Runtime":23,"../java/RuntimeException":24,"../java/Stack":25,"../java/StringBuffer":26,"../java/SystemUtil":27,"./CallInfo":32,"./Debug":34,"./DumpState":35,"./FormatItem":39,"./LuaError":46,"./LuaFunction":47,"./LuaInternal":48,"./LuaJavaCallback":49,"./LuaTable":50,"./LuaUserdata":51,"./Slot":57,"./StringReader":59,"./UpVal":62}],46:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/RuntimeException"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LuaError = void 0;
    const RuntimeException_1 = require("../java/RuntimeException");
    /*  $Header$
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Represent a Lua error
     */
    class LuaError extends RuntimeException_1.RuntimeException {
        constructor(errorStatus) {
            super();
            this.message = "Lua error"; //super("Lua error");
            this._errorStatus = errorStatus;
        }
        get errorStatus() {
            return this._errorStatus;
        }
    }
    exports.LuaError = LuaError;
});

},{"../java/RuntimeException":24}],47:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/NullPointerException", "../java/IllegalArgumentException"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LuaFunction = void 0;
    const NullPointerException_1 = require("../java/NullPointerException");
    const IllegalArgumentException_1 = require("../java/IllegalArgumentException");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/LuaFunction.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Models a Lua function.
     * Note that whilst the class is public, its constructors are not.
     * Functions are created by loading Lua chunks (in source or binary
     * form) or executing Lua code which defines functions (and, for
     * example, places them in the global table).  {@link
     * Lua#load(InputStream, String) Lua.load} is used
     * to load a Lua chunk (it returns a <code>LuaFunction</code>),
     * and {@link Lua#call Lua.call} is used to call a function.
     */
    class LuaFunction {
        /**
         * Constructs an instance from a triple of {Proto, upvalues,
         * environment}.  Deliberately not public, See {@link
         * Lua#load(InputStream, String) Lua.load} for
         * public construction.  All arguments are referenced from the
         * instance.  The <code>upval</code> array must have exactly the same
         * number of elements as the number of upvalues in <code>proto</code>
         * (the value of the <code>nups</code> parameter in the
         * <code>Proto</code> constructor).
         *
         * @param proto  A Proto object.
         * @param upval  Array of upvalues.
         * @param env    The function's environment.
         * @throws NullPointerException if any arguments are null.
         * @throws IllegalArgumentsException if upval.length is wrong.
         */
        constructor(proto, upval /*UpVal[]*/, env) {
            if (null == proto || null == upval || null == env) {
                throw new NullPointerException_1.NullPointerException();
            }
            if (upval.length != proto.nups) {
                throw new IllegalArgumentException_1.IllegalArgumentException();
            }
            this._p = proto;
            this._upval = upval;
            //FIXME:调试用
            //if (this._upval != null && 
            //	this._upval.length == 2)
            //{
            //	(this._upval[0] as UpVal)._s.tagUpVal = true;
            //	(this._upval[1] as UpVal)._s.tagUpVal = true;
            //	trace("this._upval.length == 2");
            //}
            this._env = env;
        }
        /** Get nth UpVal. */
        upVal(n) {
            return this._upval[n];
        }
        /** Get the Proto object. */
        get proto() {
            return this._p;
        }
        /** Getter for environment. */
        get env() {
            return this._env;
        }
        /** Setter for environment. */
        set env(env) {
            if (null == env) {
                throw new NullPointerException_1.NullPointerException();
            }
            this._env = env;
        }
    }
    exports.LuaFunction = LuaFunction;
});

},{"../java/IllegalArgumentException":12,"../java/NullPointerException":16}],48:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/InputStreamReader", "./LuaJavaCallback", "./Lua", "./Loader", "./FromReader", "./Syntax", "./LuaFunction"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LuaInternal = void 0;
    const InputStreamReader_1 = require("../java/InputStreamReader");
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    const Lua_1 = require("./Lua");
    const Loader_1 = require("./Loader");
    const FromReader_1 = require("./FromReader");
    const Syntax_1 = require("./Syntax");
    const LuaFunction_1 = require("./LuaFunction");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/LuaInternal.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Class used to implement internal callbacks.  Currently there is only
     * one callback used, one that parses or loads a Lua chunk into binary
     * form.
     */
    class LuaInternal extends LuaJavaCallback_1.LuaJavaCallback {
        constructor() {
            super();
            this._stream = null;
            this._reader = null;
            this._chunkname = null;
        }
        init1(_in, chunkname) {
            this._stream = _in;
            this._chunkname = chunkname;
        }
        init2(_in, chunkname) {
            this._reader = _in;
            this._chunkname = chunkname;
        }
        luaFunction(L) {
            try {
                var p = null;
                // In either the stream or the reader case there is a way of
                // converting the input to the other type.
                if (this._stream != null) {
                    this._stream.mark(1);
                    var c = this._stream.read();
                    this._stream.reset();
                    // Convert to Reader if looks like source code instead of
                    // binary.
                    if (c == Loader_1.Loader.HEADER[0]) {
                        var l = new Loader_1.Loader(this._stream, this._chunkname);
                        p = l.undump();
                    }
                    else {
                        this._reader = new InputStreamReader_1.InputStreamReader(this._stream, "UTF-8");
                        p = Syntax_1.Syntax.parser(L, this._reader, this._chunkname);
                    }
                }
                else {
                    // Convert to Stream if looks like binary (dumped via
                    // string.dump) instead of source code.
                    if (this._reader.markSupported()) {
                        this._reader.mark(1);
                        var c2 = this._reader.read();
                        this._reader.reset();
                        if (c2 == Loader_1.Loader.HEADER[0]) {
                            this._stream = new FromReader_1.FromReader(this._reader);
                            var l2 = new Loader_1.Loader(this._stream, this._chunkname);
                            p = l2.undump();
                        }
                        else {
                            p = Syntax_1.Syntax.parser(L, this._reader, this._chunkname);
                        }
                    }
                    else {
                        p = Syntax_1.Syntax.parser(L, this._reader, this._chunkname);
                    }
                }
                //
                //new UpVal[0] : 
                //Error #1007: 尝试实例化的函数不是构造函数。
                //TypeError: Error #1007: Instantiation attempted on a non-constructor.
                //
                //L.push(new LuaFunction(p, new UpVal[0], L.getGlobals()));
                L.pushObject(new LuaFunction_1.LuaFunction(p, new Array(), L.getGlobals()));
                return 1;
            }
            catch (e) {
                if (e instanceof Error) {
                    console.log(e.stack);
                }
                if (e instanceof Object) {
                    L.pushString("cannot read " + this._chunkname + ": " + e.toString());
                }
                L.dThrow(Lua_1.Lua.ERRFILE);
                return 0;
            }
            //unreachable
            return 0;
        }
    }
    exports.LuaInternal = LuaInternal;
});

},{"../java/InputStreamReader":14,"./FromReader":40,"./Loader":43,"./Lua":45,"./LuaFunction":47,"./LuaJavaCallback":49,"./Syntax":60}],49:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LuaJavaCallback = void 0;
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/LuaJavaCallback.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Common superclass for all Lua Java Functions.  A Lua function that
     * is implemented in Java is called a Lua Java Function.  Each such
     * function corresponds to an indirect instance of this class.  If you
     * wish to implement your own Lua Java Function then you'll need to
     * subclass this class and have one instance for each function that you
     * need.  It is recommended that you extend the class with at least one
     * member so that you can distinguish the different instances.  Whilst
     * it is possible to implement each different Lua Java Function by
     * having a new subclass for each one, this is not recommended as it
     * will increase the size of the resulting <code>.jar</code> file by a
     * large amount.
     */
    class LuaJavaCallback {
        luaFunction(L) {
            throw new Error("abstract class error");
        }
    }
    exports.LuaJavaCallback = LuaJavaCallback;
});

},{}],50:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/Hashtable", "../java/SystemUtil", "../java/IllegalArgumentException", "./Lua", "./Enum"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LuaTable = void 0;
    const Hashtable_1 = require("../java/Hashtable");
    const SystemUtil_1 = require("../java/SystemUtil");
    const IllegalArgumentException_1 = require("../java/IllegalArgumentException");
    const Lua_1 = require("./Lua");
    const Enum_1 = require("./Enum");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/LuaTable.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Class that models Lua's tables.  Each Lua table is an instance of
     * this class.  Whilst you can clearly see that this class extends
     * {@link java.util.Hashtable} you should in no way rely upon that.
     * Calling any methods that are not defined in this class (but are
     * defined in a super class) is extremely deprecated.
     */
    class LuaTable extends Hashtable_1.Hashtable {
        constructor() {
            //TODO:暂时屏蔽
            super(1);
            this._metatable = null; // = null;
            /**
             * Array used so that tables accessed like arrays are more efficient.
             * All elements stored at an integer index, <var>i</var>, in the
             * range [1,sizeArray] are stored at <code>array[i-1]</code>.
             * This speed and space usage for array-like access.
             * When the table is rehashed the array's size is chosen to be the
             * largest power of 2 such that at least half the entries are
             * occupied.  Default access granted for {@link Enum} class, do not
             * abuse.
             */
            this._array = LuaTable.ZERO; //Object[]
            /**
             * Equal to <code>array.length</code>.  Default access granted for
             * {@link Enum} class, do not abuse.
             */
            this._sizeArray = 0; // = 0;
            /**
             * <code>true</code> whenever we are in the {@link #rehash}
             * method.  Avoids infinite rehash loops.
             */
            this._inrehash = false; // = false;
        }
        /**
         * Fresh LuaTable with hints for preallocating to size.
         * @param narray  number of array slots to preallocate.
         * @param nhash   number of hash slots to preallocate.
         */
        init(narray, nhash) {
            // :todo: super(nhash) isn't clearly correct as adding nhash hash
            // table entries will causes a rehash with the usual implementation
            // (which rehashes when ratio of entries to capacity exceeds the
            // load factor of 0.75).  Perhaps ideally we would size the hash
            // tables such that adding nhash entries will not cause a rehash.
            //TODO:
            //super(nhash); 
            this._array = new Array(narray);
            for (var i = 0; i < narray; ++i) {
                this._array[i] = Lua_1.Lua.NIL;
            }
            this._sizeArray = narray;
        }
        /**
         * Implements discriminating equality.  <code>o1.equals(o2) == (o1 ==
         * o2) </code>.  This method is not necessary in CLDC, it's only
         * necessary in J2SE because java.util.Hashtable overrides equals.
         * @param o  the reference to compare with.
         * @return true when equal.
         */
        equals(o) {
            return this == o;
        }
        /**
         * Provided to avoid Checkstyle warning.  This method is not necessary
         * for correctness (in neither JME nor JSE), it's only provided to
         * remove a Checkstyle warning.
         * Since {@link #equals} implements the most discriminating
         * equality possible, this method can have any implementation.
         * @return an int.
        */
        hashCode() {
            return SystemUtil_1.SystemUtil.identityHashCode(this);
        }
        static arrayindex(key) {
            if (typeof (key) == "number") {
                var d = key;
                var k = d;
                if (k == d) {
                    return k;
                }
            }
            return -1; // 'key' did not match some condition
        }
        static computesizes(nums /*int[] */, narray /*int[] */) {
            var t = narray[0];
            var a = 0; // number of elements smaller than 2^i
            var na = 0; // number of elements to go to array part
            var n = 0; // optimal size for array part
            var twotoi = 1; // 2^i
            for (var i = 0; twotoi / 2 < t; ++i) {
                if (nums[i] > 0) {
                    a += nums[i];
                    if (a > twotoi / 2) // more than half elements present?
                     {
                        n = twotoi; // optimal size (till now)
                        na = a; // all elements smaller than n will go to array part
                    }
                }
                if (a == t) // all elements already counted
                 {
                    break;
                }
                twotoi *= 2;
            }
            narray[0] = n;
            //# assert narray[0]/2 <= na && na <= narray[0]
            return na;
        }
        countint(key, nums /*int[] */) {
            var k = LuaTable.arrayindex(key);
            if (0 < k && k <= LuaTable.MAXASIZE) // is 'key' an appropriate array index?
             {
                ++nums[LuaTable.ceillog2(k)]; // count as such
                return 1;
            }
            return 0;
        }
        numusearray(nums /*int[] */) {
            var ause = 0; // summation of 'nums'
            var i = 1; // count to traverse all array keys
            var ttlg = 1; // 2^lg
            for (var lg = 0; lg <= LuaTable.MAXBITS; ++lg) // for each slice
             {
                var lc = 0; // counter
                var lim = ttlg;
                if (lim > this._sizeArray) {
                    lim = this._sizeArray; // adjust upper limit
                    if (i > lim) {
                        break; // no more elements to count
                    }
                }
                // count elements in range (2^(lg-1), 2^lg]
                for (; i <= lim; ++i) {
                    if (this._array[i - 1] != Lua_1.Lua.NIL) {
                        ++lc;
                    }
                }
                nums[lg] += lc;
                ause += lc;
                ttlg *= 2;
            }
            return ause;
        }
        numusehash(nums /*int[] */, pnasize /*int[] */) {
            var totaluse = 0; // total number of elements
            var ause = 0; // summation of nums
            var e;
            e = super.keys();
            while (e.hasMoreElements()) {
                var o = e.nextElement();
                ause += this.countint(o, nums);
                ++totaluse;
            }
            pnasize[0] += ause;
            return totaluse;
        }
        /**
         * @param nasize  (new) size of array part
         */
        resize(nasize) {
            if (nasize == this._sizeArray) {
                return;
            }
            var newarray = new Array(nasize); //Object[] 
            if (nasize > this._sizeArray) // array part must grow?
             {
                // The new array slots, from sizeArray to nasize-1, must
                // be filled with their values from the hash part.
                // There are two strategies:
                // Iterate over the new array slots, and look up each index in the
                // hash part to see if it has a value; or,
                // Iterate over the hash part and see if each key belongs in the
                // array part.
                // For now we choose the first algorithm.
                // :todo: consider using second algorithm, possibly dynamically.
                SystemUtil_1.SystemUtil.arraycopy(this._array, 0, newarray, 0, this._array.length);
                for (var i = this._array.length; i < nasize; ++i) {
                    var key = new Number(i + 1);
                    var v = super.remove(key);
                    if (v == null) {
                        v = Lua_1.Lua.NIL;
                    }
                    newarray[i] = v;
                }
            }
            if (nasize < this._sizeArray) // array part must shrink?
             {
                // move elements from array slots nasize to sizeArray-1 to the
                // hash part.
                for (i = nasize; i < this._sizeArray; ++i) {
                    if (this._array[i] != Lua_1.Lua.NIL) {
                        key = new Number(i + 1);
                        super.put(key, this._array[i]); //TODO:
                    }
                }
                SystemUtil_1.SystemUtil.arraycopy(this._array, 0, newarray, 0, newarray.length);
            }
            this._array = newarray;
            this._sizeArray = this._array.length;
        }
        rehash() {
            var oldinrehash = this._inrehash;
            this._inrehash = true;
            if (!oldinrehash) {
                var nasize = new Array(1); //int[] 
                var nums = new Array(LuaTable.MAXBITS + 1); //int[] 
                nasize[0] = this.numusearray(nums); // count keys in array part
                var totaluse = nasize[0];
                totaluse += this.numusehash(nums, nasize);
                var na = LuaTable.computesizes(nums, nasize);
                this.resize(nasize[0]);
            }
            super.rehash();
            this._inrehash = oldinrehash;
        }
        /**
         * Getter for metatable member.
         * @return  The metatable.
         */
        get metatable() {
            return this._metatable;
        }
        /**
         * Setter for metatable member.
         * @param metatable  The metatable.
         */
        // :todo: Support metatable's __gc and __mode keys appropriately.
        //        This involves detecting when those keys are present in the
        //        metatable, and changing all the entries in the Hashtable
        //        to be instance of java.lang.Ref as appropriate.
        setMetatable(metatable) {
            this._metatable = metatable;
            return;
        }
        /**
         * Supports Lua's length (#) operator.  More or less equivalent to
         * luaH_getn and unbound_search in ltable.c.
         */
        getn() {
            var j = this._sizeArray;
            if (j > 0 && this._array[j - 1] == Lua_1.Lua.NIL) {
                // there is a boundary in the array part: (binary) search for it
                var i2 = 0;
                while (j - i2 > 1) {
                    var m = (i2 + j) / 2;
                    if (this._array[m - 1] == Lua_1.Lua.NIL) {
                        j = m;
                    }
                    else {
                        i2 = m;
                    }
                }
                return i2;
            }
            // unbound_search
            var i = 0;
            j = 1;
            // Find 'i' and 'j' such that i is present and j is not.
            while (this.getnum(j) != Lua_1.Lua.NIL) {
                i = j;
                j *= 2;
                if (j < 0) // overflow
                 {
                    // Pathological case.  Linear search.
                    i = 1;
                    while (this.getnum(i) != Lua_1.Lua.NIL) {
                        ++i;
                    }
                    return i - 1;
                }
            }
            // binary search between i and j
            while (j - i > 1) {
                var m2 = (i + j) / 2;
                if (this.getnum(m2) == Lua_1.Lua.NIL) {
                    j = m2;
                }
                else {
                    i = m2;
                }
            }
            return i;
        }
        /**
         * Like {@link java.util.Hashtable#get}.  Ensures that indexes
         * with no value return {@link Lua#NIL}.  In order to get the correct
         * behaviour for <code>t[nil]</code>, this code assumes that Lua.NIL
         * is non-<code>null</code>.
         */
        getlua(key) {
            if (typeof (key) == "number") {
                var d = key;
                if (d <= this._sizeArray && d >= 1) {
                    var i = d;
                    if (i == d) {
                        return this._array[i - 1];
                    }
                }
            }
            var r = super._get(key); //TODO:get
            if (r == null) {
                r = Lua_1.Lua.NIL;
            }
            return r;
        }
        /**
         * Like {@link #getlua(Object)} but the result is written into
         * the <var>value</var> {@link Slot}.
         */
        __getlua(key, value) {
            if (key.r == Lua_1.Lua.NUMBER) {
                var d = key.d;
                if (d <= this._sizeArray && d >= 1) {
                    var i = d;
                    if (i == d) {
                        value.setObject(this._array[i - 1]);
                        return;
                    }
                }
            }
            var r = super._get(key.asObject()); //TODO:
            if (r == null) {
                r = Lua_1.Lua.NIL;
            }
            value.setObject(r);
        }
        /** Like get for numeric (integer) keys. */
        getnum(k) {
            if (k <= this._sizeArray && k >= 1) {
                return this._array[k - 1];
            }
            var r = super._get(new Number(k)); //TODO:get
            if (r == null) {
                return Lua_1.Lua.NIL;
            }
            return r;
        }
        /**
         * Like {@link java.util.Hashtable#put} but enables Lua's semantics
         * for <code>nil</code>;
         * In particular that <code>x = nil</nil>
         * deletes <code>x</code>.
         * And also that <code>t[nil]</code> raises an error.
         * Generally, users of Jill should be using
         * {@link Lua#setTable} instead of this.
         * @param key key.
         * @param value value.
         */
        putluaObj(L, key, value) {
            var d = 0.0;
            var i = Number.MAX_SAFE_INTEGER; //TODO:
            if (key == Lua_1.Lua.NIL) {
                L.gRunerror("table index is nil");
            }
            if (typeof (key) == "number") {
                d = key;
                var j = d;
                if (j == d && j >= 1) {
                    i = j; // will cause additional check for array part later if
                    // the array part check fails now.
                    if (i <= this._sizeArray) {
                        this._array[i - 1] = value;
                        return;
                    }
                }
                if (isNaN(d)) {
                    L.gRunerror("table index is NaN");
                }
            }
            // :todo: Consider checking key for NaN (PUC-Rio does)
            if (value == Lua_1.Lua.NIL) {
                this.remove(key);
                return;
            }
            super.put(key, value); //TODO:
            // This check is necessary because sometimes the call to super.put
            // can rehash and the new (k,v) pair should be in the array part
            // after the rehash, but is still in the hash part.
            if (i <= this._sizeArray) {
                this.remove(key);
                this._array[i - 1] = value;
            }
        }
        putluaSlot(L, key, value) {
            var i = Number.MAX_SAFE_INTEGER; //TODO:
            if (key.r == Lua_1.Lua.NUMBER) {
                var j = key.d;
                if (j == key.d && j >= 1) {
                    i = j;
                    if (i <= this._sizeArray) {
                        this._array[i - 1] = value;
                        return;
                    }
                }
                if (isNaN(key.d)) {
                    L.gRunerror("table index is NaN");
                }
            }
            var k = key.asObject();
            // :todo: consider some sort of tail merge with the other putlua
            if (value == Lua_1.Lua.NIL) {
                this.remove(k);
                return;
            }
            super.put(k, value); //TODO:
            if (i <= this._sizeArray) {
                this.remove(k);
                this._array[i - 1] = value;
            }
        }
        /**
         * Like put for numeric (integer) keys.
         */
        putnum(k, v) {
            if (k <= this._sizeArray && k >= 1) {
                this._array[k - 1] = v;
                return;
            }
            // The key can never be NIL so putlua will never notice that its L
            // argument is null.
            // :todo: optimisation to avoid putlua checking for array part again
            this.putluaObj(null, new Number(k), v);
        }
        /**
         * Do not use, implementation exists only to generate deprecated
         * warning.
         * @deprecated Use getlua instead.
         */
        _get(key) {
            throw new IllegalArgumentException_1.IllegalArgumentException();
        }
        keys() {
            return new Enum_1.Enum(this, super.keys());
        }
        /**
         * Do not use, implementation exists only to generate deprecated
         * warning.
         * @deprecated Use putlua instead.
         */
        put(key, value) {
            throw new IllegalArgumentException_1.IllegalArgumentException();
        }
        /**
         * Equivalent to luaO_log2.
         */
        static oLog2(x) {
            //# assert x >= 0
            var l = -1;
            while (x >= 256) {
                l += 8;
                x >>>= 8;
            }
            return l + LuaTable.LOG2[x];
        }
        static ceillog2(x) {
            return LuaTable.oLog2(x - 1) + 1;
        }
        //新增
        get array() {
            return this._array;
        }
        //新增
        get sizeArray() {
            return this._sizeArray;
        }
    }
    exports.LuaTable = LuaTable;
    LuaTable.MAXBITS = 26;
    LuaTable.MAXASIZE = 1 << LuaTable.MAXBITS;
    LuaTable.ZERO = new Array(0); //final Object[]
    /**
     * Used by oLog2.  DO NOT MODIFY.
     */
    LuaTable.LOG2 = [
        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
    ];
});

},{"../java/Hashtable":9,"../java/IllegalArgumentException":12,"../java/SystemUtil":27,"./Enum":37,"./Lua":45}],51:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LuaUserdata = void 0;
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/LuaUserdata.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Models an arbitrary Java reference as a Lua value.
     * This class provides a facility that is equivalent to the userdata
     * facility provided by the PUC-Rio implementation.  It has two primary
     * uses: the first is when you wish to store an arbitrary Java reference
     * in a Lua table; the second is when you wish to create a new Lua type
     * by defining an opaque object with metamethods.  The former is
     * possible because a <code>LuaUserdata</code> can be stored in tables,
     * and passed to functions, just like any other Lua value.  The latter
     * is possible because each <code>LuaUserdata</code> supports a
     * metatable.
     */
    class LuaUserdata {
        /**
         * Wraps an arbitrary Java reference.  To retrieve the reference that
         * was wrapped, use {@link Lua#toUserdata}.
         * @param  o The Java reference to wrap.
         */
        constructor(o) {
            this._metatable = null;
            this._env = null;
            this._userdata = o;
        }
        /**
         * Getter for userdata.
         * @return the userdata that was passed to the constructor of this
         * instance.
         */
        get userdata() {
            return this._userdata;
        }
        /**
         * Getter for metatable.
         * @return the metatable.
         */
        get metatable() {
            return this._metatable;
        }
        /**
         * Setter for metatable.
         * @param metatable The metatable.
         */
        set metatable(metatable) {
            this._metatable = metatable;
        }
        /**
         * Getter for environment.
         * @return The environment.
         */
        get env() {
            return this._env;
        }
        /**
         * Setter for environment.
         * @param env  The environment.
         */
        set env(env) {
            this._env = env;
        }
    }
    exports.LuaUserdata = LuaUserdata;
});

},{}],52:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/Character", "./Lua", "./Syntax"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MatchState = void 0;
    const Character_1 = require("../java/Character");
    const Lua_1 = require("./Lua");
    const Syntax_1 = require("./Syntax");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/StringLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class MatchState {
        // :todo: consider adding the pattern string as a member (and removing
        // p parameter from methods).
        // :todo: consider removing end parameter, if end always == // src.length()
        constructor(L, src, end) {
            /** Total number of captures (finished or unfinished). */
            this._level = 0;
            /** Each capture element is a 2-element array of (index, len). */
            this._capture = new Array();
            this._L = L;
            this._src = src;
            this._end = end;
        }
        /**
         * Returns the length of capture <var>i</var>.
         */
        captureLen(i) {
            var c = this._capture[i]; //(int[])
            return c[1];
        }
        /**
         * Returns the init index of capture <var>i</var>.
         */
        captureInit(i) {
            var c = this._capture[i]; //(int[])
            return c[0];
        }
        /**
         * Returns the 2-element array for the capture <var>i</var>.
         */
        capture(i) {
            return this._capture[i]; //(int[])
        }
        capInvalid() {
            return this._L.error("invalid capture index");
        }
        malBra() {
            return this._L.error("malformed pattern (missing '[')");
        }
        capUnfinished() {
            return this._L.error("unfinished capture");
        }
        malEsc() {
            return this._L.error("malformed pattern (ends with '%')");
        }
        check_capture(l) {
            l -= '1'.charCodeAt(0); // relies on wraparound.
            if (l >= this._level || this.captureLen(l) == MatchState.CAP_UNFINISHED)
                this.capInvalid();
            return l;
        }
        capture_to_close() {
            var lev = this._level;
            for (lev--; lev >= 0; lev--)
                if (this.captureLen(lev) == MatchState.CAP_UNFINISHED)
                    return lev;
            return this.capInvalid();
        }
        classend(p, pi) {
            switch (p.charAt(pi++)) {
                case String.fromCharCode(MatchState.L_ESC):
                    // assert pi < p.length() // checked by callers
                    return pi + 1;
                case '[':
                    if (p.length == pi)
                        return this.malBra();
                    if (p.charAt(pi) == '^')
                        ++pi;
                    do // look for a ']'
                     {
                        if (p.length == pi)
                            return this.malBra();
                        if (p.charCodeAt(pi++) == MatchState.L_ESC) {
                            if (p.length == pi)
                                return this.malBra();
                            ++pi; // skip escapes (e.g. '%]')
                            if (p.length == pi)
                                return this.malBra();
                        }
                    } while (p.charAt(pi) != ']');
                    return pi + 1;
                default:
                    return pi;
            }
        }
        /**
         * @param c   char match.
         * @param cl  character class.
         */
        static match_class(c, cl) {
            var res;
            switch (Character_1.Character.toLowerCase(cl)) {
                case 'a':
                    res = Syntax_1.Syntax.isalpha(c);
                    break;
                case 'c':
                    res = Syntax_1.Syntax.iscntrl(c);
                    break;
                case 'd':
                    res = Syntax_1.Syntax.isdigit(c);
                    break;
                case 'l':
                    res = Syntax_1.Syntax.islower(c);
                    break;
                case 'p':
                    res = Syntax_1.Syntax.ispunct(c);
                    break;
                case 's':
                    res = Syntax_1.Syntax.isspace(c);
                    break;
                case 'u':
                    res = Syntax_1.Syntax.isupper(c);
                    break;
                case 'w':
                    res = Syntax_1.Syntax.isalnum(c);
                    break;
                case 'x':
                    res = Syntax_1.Syntax.isxdigit(c);
                    break;
                case 'z':
                    res = (c == 0);
                    break;
                default:
                    return (cl == c);
            }
            return Character_1.Character.isLowerCase(cl) ? res : !res;
        }
        /**
         * @param pi  index in p of start of class.
         * @param ec  index in p of end of class.
         */
        static matchbracketclass(c, p, pi, ec) {
            // :todo: consider changing char c to int c, then -1 could be used
            // represent a guard value at the beginning and end of all strings (a
            // better NUL).  -1 of course would match no positive class.
            // assert p.charAt(pi) == '[';
            // assert p.charAt(ec) == ']';
            var sig = true;
            if (p.charCodeAt(pi + 1) == '^'.charCodeAt(0)) {
                sig = false;
                ++pi; // skip the '6'
            }
            while (++pi < ec) {
                if (p.charCodeAt(pi) == MatchState.L_ESC) {
                    ++pi;
                    if (this.match_class(c, p.charCodeAt(pi)))
                        return sig;
                }
                else if ((p.charAt(pi + 1) == '-') && (pi + 2 < ec)) {
                    pi += 2;
                    if (p.charCodeAt(pi - 2) <= c && c <= p.charCodeAt(pi))
                        return sig;
                }
                else if (p.charCodeAt(pi) == c) {
                    return sig;
                }
            }
            return !sig;
        }
        static singlematch(c, p, pi, ep) {
            switch (p.charAt(pi)) {
                case '.':
                    return true; // matches any char
                case String.fromCharCode(MatchState.L_ESC):
                    return this.match_class(c, p.charCodeAt(pi + 1));
                case '[':
                    return this.matchbracketclass(c, p, pi, ep - 1);
                default:
                    return p.charCodeAt(pi) == c;
            }
        }
        // Generally all the various match functions from PUC-Rio which take a
        // MatchState and return a "const char *" are transformed into
        // instance methods that take and return string indexes.
        matchbalance(si, p, pi) {
            if (pi + 1 >= p.length)
                this._L.error("unbalanced pattern");
            if (si >= this._end || this._src.charAt(si) != p.charAt(pi)) {
                return -1;
            }
            var b = p.charCodeAt(pi);
            var e = p.charCodeAt(pi + 1);
            var cont = 1;
            while (++si < this._end) {
                if (this._src.charCodeAt(si) == e) {
                    if (--cont == 0)
                        return si + 1;
                }
                else if (this._src.charCodeAt(si) == b) {
                    ++cont;
                }
            }
            return -1; // string ends out of balance
        }
        max_expand(si, p, pi, ep) {
            var i = 0; // counts maximum expand for item
            while (si + i < this._end && MatchState.singlematch(this._src.charCodeAt(si + i), p, pi, ep)) {
                ++i;
            }
            // keeps trying to match with the maximum repetitions
            while (i >= 0) {
                var res = this.match(si + i, p, ep + 1);
                if (res >= 0)
                    return res;
                --i; // else didn't match; reduce 1 repetition to try again
            }
            return -1;
        }
        min_expand(si, p, pi, ep) {
            while (true) {
                var res = this.match(si, p, ep + 1);
                if (res >= 0)
                    return res;
                else if (si < this._end && MatchState.singlematch(this._src.charCodeAt(si), p, pi, ep))
                    ++si; // try with one more repetition
                else
                    return -1;
            }
            //unreachable
            return -1;
        }
        start_capture(si, p, pi, what) {
            var temp = new Array(this._level + 1);
            for (var kk = 0; kk < temp.length; ++kk) {
                temp[kk] = this._capture[kk];
            }
            this._capture = temp;
            this._capture[this._level] = [si, what];
            ++this._level;
            var res = this.match(si, p, pi);
            if (res < 0) // match failed
             {
                --this._level;
            }
            return res;
        }
        end_capture(si, p, pi) {
            var l = this.capture_to_close();
            this.capture(l)[1] = si - this.captureInit(l); // close it
            var res = this.match(si, p, pi);
            if (res < 0) // match failed?
             {
                this.capture(l)[1] = MatchState.CAP_UNFINISHED; // undo capture
            }
            return res;
        }
        match_capture(si, l) {
            l = this.check_capture(l);
            var len = this.captureLen(l);
            if (this._end - si >= len) //TODO: 
             
            /*              &&
                        src.regionMatches(false,
                            captureInit(l),
                            src,
                            si,
                            len))*/
            {
                return si + len;
            }
            return -1;
        }
        /**
         * @param si  index of subject at which to attempt match.
         * @param p   pattern string.
         * @param pi  index into pattern (from which to being matching).
         * @return the index of the end of the match, -1 for no match.
         */
        match(si, p, pi) {
            // This code has been considerably changed in the transformation
            // from C to Java.  There are the following non-obvious changes:
            // - The C code routinely relies on NUL being accessible at the end of
            //   the pattern string.  In Java we can't do this, so we use many
            //   more explicit length checks and pull error cases into this
            //   function.  :todo: consider appending NUL to the pattern string.
            // - The C code uses a "goto dflt" which is difficult to transform in
            //   the usual way.
            init: // labelled while loop emulates "goto init", which we use to
             
            // optimize tail recursion.
            while (true) {
                if (p.length == pi) // end of pattern
                    return si; // match succeeded
                switch (p.charAt(pi)) {
                    case '(':
                        if (p.length == pi + 1) {
                            return this.capUnfinished();
                        }
                        if (p.charAt(pi + 1) == ')') // position capture?
                            return this.start_capture(si, p, pi + 2, MatchState.CAP_POSITION);
                        return this.start_capture(si, p, pi + 1, MatchState.CAP_UNFINISHED);
                    case ')': // end capture
                        return this.end_capture(si, p, pi + 1);
                    case String.fromCharCode(MatchState.L_ESC):
                        if (p.length == pi + 1) {
                            return this.malEsc();
                        }
                        switch (p.charAt(pi + 1)) {
                            case 'b': // balanced string?
                                si = this.matchbalance(si, p, pi + 2);
                                if (si < 0)
                                    return si;
                                pi += 4;
                                // else return match(ms, s, p+4);
                                continue init; // goto init
                            case 'f': // frontier
                                {
                                    pi += 2;
                                    if (p.length == pi || p.charAt(pi) != '[')
                                        return this._L.error("missing '[' after '%f' in pattern");
                                    var ep = this.classend(p, pi); // indexes what is next
                                    var previous = (si == 0) ? '\0'.charCodeAt(0) : this._src.charCodeAt(si - 1);
                                    var at = (si == this._end) ? '\0'.charCodeAt(0) : this._src.charCodeAt(si);
                                    if (MatchState.matchbracketclass(previous, p, pi, ep - 1) ||
                                        !MatchState.matchbracketclass(at, p, pi, ep - 1)) {
                                        return -1;
                                    }
                                    pi = ep;
                                    // else return match(ms, s, ep);
                                }
                                continue init; // goto init
                            default:
                                if (Syntax_1.Syntax.isdigit(p.charCodeAt(pi + 1))) // capture results (%0-%09)?
                                 {
                                    si = this.match_capture(si, p.charCodeAt(pi + 1));
                                    if (si < 0)
                                        return si;
                                    pi += 2;
                                    // else return match(ms, s, p+2);
                                    continue init; // goto init
                                }
                            // We emulate a goto dflt by a fallthrough to the next
                            // case (of the outer switch) and making sure that the
                            // next case has no effect when we fallthrough to it from here.
                            // goto dflt;
                        }
                    // FALLTHROUGH
                    case '$':
                        if (p.charAt(pi) == '$') {
                            if (p.length == pi + 1) // is the '$' the last char in pattern?
                                return (si == this._end) ? si : -1; // check end of string
                            // else goto dflt;
                        }
                    // FALLTHROUGH
                    default: // it is a pattern item
                        {
                            var ep2 = this.classend(p, pi); // indexes what is next
                            var m = si < this._end && MatchState.singlematch(this._src.charCodeAt(si), p, pi, ep2);
                            if (p.length > ep2) {
                                switch (p.charAt(ep2)) {
                                    case '?': // optional
                                        if (m) {
                                            var res = this.match(si + 1, p, ep2 + 1);
                                            if (res >= 0)
                                                return res;
                                        }
                                        pi = ep2 + 1;
                                        // else return match(s, ep+1);
                                        continue init; // goto init
                                    case '*': // 0 or more repetitions
                                        return this.max_expand(si, p, pi, ep2);
                                    case '+': // 1 or more repetitions
                                        return m ? this.max_expand(si + 1, p, pi, ep2) : -1;
                                    case '-': // 0 or more repetitions (minimum)
                                        return this.min_expand(si, p, pi, ep2);
                                }
                            }
                            // else or default:
                            if (!m)
                                return -1;
                            ++si;
                            pi = ep2;
                            // return match(ms, s+1, ep);
                            continue init;
                        }
                }
            }
            //unreachable
            return -1;
        }
        /**
         * @param s  index of start of match.
         * @param e  index of end of match.
         */
        onecapture(i, s, e) {
            if (i >= this._level) {
                if (i == 0) // level == 0, too
                    return this._src.substring(s, e); // add whole match
                else
                    this.capInvalid();
                // NOTREACHED;
            }
            var l = this.captureLen(i);
            if (l == MatchState.CAP_UNFINISHED)
                this.capUnfinished();
            if (l == MatchState.CAP_POSITION)
                return Lua_1.Lua.valueOfNumber(this.captureInit(i) + 1);
            return this._src.substring(this.captureInit(i), this.captureInit(i) + l);
        }
        push_onecapture(i, s, e) {
            this._L.pushObject(this.onecapture(i, s, e));
        }
        /**
         * @param s  index of start of match.
         * @param e  index of end of match.
         */
        push_captures(s, e) {
            var nlevels = (this._level == 0 && s >= 0) ? 1 : this._level;
            for (var i = 0; i < nlevels; ++i)
                this.push_onecapture(i, s, e);
            return nlevels; // number of strings pushed
        }
        /** A helper for gsub.  Equivalent to add_s from lstrlib.c. */
        adds(b, si, ei) {
            var news = this._L.toString_(this._L.value(3));
            var l = news.length;
            for (var i = 0; i < l; ++i) {
                if (news.charCodeAt(i) != MatchState.L_ESC) {
                    b.append(news.charCodeAt(i));
                }
                else {
                    ++i; // skip L_ESC
                    if (!Syntax_1.Syntax.isdigit(news.charCodeAt(i))) {
                        b.append(news.charCodeAt(i));
                    }
                    else if (news.charAt(i) == '0') {
                        b.appendString(this._src.substring(si, ei));
                    }
                    else {
                        // add capture to accumulated result
                        b.appendString(this._L.toString_(this.onecapture(news.charCodeAt(i) - '1'.charCodeAt(0), si, ei)));
                    }
                }
            }
        }
        /** A helper for gsub.  Equivalent to add_value from lstrlib.c. */
        addvalue(b, si, ei) {
            switch (this._L.type(3)) {
                case Lua_1.Lua.TNUMBER:
                case Lua_1.Lua.TSTRING:
                    this.adds(b, si, ei);
                    return;
                case Lua_1.Lua.TFUNCTION:
                    {
                        this._L.pushValue(3);
                        var n = this.push_captures(si, ei);
                        this._L.call(n, 1);
                    }
                    break;
                case Lua_1.Lua.TTABLE:
                    this._L.pushObject(this._L.getTable(this._L.value(3), this.onecapture(0, si, ei)));
                    break;
                default:
                    {
                        this._L.argError(3, "string/function/table expected");
                        return;
                    }
            }
            if (!this._L.toBoolean(this._L.value(-1))) // nil or false
             {
                this._L.pop(1);
                this._L.pushString(this._src.substring(si, ei));
            }
            else if (!Lua_1.Lua.isString(this._L.value(-1))) {
                this._L.error("invalid replacement value (a " +
                    Lua_1.Lua.typeName(this._L.type(-1)) + ")");
            }
            b.appendString(this._L.toString_(this._L.value(-1))); // add result to accumulator
            this._L.pop(1);
        }
        //新增
        get end() {
            return this._end;
        }
        //新增
        set level(level) {
            this._level = level;
        }
    }
    exports.MatchState = MatchState;
    MatchState.L_ESC = '%'.charCodeAt(0);
    MatchState.SPECIALS = "^$*+?.([%-";
    MatchState.CAP_UNFINISHED = -1;
    MatchState.CAP_POSITION = -2;
});

},{"../java/Character":5,"./Lua":45,"./Syntax":60}],53:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/Random", "../java/MathUtil", "./LuaJavaCallback", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MathLib = void 0;
    const Random_1 = require("../java/Random");
    const MathUtil_1 = require("../java/MathUtil");
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/MathLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Contains Lua's math library.
     * The library can be opened using the {@link #open} method.
     * Because this library is implemented on top of CLDC 1.1 it is not as
     * complete as the PUC-Rio math library.  Trigononmetric inverses
     * (EG <code>acos</code>) and hyperbolic trigonometric functions (EG
     * <code>cosh</code>) are not provided.
     */
    class MathLib extends LuaJavaCallback_1.LuaJavaCallback {
        /** Constructs instance, filling in the 'which' member. */
        constructor(which) {
            super();
            this._which = which;
        }
        /**
         * Implements all of the functions in the Lua math library.  Do not
         * call directly.
         * @param L  the Lua state in which to execute.
         * @return number of returned parameters, as per convention.
         */
        luaFunction(L) {
            switch (this._which) {
                case MathLib.ABS:
                    return MathLib.abs(L);
                case MathLib.CEIL:
                    return MathLib.ceil(L);
                case MathLib.COS:
                    return MathLib.cos(L);
                case MathLib.DEG:
                    return MathLib.deg(L);
                case MathLib.EXP:
                    return MathLib.exp(L);
                case MathLib.FLOOR:
                    return MathLib.floor(L);
                case MathLib.FMOD:
                    return MathLib.fmod(L);
                case MathLib.MAX:
                    return MathLib.max(L);
                case MathLib.MIN:
                    return MathLib.min(L);
                case MathLib.MODF:
                    return MathLib.modf(L);
                case MathLib.POW:
                    return MathLib.pow(L);
                case MathLib.RAD:
                    return MathLib.rad(L);
                case MathLib.RANDOM:
                    return MathLib.random(L);
                case MathLib.RANDOMSEED:
                    return MathLib.randomseed(L);
                case MathLib.SIN:
                    return MathLib.sin(L);
                case MathLib.SQRT:
                    return MathLib.sqrt(L);
                case MathLib.TAN:
                    return MathLib.tan(L);
            }
            return 0;
        }
        /**
         * Opens the library into the given Lua state.  This registers
         * the symbols of the library in the global table.
         * @param L  The Lua state into which to open.
         */
        static open(L) {
            var t = L.__register("math");
            MathLib.r(L, "abs", MathLib.ABS);
            MathLib.r(L, "ceil", MathLib.CEIL);
            MathLib.r(L, "cos", MathLib.COS);
            MathLib.r(L, "deg", MathLib.DEG);
            MathLib.r(L, "exp", MathLib.EXP);
            MathLib.r(L, "floor", MathLib.FLOOR);
            MathLib.r(L, "fmod", MathLib.FMOD);
            MathLib.r(L, "max", MathLib.MAX);
            MathLib.r(L, "min", MathLib.MIN);
            MathLib.r(L, "modf", MathLib.MODF);
            MathLib.r(L, "pow", MathLib.POW);
            MathLib.r(L, "rad", MathLib.RAD);
            MathLib.r(L, "random", MathLib.RANDOM);
            MathLib.r(L, "randomseed", MathLib.RANDOMSEED);
            MathLib.r(L, "sin", MathLib.SIN);
            MathLib.r(L, "sqrt", MathLib.SQRT);
            MathLib.r(L, "tan", MathLib.TAN);
            L.setField(t, "pi", Lua_1.Lua.valueOfNumber(Math.PI));
            L.setField(t, "huge", Lua_1.Lua.valueOfNumber(Number.POSITIVE_INFINITY));
        }
        /** Register a function. */
        static r(L, name, which) {
            var f = new MathLib(which);
            L.setField(L.getGlobal("math"), name, f);
        }
        static abs(L) {
            L.pushNumber(Math.abs(L.checkNumber(1)));
            return 1;
        }
        static ceil(L) {
            L.pushNumber(Math.ceil(L.checkNumber(1)));
            return 1;
        }
        static cos(L) {
            L.pushNumber(Math.cos(L.checkNumber(1)));
            return 1;
        }
        static deg(L) {
            L.pushNumber(MathUtil_1.MathUtil.toDegrees(L.checkNumber(1)));
            return 1;
        }
        static exp(L) {
            // CLDC 1.1 has Math.E but no exp, pow, or log.  Bizarre.
            L.pushNumber(Lua_1.Lua.iNumpow(Math.E, L.checkNumber(1)));
            return 1;
        }
        static floor(L) {
            L.pushNumber(Math.floor(L.checkNumber(1)));
            return 1;
        }
        static fmod(L) {
            L.pushNumber(L.checkNumber(1) % L.checkNumber(2));
            return 1;
        }
        static max(L) {
            var n = L.getTop(); // number of arguments
            var dmax = L.checkNumber(1);
            for (var i = 2; i <= n; ++i) {
                var d = L.checkNumber(i);
                dmax = Math.max(dmax, d);
            }
            L.pushNumber(dmax);
            return 1;
        }
        static min(L) {
            var n = L.getTop(); // number of arguments
            var dmin = L.checkNumber(1);
            for (var i = 2; i <= n; ++i) {
                var d = L.checkNumber(i);
                dmin = Math.min(dmin, d);
            }
            L.pushNumber(dmin);
            return 1;
        }
        static modf(L) {
            var x = L.checkNumber(1);
            var fp = x % 1;
            var ip = x - fp;
            L.pushNumber(ip);
            L.pushNumber(fp);
            return 2;
        }
        static pow(L) {
            L.pushNumber(Lua_1.Lua.iNumpow(L.checkNumber(1), L.checkNumber(2)));
            return 1;
        }
        static rad(L) {
            L.pushNumber(MathUtil_1.MathUtil.toRadians(L.checkNumber(1)));
            return 1;
        }
        static random(L) {
            // It would seem better style to associate the java.util.Random
            // instance with the Lua instance (by implementing and using a
            // registry for example).  However, PUC-rio uses the ISO C library
            // and so will share the same random number generator across all Lua
            // states.  So we do too.
            switch (L.getTop()) // check number of arguments
             {
                case 0: // no arguments
                    L.pushNumber(MathLib._rng.nextDouble());
                    break;
                case 1: // only upper limit
                    {
                        var u = L.checkInt(1);
                        L.argCheck(1 <= u, 1, "interval is empty");
                        L.pushNumber(MathLib._rng.nextInt(u) + 1);
                    }
                    break;
                case 2: // lower and upper limits
                    {
                        var l = L.checkInt(1);
                        var u2 = L.checkInt(2);
                        L.argCheck(l <= u2, 2, "interval is empty");
                        L.pushNumber(MathLib._rng.nextInt(u2) + l);
                    }
                    break;
                default:
                    return L.error("wrong number of arguments");
            }
            return 1;
        }
        static randomseed(L) {
            MathLib._rng.setSeed(L.checkNumber(1));
            return 0;
        }
        static sin(L) {
            L.pushNumber(Math.sin(L.checkNumber(1)));
            return 1;
        }
        static sqrt(L) {
            L.pushNumber(Math.sqrt(L.checkNumber(1)));
            return 1;
        }
        static tan(L) {
            L.pushNumber(Math.tan(L.checkNumber(1)));
            return 1;
        }
    }
    exports.MathLib = MathLib;
    // Each function in the library corresponds to an instance of
    // this class which is associated (the 'which' member) with an integer
    // which is unique within this class.  They are taken from the following
    // set.
    MathLib.ABS = 1;
    //private static const acos:int = 2;
    //private static const asin:int = 3;
    //private static const atan2:int = 4;
    //private static const atan:int = 5;
    MathLib.CEIL = 6;
    //private static const cosh:int = 7;
    MathLib.COS = 8;
    MathLib.DEG = 9;
    MathLib.EXP = 10;
    MathLib.FLOOR = 11;
    MathLib.FMOD = 12;
    //private static const frexp:int = 13;
    //private static const ldexp:int = 14;
    //private static const log:int = 15;
    MathLib.MAX = 16;
    MathLib.MIN = 17;
    MathLib.MODF = 18;
    MathLib.POW = 19;
    MathLib.RAD = 20;
    MathLib.RANDOM = 21;
    MathLib.RANDOMSEED = 22;
    //private static const sinh:int = 23;
    MathLib.SIN = 24;
    MathLib.SQRT = 25;
    //private static const tanh:int = 26;
    MathLib.TAN = 27;
    MathLib._rng = new Random_1.Random();
});

},{"../java/MathUtil":15,"../java/Random":21,"./Lua":45,"./LuaJavaCallback":49}],54:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/Calendar", "../java/StringBuffer", "../java/SystemUtil", "../java/TimeZone", "./Lua", "./LuaJavaCallback"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OSLib = void 0;
    const Calendar_1 = require("../java/Calendar");
    const StringBuffer_1 = require("../java/StringBuffer");
    const SystemUtil_1 = require("../java/SystemUtil");
    const TimeZone_1 = require("../java/TimeZone");
    const Lua_1 = require("./Lua");
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/OSLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    // REFERENCES
    // [C1990] "ISO Standard: Programming languages - C"; ISO 9899:1990;
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * The OS Library.  Can be opened into a {@link Lua} state by invoking
     * the {@link #open} method.
     */
    class OSLib extends LuaJavaCallback_1.LuaJavaCallback {
        /** Constructs instance, filling in the 'which' member. */
        constructor(which) {
            super();
            this._which = which;
        }
        /**
         * Implements all of the functions in the Lua os library (that are
         * provided).  Do not call directly.
         * @param L  the Lua state in which to execute.
         * @return number of returned parameters, as per convention.
         */
        luaFunction(L) {
            switch (this._which) {
                case OSLib.CLOCK:
                    return OSLib.clock(L);
                case OSLib.DATE:
                    return OSLib.date(L);
                case OSLib.DIFFTIME:
                    return OSLib.difftime(L);
                case OSLib.GETENV:
                    return OSLib.getenv(L);
                case OSLib.SETLOCALE:
                    return OSLib.setlocale(L);
                case OSLib.TIME:
                    return OSLib.time(L);
            }
            return 0;
        }
        /**
         * Opens the library into the given Lua state.  This registers
         * the symbols of the library in the table "os".
         * @param L  The Lua state into which to open.
         */
        static open(L) {
            L.__register("os");
            OSLib.r(L, "clock", OSLib.CLOCK);
            OSLib.r(L, "date", OSLib.DATE);
            OSLib.r(L, "difftime", OSLib.DIFFTIME);
            OSLib.r(L, "getenv", OSLib.GETENV);
            OSLib.r(L, "setlocale", OSLib.SETLOCALE);
            OSLib.r(L, "time", OSLib.TIME);
        }
        /** Register a function. */
        static r(L, name, which) {
            var f = new OSLib(which);
            var lib = L.getGlobal("os");
            L.setField(lib, name, f);
        }
        /** Implements clock.  Java provides no way to get CPU time, so we
         * return the amount of wall clock time since this class was loaded.
         */
        static clock(L) {
            var d = SystemUtil_1.SystemUtil.currentTimeMillis();
            d = d - OSLib.T0;
            d /= 1000;
            L.pushNumber(d);
            return 1;
        }
        /** Implements date. */
        static date(L) {
            var t;
            if (L.isNoneOrNil(2)) {
                t = SystemUtil_1.SystemUtil.currentTimeMillis();
            }
            else {
                t = L.checkNumber(2);
            }
            var s = L.optString(1, "%c");
            var tz = TimeZone_1.TimeZone.getDefault();
            if (s.substr(0, 1) == "!") {
                tz = TimeZone_1.TimeZone.getTimeZone("GMT");
                s = s.substring(1);
            }
            var c = Calendar_1.Calendar.getInstance(tz);
            c.setTime(new Date(t));
            if (s == "*t") {
                L.pushObject(L.createTable(0, 8)); // 8 = number of fields
                OSLib.setfield(L, "sec", c._get(Calendar_1.Calendar.SECOND));
                OSLib.setfield(L, "min", c._get(Calendar_1.Calendar.MINUTE));
                OSLib.setfield(L, "hour", c._get(Calendar_1.Calendar.HOUR));
                OSLib.setfield(L, "day", c._get(Calendar_1.Calendar.DAY_OF_MONTH));
                OSLib.setfield(L, "month", OSLib.canonicalmonth(c._get(Calendar_1.Calendar.MONTH)));
                OSLib.setfield(L, "year", c._get(Calendar_1.Calendar.YEAR));
                OSLib.setfield(L, "wday", OSLib.canonicalweekday(c._get(Calendar_1.Calendar.DAY_OF_WEEK)));
                // yday is not supported because CLDC 1.1 does not provide it.
                // setfield(L, "yday", c.get("???"));
                if (tz.useDaylightTime()) {
                    // CLDC 1.1 does not provide any way to determine isdst, so we set
                    // it to -1 (which in C means that the information is not
                    // available).
                    OSLib.setfield(L, "isdst", -1);
                }
                else {
                    // On the other hand if the timezone does not do DST then it
                    // can't be in effect.
                    OSLib.setfield(L, "isdst", 0);
                }
            }
            else {
                var b = new StringBuffer_1.StringBuffer();
                var i = 0;
                var l = s.length;
                while (i < l) {
                    var ch = s.charCodeAt(i);
                    ++i;
                    if (ch != '%'.charCodeAt(0)) {
                        b.append(ch);
                        continue;
                    }
                    if (i >= l) {
                        break;
                    }
                    ch = s.charCodeAt(i);
                    ++i;
                    // Generally in order to save space, the abbreviated forms are
                    // identical to the long forms.
                    // The specifiers are from [C1990].
                    switch (String.fromCharCode(ch)) {
                        case 'a':
                        case 'A':
                            b.appendString(OSLib.weekdayname(c));
                            break;
                        case 'b':
                        case 'B':
                            b.appendString(OSLib.monthname(c));
                            break;
                        case 'c':
                            b.appendString(c.getTime().toString());
                            break;
                        case 'd':
                            b.appendString(OSLib.format(c._get(Calendar_1.Calendar.DAY_OF_MONTH), 2));
                            break;
                        case 'H':
                            b.appendString(OSLib.format(c._get(Calendar_1.Calendar.HOUR), 2));
                            break;
                        case 'I':
                            {
                                var h = c._get(Calendar_1.Calendar.HOUR);
                                h = (h + 11) % 12 + 1; // force into range 1-12
                                b.appendString(OSLib.format(h, 2));
                            }
                            break;
                        case 'j':
                        case 'U':
                        case 'W':
                            // Not supported because CLDC 1.1 doesn't provide it.
                            b.append('%'.charCodeAt(0));
                            b.append(ch);
                            break;
                        case 'm':
                            {
                                var m = OSLib.canonicalmonth(c._get(Calendar_1.Calendar.MONTH));
                                b.appendString(OSLib.format(m, 2));
                            }
                            break;
                        case 'M':
                            b.appendString(OSLib.format(c._get(Calendar_1.Calendar.MINUTE), 2));
                            break;
                        case 'p':
                            {
                                var h2 = c._get(Calendar_1.Calendar.HOUR);
                                b.appendString(h2 < 12 ? "am" : "pm");
                            }
                            break;
                        case 'S':
                            b.appendString(OSLib.format(c._get(Calendar_1.Calendar.SECOND), 2));
                            break;
                        case 'w':
                            b.append(OSLib.canonicalweekday(c._get(Calendar_1.Calendar.DAY_OF_WEEK)));
                            break;
                        case 'x':
                            {
                                var u = c.getTime().toString();
                                // We extract fields from the result of Date.toString.
                                // The output of which is of the form:
                                // dow mon dd hh:mm:ss zzz yyyy
                                // except that zzz is optional.
                                b.appendString(u.substring(0, 11));
                                b.append(c._get(Calendar_1.Calendar.YEAR));
                            }
                            break;
                        case 'X':
                            {
                                var u2 = c.getTime().toString();
                                b.appendString(u2.substring(11, u2.length - 5));
                            }
                            break;
                        case 'y':
                            b.appendString(OSLib.format(c._get(Calendar_1.Calendar.YEAR) % 100, 2));
                            break;
                        case 'Y':
                            b.append(c._get(Calendar_1.Calendar.YEAR));
                            break;
                        case 'Z':
                            b.appendString(tz.getID());
                            break;
                        case '%':
                            b.append('%'.charCodeAt(0));
                            break;
                    }
                } /* while */
                L.pushString(b.toString());
            }
            return 1;
        }
        /** Implements difftime. */
        static difftime(L) {
            L.pushNumber((L.checkNumber(1) - L.optNumber(2, 0)) / 1000);
            return 1;
        }
        /** Implements setlocale. */
        static setlocale(L) {
            if (L.isNoneOrNil(1)) {
                L.pushString("");
            }
            else {
                L.pushNil();
            }
            return 1;
        }
        /** Implements time. */
        static time(L) {
            if (L.isNoneOrNil(1)) // called without args?
             {
                L.pushNumber(SystemUtil_1.SystemUtil.currentTimeMillis());
                return 1;
            }
            L.checkType(1, Lua_1.Lua.TTABLE);
            L.setTop(1); // make sure table is at the top
            var c = Calendar_1.Calendar.getInstance();
            c._set(Calendar_1.Calendar.SECOND, OSLib.getfield(L, "sec", 0));
            c._set(Calendar_1.Calendar.MINUTE, OSLib.getfield(L, "min", 0));
            c._set(Calendar_1.Calendar.HOUR, OSLib.getfield(L, "hour", 12));
            c._set(Calendar_1.Calendar.DAY_OF_MONTH, OSLib.getfield(L, "day", -1));
            c._set(Calendar_1.Calendar.MONTH, OSLib.MONTH[OSLib.getfield(L, "month", -1) - 1]);
            c._set(Calendar_1.Calendar.YEAR, OSLib.getfield(L, "year", -1));
            // ignore isdst field
            L.pushNumber(c.getTime().getTime());
            return 1;
        }
        static getfield(L, key, d) {
            var o = L.getField(L.value(-1), key);
            if (Lua_1.Lua.isNumber(o))
                return L.toNumber(o);
            if (d < 0)
                return L.error("field '" + key + "' missing in date table");
            return d;
        }
        static setfield(L, key, value) {
            L.setField(L.value(-1), key, Lua_1.Lua.valueOfNumber(value));
        }
        /** Format a positive integer in a 0-filled field of width
         * <var>w</var>.
         */
        static format(i, w) {
            var b = new StringBuffer_1.StringBuffer();
            b.append(i);
            while (b.length() < w) {
                b.insert(0, '0'.charCodeAt(0));
            }
            return b.toString();
        }
        static weekdayname(c) {
            var s = c.getTime().toString();
            return s.substring(0, 3);
        }
        static monthname(c) {
            var s = c.getTime().toString();
            return s.substring(4, 7);
        }
        /**
         * (almost) inverts the conversion provided by {@link #MONTH}.  Converts
         * from a {@link Calendar} value to a month in the range 1-12.
         * @param m  a value from the enum Calendar.JANUARY, Calendar.FEBRUARY, etc
         * @return a month in the range 1-12, or the original value.
         */
        static canonicalmonth(m) {
            for (var i = 0; i < OSLib.MONTH.length; ++i) {
                if (m == OSLib.MONTH[i]) {
                    return i + 1;
                }
            }
            return m;
        }
        /**
         * Converts from a {@link Calendar} value to a weekday in the range
         * 0-6 where 0 is Sunday (as per the convention used in [C1990]).
         * @param w  a value from the enum Calendar.SUNDAY, Calendar.MONDAY, etc
         * @return a weekday in the range 0-6, or the original value.
         */
        static canonicalweekday(w) {
            for (var i = 0; i < OSLib.WEEKDAY.length; ++i) {
                if (w == OSLib.WEEKDAY[i]) {
                    return i;
                }
            }
            return w;
        }
        //FIXME:not implemented
        static getenv(L) {
            var name = L.checkString(1);
            //FIXME:
            var value = null;
            if (value == null) {
                L.pushNil();
            }
            else {
                L.pushString(value);
            }
            return 1;
        }
    }
    exports.OSLib = OSLib;
    // Each function in the library corresponds to an instance of
    // this class which is associated (the 'which' member) with an integer
    // which is unique within this class.  They are taken from the following
    // set.
    OSLib.CLOCK = 1;
    OSLib.DATE = 2;
    OSLib.DIFFTIME = 3;
    // EXECUTE = 4;
    // EXIT = 5;
    OSLib.GETENV = 6;
    // REMOVE = 7;
    // RENAME = 8;
    OSLib.SETLOCALE = 9;
    OSLib.TIME = 10;
    OSLib.T0 = SystemUtil_1.SystemUtil.currentTimeMillis();
    // Incredibly, the spec doesn't give a numeric value and range for
    // Calendar.JANUARY through to Calendar.DECEMBER.
    /**
     * Converts from 0-11 to required Calendar value.  DO NOT MODIFY THIS
     * ARRAY.
     */
    OSLib.MONTH = [
        Calendar_1.Calendar.JANUARY,
        Calendar_1.Calendar.FEBRUARY,
        Calendar_1.Calendar.MARCH,
        Calendar_1.Calendar.APRIL,
        Calendar_1.Calendar.MAY,
        Calendar_1.Calendar.JUNE,
        Calendar_1.Calendar.JULY,
        Calendar_1.Calendar.AUGUST,
        Calendar_1.Calendar.SEPTEMBER,
        Calendar_1.Calendar.OCTOBER,
        Calendar_1.Calendar.NOVEMBER,
        Calendar_1.Calendar.DECEMBER
    ];
    // DO NOT MODIFY ARRAY
    OSLib.WEEKDAY = [
        Calendar_1.Calendar.SUNDAY,
        Calendar_1.Calendar.MONDAY,
        Calendar_1.Calendar.TUESDAY,
        Calendar_1.Calendar.WEDNESDAY,
        Calendar_1.Calendar.THURSDAY,
        Calendar_1.Calendar.FRIDAY,
        Calendar_1.Calendar.SATURDAY,
    ];
});

},{"../java/Calendar":4,"../java/StringBuffer":26,"../java/SystemUtil":27,"../java/TimeZone":28,"./Lua":45,"./LuaJavaCallback":49}],55:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/StringBuffer", "../java/IOException", "../java/SystemUtil", "./LuaJavaCallback", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PackageLib = void 0;
    const StringBuffer_1 = require("../java/StringBuffer");
    const IOException_1 = require("../java/IOException");
    const SystemUtil_1 = require("../java/SystemUtil");
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/PackageLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Contains Lua's package library.
     * The library
     * can be opened using the {@link #open} method.
     */
    class PackageLib extends LuaJavaCallback_1.LuaJavaCallback {
        constructor(which, me) {
            super();
            this._which = which;
            this._me = ((me !== undefined) ? me : null);
        }
        //private function __init(which:int, me:LuaTable):void
        //{
        //	this._which = which;
        //	this.me = me;
        //}
        /**
        * Implements all of the functions in the Lua package library.  Do not
        * call directly.
        * @param L  the Lua state in which to execute.
        * @return number of returned parameters, as per convention.
        */
        luaFunction(L) {
            switch (this._which) {
                case PackageLib.MODULE:
                    return this.module(L);
                case PackageLib.REQUIRE:
                    return this.require(L);
                case PackageLib.SEEALL:
                    return PackageLib.seeall(L);
                case PackageLib.LOADER_LUA:
                    return this.loaderLua(L);
                case PackageLib.LOADER_PRELOAD:
                    return this.loaderPreload(L);
            }
            return 0;
        }
        /**
         * Opens the library into the given Lua state.  This registers
         * the symbols of the library in the global table.
         * @param L  The Lua state into which to open.
         */
        static open(L) {
            var t = L.__register("package");
            PackageLib.g(L, t, "module", PackageLib.MODULE);
            PackageLib.g(L, t, "require", PackageLib.REQUIRE);
            PackageLib.r(L, "seeall", PackageLib.SEEALL);
            L.setField(t, "loaders", L.newTable());
            PackageLib.p(L, t, PackageLib.LOADER_PRELOAD);
            PackageLib.p(L, t, PackageLib.LOADER_LUA);
            PackageLib.setpath(L, t, "path", PackageLib.PATH_DEFAULT); // set field 'path'
            // set field 'loaded'
            L.findTable(L.getRegistry(), Lua_1.Lua.LOADED, 1);
            L.setField(t, "loaded", L.value(-1));
            L.pop(1);
            L.setField(t, "preload", L.newTable());
        }
        /** Register a function. */
        static r(L, name, which) {
            var f = new PackageLib(which);
            L.setField(L.getGlobal("package"), name, f);
        }
        /** Register a function in the global table. */
        static g(L, t, name, which) {
            var f = new PackageLib(which, t);
            L.setGlobal(name, f);
        }
        /** Register a loader in package.loaders. */
        static p(L, t, which) {
            var f = new PackageLib(which, t);
            var loaders = L.getField(t, "loaders");
            L.rawSetI(loaders, Lua_1.Lua.objLen(loaders) + 1, f);
        }
        /**
        * Implements the preload loader.  This is conventionally stored
        * first in the package.loaders table.
        */
        loaderPreload(L) {
            var name = L.checkString(1);
            var preload = L.getField(this._me, "preload");
            if (!Lua_1.Lua.isTable(preload))
                L.error("'package.preload' must be a table");
            var loader = L.getField(preload, name);
            if (Lua_1.Lua.isNil(loader)) // not found?
                L.pushString("\n\tno field package.preload['" + name + "']");
            L.pushObject(loader);
            return 1;
        }
        /**
         * Implements the lua loader.  This is conventionally stored second in
         * the package.loaders table.
         */
        loaderLua(L) {
            var name = L.checkString(1);
            var filename = this.findfile(L, name, "path");
            if (filename == null)
                return 1; // library not found in this path
            if (L.loadFile(filename) != 0)
                PackageLib.loaderror(L, filename);
            return 1; // library loaded successfully
        }
        /** Implements module. */
        module(L) {
            var modname = L.checkString(1);
            var loaded = L.getField(this._me, "loaded");
            var module = L.getField(loaded, modname);
            if (!Lua_1.Lua.isTable(module)) // not found?
             {
                // try global variable (and create one if it does not exist)
                if (L.findTable(L.getGlobals(), modname, 1) != null)
                    return L.error("name conflict for module '" + modname + "'");
                module = L.value(-1);
                L.pop(1);
                // package.loaded = new table
                L.setField(loaded, modname, module);
            }
            // check whether table already has a _NAME field
            if (Lua_1.Lua.isNil(L.getField(module, "_NAME"))) {
                PackageLib.modinit(L, module, modname);
            }
            PackageLib.setfenv(L, module);
            PackageLib.dooptions(L, module, L.getTop());
            return 0;
        }
        /** Implements require. */
        require(L) {
            var name = L.checkString(1);
            L.setTop(1);
            // PUC-Rio's use of lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
            // (package.loaded is kept in the registry in PUC-Rio) is translated
            // into this:
            var loaded = L.getField(this._me, "loaded");
            var module = L.getField(loaded, name);
            if (L.toBoolean(module)) // is it there?
             {
                if (module == PackageLib.SENTINEL) // check loops
                    L.error("loop or previous error loading module '" + name + "'");
                L.pushObject(module);
                return 1;
            }
            // else must load it; iterate over available loaders.
            var loaders = L.getField(this._me, "loaders");
            if (!Lua_1.Lua.isTable(loaders))
                L.error("'package.loaders' must be a table");
            L.pushString(""); // error message accumulator
            for (var i = 1;; ++i) {
                var loader = Lua_1.Lua.rawGetI(loaders, i); // get a loader
                if (Lua_1.Lua.isNil(loader))
                    L.error("module '" + name + "' not found:" +
                        L.toString_(L.value(-1)));
                L.pushObject(loader);
                L.pushString(name);
                L.call(1, 1); // call it
                if (Lua_1.Lua.isFunction(L.value(-1))) // did it find module?
                    break; // module loaded successfully
                else if (Lua_1.Lua.isString(L.value(-1))) // loader returned error message?
                    L.concat(2); // accumulate it
                else
                    L.pop(1);
            }
            L.setField(loaded, name, PackageLib.SENTINEL); // package.loaded[name] = sentinel
            L.pushString(name); // pass name as argument to module
            L.call(1, 1); // run loaded module
            if (!Lua_1.Lua.isNil(L.value(-1))) // non-nil return?
             {
                // package.loaded[name] = returned value
                L.setField(loaded, name, L.value(-1));
            }
            module = L.getField(loaded, name);
            if (module == PackageLib.SENTINEL) // module did not set a value?
             {
                module = Lua_1.Lua.valueOfBoolean(true); // use true as result
                L.setField(loaded, name, module); // package.loaded[name] = true
            }
            L.pushObject(module);
            return 1;
        }
        /** Implements package.seeall. */
        static seeall(L) {
            L.checkType(1, Lua_1.Lua.TTABLE);
            var mt = L.getMetatable(L.value(1));
            if (mt == null) {
                mt = L.createTable(0, 1);
                L.setMetatable(L.value(1), mt);
            }
            L.setField(mt, "__index", L.getGlobals());
            return 0;
        }
        /**
        * Helper for module.  <var>module</var> parameter replaces PUC-Rio
        * use of passing it on the stack.
        */
        static setfenv(L, module) {
            var ar = L.getStack(1);
            L.getInfo("f", ar);
            L.setFenv(L.value(-1), module);
            L.pop(1);
        }
        /**
         * Helper for module.  <var>module</var> parameter replaces PUC-Rio
         * use of passing it on the stack.
         */
        static dooptions(L, module, n) {
            for (var i = 2; i <= n; ++i) {
                L.pushValue(i); // get option (a function)
                L.pushObject(module);
                L.call(1, 0);
            }
        }
        /**
        * Helper for module.  <var>module</var> parameter replaces PUC-Rio
        * use of passing it on the stack.
        */
        static modinit(L, module, modname) {
            L.setField(module, "_M", module); // module._M = module
            L.setField(module, "_NAME", modname);
            var dot = modname.lastIndexOf('.'); // look for last dot in module name
            // Surprisingly, ++dot works when '.' was found and when it wasn't.
            ++dot;
            // set _PACKAGE as package name (full module name minus last part)
            L.setField(module, "_PACKAGE", modname.substring(0, dot));
        }
        static loaderror(L, filename) {
            L.error("error loading module '" + L.toString_(L.value(1)) +
                "' from file '" + filename + "':\n\t" +
                L.toString_(L.value(-1)));
        }
        static readable(filename) {
            var f = SystemUtil_1.SystemUtil.getResourceAsStream(filename);
            if (f == null)
                return false;
            try {
                f.close();
            }
            catch (e_) {
                if (e_ instanceof IOException_1.IOException) {
                    console.log(e_.getStackTrace());
                }
            }
            return true;
        }
        static pushnexttemplate(L, path) {
            var i = 0;
            // skip seperators
            while (i < path.length && path.substr(i, 1) == PackageLib.PATHSEP) //TODO:
                ++i;
            if (i == path.length)
                return null; // no more templates
            var l = path.indexOf(PackageLib.PATHSEP, i);
            if (l < 0)
                l = path.length;
            L.pushString(path.substring(i, l)); // template
            return path.substring(l);
        }
        findfile(L, name, pname) {
            name = PackageLib.gsub(name, ".", PackageLib.DIRSEP);
            var path = L.toString_(L.getField(this._me, pname));
            if (path == null)
                L.error("'package." + pname + "' must be a string");
            L.pushString(""); // error accumulator
            while (true) {
                path = PackageLib.pushnexttemplate(L, path);
                if (path == null)
                    break;
                var filename = PackageLib.gsub(L.toString_(L.value(-1)), PackageLib.PATH_MARK, name);
                if (PackageLib.readable(filename)) // does file exist and is readable?
                    return filename; // return that file name
                L.pop(1); // remove path template
                L.pushString("\n\tno file '" + filename + "'");
                L.concat(2);
            }
            return null; // not found
        }
        /** Almost equivalent to luaL_gsub. */
        static gsub(s, p, r) {
            var b = new StringBuffer_1.StringBuffer();
            // instead of incrementing the char *s, we use the index i
            var i = 0;
            var l = p.length;
            while (true) {
                var wild = s.indexOf(p, i);
                if (wild < 0)
                    break;
                b.appendString(s.substring(i, wild)); // add prefix
                b.appendString(r); // add replacement in place of pattern
                i = wild + l; // continue after 'p'
            }
            b.appendString(s.substring(i));
            return b.toString();
        }
        static setpath(L, t, fieldname, def) {
            // :todo: consider implementing a user-specified path via
            // javax.microedition.midlet.MIDlet.getAppProperty or similar.
            // Currently we just use a default path defined by Jill.
            L.setField(t, fieldname, def);
        }
    }
    exports.PackageLib = PackageLib;
    // Each function in the library corresponds to an instance of
    // this class which is associated (the 'which' member) with an integer
    // which is unique within this class.  They are taken from the following
    // set.
    PackageLib.MODULE = 1;
    PackageLib.REQUIRE = 2;
    PackageLib.SEEALL = 3;
    PackageLib.LOADER_PRELOAD = 4;
    PackageLib.LOADER_LUA = 5;
    PackageLib.DIRSEP = "/";
    PackageLib.PATHSEP = ';'; //TODO:
    PackageLib.PATH_MARK = "?";
    PackageLib.PATH_DEFAULT = "?.lua;?/init.lua";
    PackageLib.SENTINEL = new Object();
});

},{"../java/IOException":11,"../java/StringBuffer":26,"../java/SystemUtil":27,"./Lua":45,"./LuaJavaCallback":49}],56:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/IllegalArgumentException", "../java/NullPointerException", "../java/SystemUtil", "./LocVar", "./Lua", "./Slot"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Proto = void 0;
    const IllegalArgumentException_1 = require("../java/IllegalArgumentException");
    const NullPointerException_1 = require("../java/NullPointerException");
    const SystemUtil_1 = require("../java/SystemUtil");
    const LocVar_1 = require("./LocVar");
    const Lua_1 = require("./Lua");
    const Slot_1 = require("./Slot");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Proto.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/
    /**
     * Models a function prototype.  This class is internal to Jill and
     * should not be used by clients.  This is the analogue of the PUC-Rio
     * type <code>Proto</code>, hence the name.
     * A function prototype represents the constant part of a function, that
     * is, a function without closures (upvalues) and without an
     * environment.  It's a handle for a block of VM instructions and
     * ancillary constants.
     *
     * For convenience some private arrays are exposed.  Modifying these
     * arrays is punishable by death. (Java has no convenient constant
     * array datatype)
     */
    class Proto {
        //TODO:
        constructor() {
            // Generally the fields are named following the PUC-Rio implementation
            // and so are unusually terse.
            /** Array of constants. */
            this._k = null; //Slot[] 
            this._sizek = 0;
            /** Array of VM instructions. */
            this._code = null; //int[] 
            this._sizecode = 0;
            /** Array of Proto objects. */
            this._p = null; //Proto[] 
            this._sizep = 0;
            /**
             * Number of upvalues used by this prototype (and so by all the
             * functions created from this Proto).
             */
            this._nups = 0;
            /**
             * Number of formal parameters used by this prototype, and so the
             * number of argument received by a function created from this Proto.
             * In a function defined to be variadic then this is the number of
             * fixed parameters, the number appearing before '...' in the parameter
             * list.
             */
            this._numparams = 0;
            /**
             * <code>true</code> if and only if the function is variadic, that is,
             * defined with '...' in its parameter list.
             */
            this._isVararg = false;
            this._maxstacksize = 0;
            // Debug info
            /** Map from PC to line number. */
            this._lineinfo = null; //int[]
            this._sizelineinfo = 0;
            this._locvars = null; //LocVar[] 
            this._sizelocvars = 0;
            this._upvalues = null; //String[] 
            this._sizeupvalues = 0;
            this._source = null;
            this._linedefined = 0;
            this._lastlinedefined = 0;
        }
        /**
         * Proto synthesized by {@link Loader}.
         * All the arrays that are passed to the constructor are
         * referenced by the instance.  Avoid unintentional sharing.  All
         * arrays must be non-null and all int parameters must not be
         * negative.  Generally, this constructor is used by {@link Loader}
         * since that has all the relevant arrays already constructed (as
         * opposed to the compiler).
         * @param constant   array of constants.
         * @param code       array of VM instructions.
         * @param nups       number of upvalues (used by this function).
         * @param numparams  number of fixed formal parameters.
         * @param isVararg   whether '...' is used.
         * @param maxstacksize  number of stack slots required when invoking.
         * @throws NullPointerException if any array arguments are null.
         * @throws IllegalArgumentException if nups or numparams is negative.
         */
        init1(constant, //Slot[] 
        code, //int[] 
        proto, //Proto[] 
        nups, numparams, isVararg, maxstacksize) {
            if (null == constant || null == code || null == proto) {
                throw new NullPointerException_1.NullPointerException();
            }
            if (nups < 0 || numparams < 0 || maxstacksize < 0) {
                throw new IllegalArgumentException_1.IllegalArgumentException();
            }
            this._k = constant;
            this._sizek = this._k.length;
            this._code = code;
            this._sizecode = this._code.length;
            this._p = proto;
            this._sizep = proto.length;
            this._nups = nups;
            this._numparams = numparams;
            this.isVararg = isVararg;
            this._maxstacksize = maxstacksize;
        }
        /**
         * Blank Proto in preparation for compilation.
         * 废弃？
         */
        init2(source, maxstacksize) {
            this._maxstacksize = maxstacksize;
            // maxstacksize = 2;   // register 0/1 are always valid.
            // :todo: Consider removing size* members
            this._source = source;
            this._k = Proto.ZERO_CONSTANT_ARRAY;
            this._sizek = 0;
            this._code = Proto.ZERO_INT_ARRAY;
            this._sizecode = 0;
            this._p = Proto.ZERO_PROTO_ARRAY;
            this._sizep = 0;
            this._lineinfo = Proto.ZERO_INT_ARRAY;
            this._sizelineinfo = 0;
            this._locvars = Proto.ZERO_LOCVAR_ARRAY;
            this._sizelocvars = 0;
            this._upvalues = Proto.ZERO_STRING_ARRAY;
            this._sizeupvalues = 0;
        }
        /**
         * Augment with debug info.  All the arguments are referenced by the
         * instance after the method has returned, so try not to share them.
         */
        debug(lineinfoArg, //int[] 
        locvarsArg, //LocVar[] 
        upvaluesArg) {
            this._lineinfo = lineinfoArg;
            this._sizelineinfo = this._lineinfo.length;
            this._locvars = locvarsArg;
            this._sizelocvars = this._locvars.length;
            this._upvalues = upvaluesArg;
            this._sizeupvalues = this._upvalues.length;
        }
        /** Gets source. */
        get source() {
            return this._source;
        }
        /** Setter for source. */
        set source(source) {
            this._source = source;
        }
        get linedefined() {
            return this._linedefined;
        }
        set linedefined(linedefined) {
            this._linedefined = linedefined;
        }
        get lastlinedefined() {
            return this._lastlinedefined;
        }
        set lastlinedefined(lastlinedefined) {
            this._lastlinedefined = lastlinedefined;
        }
        /** Gets Number of Upvalues */
        get nups() {
            return this._nups;
        }
        set nups(nups) {
            this._nups = nups;
        }
        /** Number of Parameters. */
        get numparams() {
            return this._numparams;
        }
        set numparams(numparams) {
            this._numparams = numparams;
        }
        /** Maximum Stack Size. */
        get maxstacksize() {
            return this._maxstacksize;
        }
        /** Setter for maximum stack size. */
        set maxstacksize(m) {
            this._maxstacksize = m;
        }
        /** Instruction block (do not modify). */
        get code() {
            return this._code;
        }
        /** Append instruction. */
        codeAppend(L, pc, instruction, line) {
            if (Proto.D) {
                console.log("pc:" + pc +
                    ", instruction:" + instruction +
                    ", line:" + line +
                    ", lineinfo.length:" + this.lineinfo.length);
            }
            this.ensureCode(L, pc);
            this._code[pc] = instruction;
            if (pc >= this._lineinfo.length) {
                var newLineinfo = new Array(this._lineinfo.length * 2 + 1); //int[]
                SystemUtil_1.SystemUtil.arraycopy(this._lineinfo, 0, newLineinfo, 0, this._lineinfo.length);
                this._lineinfo = newLineinfo;
            }
            this._lineinfo[pc] = line;
        }
        ensureLocvars(L, atleast, limit) {
            if (atleast + 1 > this._sizelocvars) {
                var newsize = atleast * 2 + 1;
                if (newsize > limit)
                    newsize = limit;
                if (atleast + 1 > newsize)
                    L.gRunerror("too many local variables");
                var newlocvars = new Array(newsize); //LocVar []
                SystemUtil_1.SystemUtil.arraycopy(this.locvars, 0, newlocvars, 0, this._sizelocvars);
                for (var i = this._sizelocvars; i < newsize; i++)
                    newlocvars[i] = new LocVar_1.LocVar();
                this._locvars = newlocvars;
                this._sizelocvars = newsize;
            }
        }
        ensureProtos(L, atleast) {
            if (atleast + 1 > this._sizep) {
                var newsize = atleast * 2 + 1;
                if (newsize > Lua_1.Lua.MAXARG_Bx)
                    newsize = Lua_1.Lua.MAXARG_Bx;
                if (atleast + 1 > newsize)
                    L.gRunerror("constant table overflow");
                var newprotos = new Array(newsize); //Proto [] 
                SystemUtil_1.SystemUtil.arraycopy(this._p, 0, newprotos, 0, this._sizep);
                this._p = newprotos;
                this._sizep = newsize;
            }
        }
        ensureUpvals(L, atleast) {
            if (atleast + 1 > this._sizeupvalues) {
                var newsize = atleast * 2 + 1;
                if (atleast + 1 > newsize)
                    L.gRunerror("upvalues overflow");
                var newupvalues = new Array(newsize); //String []
                SystemUtil_1.SystemUtil.arraycopy(this._upvalues, 0, newupvalues, 0, this._sizeupvalues);
                this._upvalues = newupvalues;
                this._sizeupvalues = newsize;
            }
        }
        ensureCode(L, atleast) {
            if (atleast + 1 > this._sizecode) {
                var newsize = atleast * 2 + 1;
                if (atleast + 1 > newsize)
                    L.gRunerror("code overflow");
                var newcode = new Array(newsize); //int [] 
                SystemUtil_1.SystemUtil.arraycopy(this._code, 0, newcode, 0, this._sizecode);
                this._code = newcode;
                this._sizecode = newsize;
            }
        }
        /** Set lineinfo record. */
        setLineinfo(pc, line) {
            this._lineinfo[pc] = line;
        }
        /** Get linenumber corresponding to pc, or 0 if no info. */
        getline(pc) {
            if (this._lineinfo.length == 0) {
                return 0;
            }
            return this._lineinfo[pc];
        }
        /** Array of inner protos (do not modify). */
        get proto() {
            return this._p;
        }
        /** Constant array (do not modify). */
        get constant() {
            return this._k;
        }
        /** Append constant. */
        constantAppend(idx, o) {
            if (idx >= this._k.length) {
                var newK = new Array(this._k.length * 2 + 1); //Slot[]
                SystemUtil_1.SystemUtil.arraycopy(this._k, 0, newK, 0, this._k.length);
                this._k = newK;
            }
            this._k[idx] = new Slot_1.Slot();
            this._k[idx].init2(o);
        }
        /** Predicate for whether function uses ... in its parameter list. */
        get isVararg() {
            return this._isVararg;
        }
        /** "Setter" for isVararg.  Sets it to true. */
        set isVararg(isVararg) {
            this._isVararg = true;
        }
        /** LocVar array (do not modify). */
        get locvars() {
            return this._locvars;
        }
        // All the trim functions, below, check for the redundant case of
        // trimming to the length that they already are.  Because they are
        // initially allocated as interned zero-length arrays this also means
        // that no unnecesary zero-length array objects are allocated.
        /**
         * Trim an int array to specified size.
         * @return the trimmed array.
         */
        trimInt(old /*int[] */, n) {
            if (n == old.length) {
                return old;
            }
            var newArray = new Array(n); //int[] 
            SystemUtil_1.SystemUtil.arraycopy(old, 0, newArray, 0, n);
            return newArray;
        }
        /** Trim code array to specified size. */
        closeCode(n) {
            this._code = this.trimInt(this._code, n);
            this._sizecode = this._code.length;
        }
        /** Trim lineinfo array to specified size. */
        closeLineinfo(n) {
            this._lineinfo = this.trimInt(this._lineinfo, n);
            this._sizelineinfo = n;
        }
        /** Trim k (constant) array to specified size. */
        closeK(n) {
            if (this._k.length > n) {
                var newArray = new Array(n); //Slot[] 
                SystemUtil_1.SystemUtil.arraycopy(this._k, 0, newArray, 0, n);
                this._k = newArray;
            }
            this._sizek = n;
            return;
        }
        /** Trim p (proto) array to specified size. */
        closeP(n) {
            if (n == this._p.length) {
                return;
            }
            var newArray = new Array(n); //Proto[] 
            SystemUtil_1.SystemUtil.arraycopy(this._p, 0, newArray, 0, n);
            this._p = newArray;
            this._sizep = n;
        }
        /** Trim locvar array to specified size. */
        closeLocvars(n) {
            if (n == this.locvars.length) {
                return;
            }
            var newArray = new Array(n); //LocVar[] 
            SystemUtil_1.SystemUtil.arraycopy(this.locvars, 0, newArray, 0, n);
            this._locvars = newArray;
            this._sizelocvars = n;
        }
        /** Trim upvalues array to size <var>nups</var>. */
        closeUpvalues() {
            if (this.nups == this._upvalues.length) {
                return;
            }
            var newArray = new Array(this.nups); //String[] 
            SystemUtil_1.SystemUtil.arraycopy(this._upvalues, 0, newArray, 0, this.nups);
            this._upvalues = newArray;
            this._sizeupvalues = this.nups;
        }
        //新增
        get k() {
            return this._k;
        }
        //新增
        get sizek() {
            return this._sizek;
        }
        //新增
        get sizecode() {
            return this._sizecode;
        }
        //新增
        get p() {
            return this._p;
        }
        //新增
        get sizep() {
            return this._sizep;
        }
        //新增
        get lineinfo() {
            return this._lineinfo;
        }
        //新增
        get sizelineinfo() {
            return this._sizelineinfo;
        }
        //新增
        get sizelocvars() {
            return this._sizelocvars;
        }
        //新增
        get upvalues() {
            return this._upvalues;
        }
        //新增
        get sizeupvalues() {
            return this._sizeupvalues;
        }
    }
    exports.Proto = Proto;
    Proto.D = false;
    /** Interned 0-element array. */
    Proto.ZERO_INT_ARRAY = new Array(); /*int[] = new int[0]*/
    Proto.ZERO_LOCVAR_ARRAY = new Array(); /*LocVar[]  = new LocVar[0]*/
    Proto.ZERO_CONSTANT_ARRAY = new Array(); //final Slot[] ZERO_CONSTANT_ARRAY = new Slot[0];
    Proto.ZERO_PROTO_ARRAY = new Array(); //final Proto[] ZERO_PROTO_ARRAY = new Proto[0];
    Proto.ZERO_STRING_ARRAY = new Array(); //final String[] ZERO_STRING_ARRAY = new String[0];
});

},{"../java/IllegalArgumentException":12,"../java/NullPointerException":16,"../java/SystemUtil":27,"./LocVar":44,"./Lua":45,"./Slot":57}],57:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slot = void 0;
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/BlockCnt.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    class Slot {
        //private var _tag:Boolean = false;
        //public var tagUpVal:Boolean = false;
        constructor() {
            this._r = null;
            this._d = 0;
        }
        init1(s) {
            this._r = s._r;
            this._d = s._d;
            //testD();
        }
        //TODO:
        init2(o) {
            this.setObject(o);
        }
        asObject() {
            if (this._r == Lua_1.Lua.NUMBER) {
                return new Number(this._d);
            }
            return this._r;
        }
        setObject(o) {
            //_tag = true;
            //if (!Lua.D)
            //{
            //	if (o == null)
            //	{
            //		trace("setObject:", o.toString());
            //	}
            //}
            this._r = o;
            if (typeof (o) == 'number') {
                this._r = Lua_1.Lua.NUMBER;
                this._d = o;
                //testD();
            }
            //if (_d == 150048)
            //{
            //	trace("setObject 150048:", o.toString());
            //}
        }
        //新增
        set r(r) {
            this._r = r;
            //if (r == null)
            //{
            //	if (Lua.D)
            //	{
            //		//FIXME:如果为空值的话报错，可以用于发现问题(index no value错误）
            //		trace("Slot set r : ", r.toString());
            //	}
            //}	
        }
        //新增
        get r() {
            return this._r;
        }
        //新增
        set d(d) {
            //if (this.tagUpVal == true)
            //{
            //	trace("======this.tagUpVal == true, set d from " + this._d + "=>" + d);
            //}
            this._d = d;
            //testD();
        }
        //新增
        get d() {
            return this._d;
        }
        //调试用
        testD__() {
            /*
            if (this._d == 150048)
            {
                trace("setObject 150048:xxx r==" + this._r);
            }
            */
            //if (isNaN(this._d))
            //{
            //	trace("setObject 150048:xxxxx");
            //}
            //if (this.tagUpVal == true)
            //{
            //	trace("==============");
            //}
            //if (this.tagUpVal == true)
            //{
            //	trace("======this.tagUpVal == true, =>" + this._d);
            //}
        }
    }
    exports.Slot = Slot;
});

},{"./Lua":45}],58:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/StringBuffer", "../java/ByteArrayOutputStream", "./LuaJavaCallback", "./FormatItem", "./Lua", "./LuaTable", "./MatchState"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringLib = void 0;
    const StringBuffer_1 = require("../java/StringBuffer");
    const ByteArrayOutputStream_1 = require("../java/ByteArrayOutputStream");
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    const FormatItem_1 = require("./FormatItem");
    const Lua_1 = require("./Lua");
    const LuaTable_1 = require("./LuaTable");
    const MatchState_1 = require("./MatchState");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/StringLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Contains Lua's string library.
     * The library can be opened using the {@link #open} method.
     */
    class StringLib extends LuaJavaCallback_1.LuaJavaCallback {
        /** Constructs instance, filling in the 'which' member. */
        constructor(which) {
            super();
            this._which = which;
        }
        /**
         * Adjusts the output of string.format so that %e and %g use 'e'
         * instead of 'E' to indicate the exponent.  In other words so that
         * string.format follows the ISO C (ISO 9899) standard for printf.
         */
        formatISO() {
            FormatItem_1.FormatItem.E_LOWER = 'e'.charCodeAt(0);
        }
        /**
         * Implements all of the functions in the Lua string library.  Do not
         * call directly.
         * @param L  the Lua state in which to execute.
         * @return number of returned parameters, as per convention.
         */
        luaFunction(L) {
            switch (this._which) {
                case StringLib.BYTE:
                    return StringLib.byteFunction(L);
                case StringLib.CHAR:
                    return StringLib.charFunction(L);
                case StringLib.DUMP:
                    return StringLib.dump(L);
                case StringLib.FIND:
                    return StringLib.find(L);
                case StringLib.FORMAT:
                    return StringLib.format(L);
                case StringLib.GMATCH:
                    return StringLib.gmatch(L);
                case StringLib.GSUB:
                    return StringLib.gsub(L);
                case StringLib.LEN:
                    return StringLib.len(L);
                case StringLib.LOWER:
                    return StringLib.lower(L);
                case StringLib.MATCH:
                    return StringLib.match(L);
                case StringLib.REP:
                    return StringLib.rep(L);
                case StringLib.REVERSE:
                    return StringLib.reverse(L);
                case StringLib.SUB:
                    return StringLib.sub(L);
                case StringLib.UPPER:
                    return StringLib.upper(L);
                case StringLib.GMATCH_AUX:
                    return StringLib.gmatchaux(L);
            }
            return 0;
        }
        /**
         * Opens the string library into the given Lua state.  This registers
         * the symbols of the string library in a newly created table called
         * "string".
         * @param L  The Lua state into which to open.
         */
        static open(L) {
            var lib = L.__register("string");
            StringLib.r(L, "byte", StringLib.BYTE);
            StringLib.r(L, "char", StringLib.CHAR);
            StringLib.r(L, "dump", StringLib.DUMP);
            StringLib.r(L, "find", StringLib.FIND);
            StringLib.r(L, "format", StringLib.FORMAT);
            StringLib.r(L, "gfind", StringLib.GFIND);
            StringLib.r(L, "gmatch", StringLib.GMATCH);
            StringLib.r(L, "gsub", StringLib.GSUB);
            StringLib.r(L, "len", StringLib.LEN);
            StringLib.r(L, "lower", StringLib.LOWER);
            StringLib.r(L, "match", StringLib.MATCH);
            StringLib.r(L, "rep", StringLib.REP);
            StringLib.r(L, "reverse", StringLib.REVERSE);
            StringLib.r(L, "sub", StringLib.SUB);
            StringLib.r(L, "upper", StringLib.UPPER);
            var mt = new LuaTable_1.LuaTable();
            L.setMetatable("", mt); // set string metatable
            L.setField(mt, "__index", lib);
        }
        /** Register a function. */
        static r(L, name, which) {
            var f = new StringLib(which);
            var lib = L.getGlobal("string");
            L.setField(lib, name, f);
        }
        /** Implements string.byte.  Name mangled to avoid keyword. */
        static byteFunction(L) {
            var s = L.checkString(1);
            var posi = StringLib.posrelat(L.optInt(2, 1), s);
            var pose = StringLib.posrelat(L.optInt(3, posi), s);
            if (posi <= 0) {
                posi = 1;
            }
            if (pose > s.length) {
                pose = s.length;
            }
            if (posi > pose) {
                return 0; // empty interval; return no values
            }
            var n = pose - posi + 1;
            for (var i = 0; i < n; ++i) {
                L.pushNumber(s.charCodeAt(posi + i - 1));
            }
            return n;
        }
        /** Implements string.char.  Name mangled to avoid keyword. */
        static charFunction(L) {
            var n = L.getTop(); // number of arguments
            var b = new StringBuffer_1.StringBuffer();
            for (var i = 1; i <= n; ++i) {
                var c = L.checkInt(i);
                L.argCheck(c == c, i, "invalid value");
                b.append(c);
            }
            L.pushString(b.toString());
            return 1;
        }
        /** Implements string.dump. */
        static dump(L) {
            L.checkType(1, Lua_1.Lua.TFUNCTION);
            L.setTop(1);
            try {
                var s = new ByteArrayOutputStream_1.ByteArrayOutputStream();
                Lua_1.Lua.dump(L.value(1), s);
                var a = s.toByteArray();
                s = null;
                var b = new StringBuffer_1.StringBuffer();
                for (var i = 0; i < a.length; ++i) {
                    b.append((a.get(i) & 0xff));
                }
                L.pushString(b.toString());
                return 1;
            }
            catch (e_) {
                if (e_ instanceof Error) {
                    console.log(e_.stack);
                }
                L.error("unabe to dump given function");
            }
            // NOTREACHED
            return 0;
        }
        /** Helper for find and match.  Equivalent to str_find_aux. */
        static findAux(L, isFind) {
            var s = L.checkString(1);
            var p = L.checkString(2);
            var l1 = s.length;
            var l2 = p.length;
            var init = StringLib.posrelat(L.optInt(3, 1), s) - 1;
            if (init < 0) {
                init = 0;
            }
            else if (init > l1) {
                init = l1;
            }
            if (isFind && (L.toBoolean(L.value(4)) || // explicit request
                StringLib.strpbrk(p, MatchState_1.MatchState.SPECIALS) < 0)) // or no special characters?
             { // do a plain search
                var off = StringLib.lmemfind(s.substring(init), l1 - init, p, l2);
                if (off >= 0) {
                    L.pushNumber(init + off + 1);
                    L.pushNumber(init + off + l2);
                    return 2;
                }
            }
            else {
                var ms = new MatchState_1.MatchState(L, s, l1);
                var anchor = p.charAt(0) == '^';
                var si = init;
                do {
                    ms.level = 0;
                    var res = ms.match(si, p, anchor ? 1 : 0);
                    if (res >= 0) {
                        if (isFind) {
                            L.pushNumber(si + 1); // start
                            L.pushNumber(res); // end
                            return ms.push_captures(-1, -1) + 2;
                        } // else
                        return ms.push_captures(si, res);
                    }
                } while (si++ < ms.end && !anchor);
            }
            L.pushNil(); // not found
            return 1;
        }
        /** Implements string.find. */
        static find(L) {
            return StringLib.findAux(L, true);
        }
        /** Implement string.match.  Operates slightly differently from the
         * PUC-Rio code because instead of storing the iteration state as
         * upvalues of the C closure the iteration state is stored in an
         * Object[3] and kept on the stack.
         */
        static gmatch(L) {
            var state = new Array(3); //Object[]
            state[0] = L.checkString(1);
            state[1] = L.checkString(2);
            state[2] = 0;
            L.pushObject(StringLib.GMATCH_AUX_FUN);
            L.pushObject(state);
            return 2;
        }
        /**
         * Expects the iteration state, an Object[3] (see {@link
         * #gmatch}), to be first on the stack.
         */
        static gmatchaux(L) {
            var state = L.value(1); //Object[] 
            var s = state[0];
            var p = state[1];
            var i = state[2];
            var ms = new MatchState_1.MatchState(L, s, s.length);
            for (; i <= ms.end; ++i) {
                ms.level = 0;
                var e = ms.match(i, p, 0);
                if (e >= 0) {
                    var newstart = e;
                    if (e == i) // empty match?
                        ++newstart; // go at least one position
                    state[2] = parseInt(newstart.toFixed(0));
                    return ms.push_captures(i, e);
                }
            }
            return 0; // not found.
        }
        /** Implements string.gsub. */
        static gsub(L) {
            var s = L.checkString(1);
            var sl = s.length;
            var p = L.checkString(2);
            var maxn = L.optInt(4, sl + 1);
            var anchor = false;
            if (p.length > 0) {
                anchor = p.charAt(0) == '^';
            }
            if (anchor)
                p = p.substring(1);
            var ms = new MatchState_1.MatchState(L, s, sl);
            var b = new StringBuffer_1.StringBuffer();
            var n = 0;
            var si = 0;
            while (n < maxn) {
                ms.level = 0;
                var e = ms.match(si, p, 0);
                if (e >= 0) {
                    ++n;
                    ms.addvalue(b, si, e);
                }
                if (e >= 0 && e > si) // non empty match?
                    si = e; // skip it
                else if (si < ms.end)
                    b.append(s.charCodeAt(si++));
                else
                    break;
                if (anchor)
                    break;
            }
            b.appendString(s.substring(si));
            L.pushString(b.toString());
            L.pushNumber(n); // number of substitutions
            return 2;
        }
        static addquoted(L, b, arg) {
            var s = L.checkString(arg);
            var l = s.length;
            b.append('"'.charCodeAt(0));
            for (var i = 0; i < l; ++i) {
                switch (s.charAt(i)) {
                    case '"':
                    case '\\':
                    case '\n':
                        b.append('\\'.charCodeAt(0));
                        b.append(s.charCodeAt(i));
                        break;
                    case '\r':
                        b.appendString("\\r");
                        break;
                    case '\0':
                        b.appendString("\\u0000" /*"\\000"*/);
                        break;
                    default:
                        b.append(s.charCodeAt(i));
                        break;
                }
            }
            b.append('"'.charCodeAt(0));
        }
        static format(L) {
            var arg = 1;
            var strfrmt = L.checkString(1);
            var sfl = strfrmt.length;
            var b = new StringBuffer_1.StringBuffer();
            var i = 0;
            while (i < sfl) {
                if (strfrmt.charCodeAt(i) != MatchState_1.MatchState.L_ESC) {
                    b.append(strfrmt.charCodeAt(i++));
                }
                else if (strfrmt.charCodeAt(++i) == MatchState_1.MatchState.L_ESC) {
                    b.append(strfrmt.charCodeAt(i++));
                }
                else // format item
                 {
                    ++arg;
                    var item = new FormatItem_1.FormatItem(L, strfrmt.substring(i));
                    i += item.length;
                    switch (String.fromCharCode(item.type)) {
                        case 'c':
                            item.formatChar(b, L.checkNumber(arg));
                            break;
                        case 'd':
                        case 'i':
                        case 'o':
                        case 'u':
                        case 'x':
                        case 'X':
                            // :todo: should be unsigned conversions cope better with
                            // negative number?
                            item.formatInteger(b, L.checkNumber(arg));
                            break;
                        case 'e':
                        case 'E':
                        case 'f':
                        case 'g':
                        case 'G':
                            item.formatFloat(b, L.checkNumber(arg));
                            break;
                        case 'q':
                            StringLib.addquoted(L, b, arg);
                            break;
                        case 's':
                            item.formatString(b, L.checkString(arg));
                            break;
                        default:
                            return L.error("invalid option to 'format'");
                    }
                }
            }
            L.pushString(b.toString());
            return 1;
        }
        /** Implements string.len. */
        static len(L) {
            var s = L.checkString(1);
            L.pushNumber(s.length);
            return 1;
        }
        /** Implements string.lower. */
        static lower(L) {
            var s = L.checkString(1);
            L.pushString(s.toLowerCase());
            return 1;
        }
        /** Implements string.match. */
        static match(L) {
            return StringLib.findAux(L, false);
        }
        /** Implements string.rep. */
        static rep(L) {
            var s = L.checkString(1);
            var n = L.checkInt(2);
            var b = new StringBuffer_1.StringBuffer();
            for (var i = 0; i < n; ++i) {
                b.appendString(s);
            }
            L.pushString(b.toString());
            return 1;
        }
        /** Implements string.reverse. */
        static reverse(L) {
            var s = L.checkString(1);
            var b = new StringBuffer_1.StringBuffer();
            var l = s.length;
            while (--l >= 0) {
                b.append(s.charCodeAt(l));
            }
            L.pushString(b.toString());
            return 1;
        }
        /** Helper for {@link #sub} and friends. */
        static posrelat(pos, s) {
            if (pos >= 0) {
                return pos;
            }
            var len = s.length;
            return len + pos + 1;
        }
        /** Implements string.sub. */
        static sub(L) {
            var s = L.checkString(1);
            var start = StringLib.posrelat(L.checkInt(2), s);
            var end = StringLib.posrelat(L.optInt(3, -1), s);
            if (start < 1) {
                start = 1;
            }
            if (end > s.length) {
                end = s.length;
            }
            if (start <= end) {
                L.pushString(s.substring(start - 1, end));
            }
            else {
                L.pushLiteral("");
            }
            return 1;
        }
        /** Implements string.upper. */
        static upper(L) {
            var s = L.checkString(1);
            L.pushString(s.toUpperCase());
            return 1;
        }
        /**
         * @return  character index of start of match (-1 if no match).
         */
        static lmemfind(s1, l1, s2, l2) {
            if (l2 == 0) {
                return 0; // empty strings are everywhere
            }
            else if (l2 > l1) {
                return -1; // avoids a negative l1
            }
            return s1.indexOf(s2);
        }
        /**
         * Just like C's strpbrk.
         * @return an index into <var>s</var> or -1 for no match.
         */
        static strpbrk(s, _set) {
            var l = _set.length;
            for (var i = 0; i < l; ++i) {
                var idx = s.indexOf(_set.charAt(i));
                if (idx >= 0)
                    return idx;
            }
            return -1;
        }
    }
    exports.StringLib = StringLib;
    // Each function in the string library corresponds to an instance of
    // this class which is associated (the 'which' member) with an integer
    // which is unique within this class.  They are taken from the following
    // set.
    StringLib.BYTE = 1;
    StringLib.CHAR = 2;
    StringLib.DUMP = 3;
    StringLib.FIND = 4;
    StringLib.FORMAT = 5;
    StringLib.GFIND = 6;
    StringLib.GMATCH = 7;
    StringLib.GSUB = 8;
    StringLib.LEN = 9;
    StringLib.LOWER = 10;
    StringLib.MATCH = 11;
    StringLib.REP = 12;
    StringLib.REVERSE = 13;
    StringLib.SUB = 14;
    StringLib.UPPER = 15;
    StringLib.GMATCH_AUX = 16;
    StringLib.GMATCH_AUX_FUN = new StringLib(StringLib.GMATCH_AUX);
});

},{"../java/ByteArrayOutputStream":3,"../java/StringBuffer":26,"./FormatItem":39,"./Lua":45,"./LuaJavaCallback":49,"./LuaTable":50,"./MatchState":52}],59:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/Reader"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringReader = void 0;
    const Reader_1 = require("../java/Reader");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/StringReader.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /** Ersatz replacement for {@link java.io.StringReader} from JSE. */
    class StringReader extends Reader_1.Reader {
        constructor(s) {
            super();
            /** Index of the current read position.  -1 if closed. */
            this._current = 0; // = 0
            /**
             * Index of the current mark (set with {@link #mark}).
             */
            this._mark = 0; // = 0;
            this._s = s;
        }
        close() {
            this._current = -1;
        }
        mark(limit) {
            this._mark = this._current;
        }
        markSupported() {
            return true;
        }
        read() {
            if (this._current < 0) {
                throw new Error("StringReader read error");
            }
            if (this._current >= this._s.length) {
                return -1;
            }
            return this._s.charCodeAt(this._current++);
        }
        readMultiBytes(cbuf, off, len) {
            if (this._current < 0 || len < 0) {
                throw new Error();
            }
            if (this._current >= this._s.length) {
                return 0;
            }
            if (this._current + len > this._s.length) {
                len = this._s.length - this._current;
            }
            for (var i = 0; i < len; ++i) {
                cbuf[off + i] = this._s.charCodeAt(this._current + i);
            }
            this._current += len;
            return len;
        }
        reset() {
            this._current = this._mark;
        }
    }
    exports.StringReader = StringReader;
});

},{"../java/Reader":22}],60:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../java/Character", "../java/Hashtable", "../java/NumberFormatException", "../java/StringBuffer", "./BlockCnt", "./ConsControl", "./Expdesc", "./FuncState", "./LHSAssign", "./Lua", "./Proto"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Syntax = void 0;
    const Character_1 = require("../java/Character");
    const Hashtable_1 = require("../java/Hashtable");
    const NumberFormatException_1 = require("../java/NumberFormatException");
    const StringBuffer_1 = require("../java/StringBuffer");
    const BlockCnt_1 = require("./BlockCnt");
    const ConsControl_1 = require("./ConsControl");
    const Expdesc_1 = require("./Expdesc");
    const FuncState_1 = require("./FuncState");
    const LHSAssign_1 = require("./LHSAssign");
    const Lua_1 = require("./Lua");
    const Proto_1 = require("./Proto");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/Syntax.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Syntax analyser.  Lexing, parsing, code generation.
     */
    class Syntax {
        constructor(L, z, source) {
            // From struct LexState
            /** current character */
            this._current = 0;
            /** input line counter */
            this._linenumber = 1;
            /** line of last token 'consumed' */
            this._lastline = 1;
            /**
            * The token value.  For "punctuation" tokens this is the ASCII value
            * for the character for the token; for other tokens a member of the
            * enum (all of which are > 255).
            */
            this._token = 0;
            /** Semantic info for token; a number. */
            this._tokenR = 0;
            /** Semantic info for token; a string. */
            this._tokenS = null;
            /** Lookahead token value. */
            this._lookahead = Syntax.TK_EOS;
            /** Semantic info for lookahead; a number. */
            this._lookaheadR = 0;
            /** Semantic info for lookahead; a string. */
            this._lookaheadS = null;
            /** Semantic info for return value from {@link #llex}; a number. */
            this._semR = 0;
            /** As {@link #semR}, for string. */
            this._semS = null;
            /** FuncState for current (innermost) function being parsed. */
            this._fs = null;
            /** Buffer for tokens. */
            this._buff = new StringBuffer_1.StringBuffer();
            /** locale decimal point. */
            //TODO:这个变量貌似没有使用
            this._decpoint = '.'.charCodeAt(0);
            Syntax.init();
            this._L = L;
            this._z = z;
            this._source = source;
            this.next();
        }
        //TODO:实现静态初始化
        static init() {
            if (Syntax._reserved == null) {
                Syntax._reserved = new Hashtable_1.Hashtable();
                for (var i = 0; i < Syntax.NUM_RESERVED; ++i) {
                    //TODO:
                    Syntax._reserved.put(Syntax._tokens[i], new Number(Syntax.FIRST_RESERVED + i));
                }
            }
        }
        get lastline() {
            return this._lastline;
        }
        // From <ctype.h>
        // Implementations of functions from <ctype.h> are only correct copies
        // to the extent that Lua requires them.
        // Generally they have default access so that StringLib can see them.
        // Unlike C's these version are not locale dependent, they use the
        // ISO-Latin-1 definitions from CLDC 1.1 Character class.
        static isalnum(c) {
            var ch = c;
            return Character_1.Character.isUpperCase(ch) ||
                Character_1.Character.isLowerCase(ch) ||
                Character_1.Character.isDigit(ch);
        }
        static isalpha(c) {
            var ch = c;
            return Character_1.Character.isUpperCase(ch) ||
                Character_1.Character.isLowerCase(ch);
        }
        /** True if and only if the char (when converted from the int) is a
         * control character.
         */
        static iscntrl(c) {
            return c < 0x20 || c == 0x7f;
        }
        static isdigit(c) {
            return Character_1.Character.isDigit(c);
        }
        static islower(c) {
            return Character_1.Character.isLowerCase(c);
        }
        /**
         * A character is punctuation if not cntrl, not alnum, and not space.
         */
        static ispunct(c) {
            return !Syntax.isalnum(c) && !Syntax.iscntrl(c) && !Syntax.isspace(c);
        }
        static isspace(c) {
            return c == ' '.charCodeAt(0) ||
                c == '\f'.charCodeAt(0) ||
                c == '\n'.charCodeAt(0) ||
                c == '\r'.charCodeAt(0) ||
                c == '\t'.charCodeAt(0);
        }
        static isupper(c) {
            return Character_1.Character.isUpperCase(c);
        }
        static isxdigit(c) {
            return Character_1.Character.isDigit(c) ||
                ('a'.charCodeAt(0) <= c && c <= 'f'.charCodeAt(0)) ||
                ('A'.charCodeAt(0) <= c && c <= 'F'.charCodeAt(0));
        }
        // From llex.c
        check_next(_set) {
            if (_set.indexOf(String.fromCharCode(this._current)) < 0) {
                return false;
            }
            this.save_and_next();
            return true;
        }
        currIsNewline() {
            return this._current == '\n'.charCodeAt(0) ||
                this._current == '\r'.charCodeAt(0);
        }
        inclinenumber() {
            var old = this._current;
            //# assert currIsNewline()
            this.next(); // skip '\n' or '\r'
            if (this.currIsNewline() && this._current != old) {
                this.next(); // skip '\n\r' or '\r\n'
            }
            if (++this._linenumber < 0) // overflow
             {
                this.xSyntaxerror("chunk has too many lines");
            }
        }
        skip_sep() {
            var count = 0;
            var s = this._current;
            //# assert s == '[' || s == ']'
            this.save_and_next();
            while (this._current == '='.charCodeAt(0)) {
                this.save_and_next();
                count++;
            }
            return (this._current == s) ? count : (-count) - 1;
        }
        read_long_string(isString, sep) {
            var cont = 0;
            this.save_and_next(); /* skip 2nd `[' */
            if (this.currIsNewline()) /* string starts with a newline? */
                this.inclinenumber(); /* skip it */
            loop: while (true) {
                switch (String.fromCharCode(this._current)) {
                    case String.fromCharCode(Syntax.EOZ): //TODO:
                        this.xLexerror(isString ? "unfinished long string" :
                            "unfinished long comment", Syntax.TK_EOS);
                        break; /* to avoid warnings */
                    case ']':
                        if (this.skip_sep() == sep) {
                            this.save_and_next(); /* skip 2nd `]' */
                            break loop;
                        }
                        break;
                    case '\n':
                    case '\r':
                        this.__save('\n'.charCodeAt(0));
                        this.inclinenumber();
                        if (!isString)
                            this._buff.setLength(0); /* avoid wasting space */
                        break;
                    default:
                        if (isString)
                            this.save_and_next();
                        else
                            this.next();
                }
            } /* loop */
            if (isString) {
                var rawtoken = this._buff.toString();
                var trim_by = 2 + sep;
                this._semS = rawtoken.substring(trim_by, rawtoken.length - trim_by);
            }
        }
        /** Lex a token and return it.  The semantic info for the token is
         * stored in <code>this.semR</code> or <code>this.semS</code> as
         * appropriate.
         */
        llex() {
            if (Lua_1.Lua.D) {
                console.log("llex() enter, current:" + this._current);
            }
            this._buff.setLength(0);
            while (true) {
                switch (String.fromCharCode(this._current)) {
                    case '\n':
                    case '\r':
                        if (Lua_1.Lua.D) {
                            console.log("case \\n\\r");
                        }
                        this.inclinenumber();
                        continue;
                    case '-':
                        if (Lua_1.Lua.D) {
                            console.log("case -");
                        }
                        this.next();
                        if (this._current != '-'.charCodeAt(0))
                            return '-'.charCodeAt(0);
                        /* else is a comment */
                        this.next();
                        if (this._current == '['.charCodeAt(0)) {
                            var sep2 = this.skip_sep();
                            this._buff.setLength(0); /* `skip_sep' may dirty the buffer */
                            if (sep2 >= 0) {
                                this.read_long_string(false, sep2); /* long comment */
                                this._buff.setLength(0);
                                continue;
                            }
                        }
                        /* else short comment */
                        while (!this.currIsNewline() && this._current != Syntax.EOZ)
                            this.next();
                        continue;
                    case '[':
                        if (Lua_1.Lua.D) {
                            console.log("case [");
                        }
                        var sep = this.skip_sep();
                        if (sep >= 0) {
                            this.read_long_string(true, sep);
                            return Syntax.TK_STRING;
                        }
                        else if (sep == -1)
                            return '['.charCodeAt(0);
                        else
                            this.xLexerror("invalid long string delimiter", Syntax.TK_STRING);
                        continue; // avoids Checkstyle warning.
                    case '=':
                        if (Lua_1.Lua.D) {
                            console.log("case =");
                        }
                        this.next();
                        if (this._current != '='.charCodeAt(0)) {
                            return '='.charCodeAt(0);
                        }
                        else {
                            this.next();
                            return Syntax.TK_EQ;
                        }
                    case '<':
                        if (Lua_1.Lua.D) {
                            console.log("case <");
                        }
                        this.next();
                        if (this._current != '='.charCodeAt(0)) {
                            return '<'.charCodeAt(0);
                        }
                        else {
                            this.next();
                            return Syntax.TK_LE;
                        }
                    case '>':
                        if (Lua_1.Lua.D) {
                            console.log("case >");
                        }
                        this.next();
                        if (this._current != '='.charCodeAt(0)) {
                            return '>'.charCodeAt(0);
                        }
                        else {
                            this.next();
                            return Syntax.TK_GE;
                        }
                    case '~':
                        if (Lua_1.Lua.D) {
                            console.log("case ~");
                        }
                        this.next();
                        if (this._current != '='.charCodeAt(0)) {
                            return '~'.charCodeAt(0);
                        }
                        else {
                            this.next();
                            return Syntax.TK_NE;
                        }
                    case '"':
                    case '\'':
                        if (Lua_1.Lua.D) {
                            console.log("case \"'");
                        }
                        this.read_string(this._current);
                        return Syntax.TK_STRING;
                    case '.':
                        if (Lua_1.Lua.D) {
                            console.log("case .");
                        }
                        this.save_and_next();
                        if (this.check_next(".")) {
                            if (this.check_next(".")) {
                                return Syntax.TK_DOTS;
                            }
                            else {
                                return Syntax.TK_CONCAT;
                            }
                        }
                        else if (!Syntax.isdigit(this._current)) {
                            return '.'.charCodeAt(0);
                        }
                        else {
                            this.read_numeral();
                            return Syntax.TK_NUMBER;
                        }
                    case String.fromCharCode(Syntax.EOZ): //TODO:
                        if (Lua_1.Lua.D) {
                            console.log("case EOZ");
                        }
                        return Syntax.TK_EOS;
                    default:
                        if (Syntax.isspace(this._current)) {
                            if (Lua_1.Lua.D) {
                                console.log("isspace");
                            }
                            // assert !currIsNewline();
                            this.next();
                            continue;
                        }
                        else if (Syntax.isdigit(this._current)) {
                            if (Lua_1.Lua.D) {
                                console.log("isdigit");
                            }
                            this.read_numeral();
                            return Syntax.TK_NUMBER;
                        }
                        else if (Syntax.isalpha(this._current) || this._current == '_'.charCodeAt(0)) {
                            if (Lua_1.Lua.D) {
                                console.log("isalpha or _");
                            }
                            // identifier or reserved word
                            do {
                                this.save_and_next();
                            } while (Syntax.isalnum(this._current) || this._current == '_'.charCodeAt(0));
                            var s = this._buff.toString();
                            var t = Syntax._reserved._get(s); //TODO:
                            if (t == null) {
                                this._semS = s;
                                return Syntax.TK_NAME;
                            }
                            else {
                                return t;
                            }
                        }
                        else {
                            var c = this._current;
                            this.next();
                            return c; // single-char tokens
                        }
                }
            }
            //unreachable
            return 0;
        }
        next() {
            this._current = this._z.read();
            if (Lua_1.Lua.D) {
                console.log("Syntax.next(), current:" + this._current + "(" + String.fromCharCode(this._current) + ")");
            }
        }
        /** Reads number.  Writes to semR. */
        read_numeral() {
            // assert isdigit(current);
            do {
                this.save_and_next();
            } while (Syntax.isdigit(this._current) || this._current == '.'.charCodeAt(0));
            if (this.check_next("Ee")) // 'E' ?
             {
                this.check_next("+-"); // optional exponent sign
            }
            while (Syntax.isalnum(this._current) || this._current == '_'.charCodeAt(0)) {
                this.save_and_next();
            }
            // :todo: consider doing PUC-Rio's decimal point tricks.
            try {
                this._semR = Number(this._buff.toString());
                return;
            }
            catch (e) {
                if (e instanceof NumberFormatException_1.NumberFormatException) {
                    console.log(e.stack);
                }
                this.xLexerror("malformed number", Syntax.TK_NUMBER);
            }
        }
        /** Reads string.  Writes to semS. */
        read_string(del) {
            this.save_and_next();
            while (this._current != del) {
                switch (String.fromCharCode(this._current)) {
                    case String.fromCharCode(Syntax.EOZ): //TODO:
                        this.xLexerror("unfinished string", Syntax.TK_EOS);
                        continue; // avoid compiler warning
                    case '\n':
                    case '\r':
                        this.xLexerror("unfinished string", Syntax.TK_STRING);
                        continue; // avoid compiler warning
                    case '\\':
                        {
                            var c;
                            this.next(); // do not save the '\'
                            switch (String.fromCharCode(this._current)) {
                                case 'a':
                                    c = 7;
                                    break; // no '\a' in Java.
                                case 'b':
                                    c = '\b'.charCodeAt(0);
                                    break;
                                case 'f':
                                    c = '\f'.charCodeAt(0);
                                    break;
                                case 'n':
                                    c = '\n'.charCodeAt(0);
                                    break;
                                case 'r':
                                    c = '\r'.charCodeAt(0);
                                    break;
                                case 't':
                                    c = '\t'.charCodeAt(0);
                                    break;
                                case 'v':
                                    c = 11;
                                    break; // no '\v' in Java.
                                case '\n':
                                case '\r':
                                    this.__save('\n'.charCodeAt(0));
                                    this.inclinenumber();
                                    continue;
                                case String.fromCharCode(Syntax.EOZ):
                                    continue; // will raise an error next loop
                                default:
                                    if (!Syntax.isdigit(this._current)) {
                                        this.save_and_next(); // handles \\, \", \', \?
                                    }
                                    else // \xxx
                                     {
                                        var i = 0;
                                        c = 0;
                                        do {
                                            c = 10 * c + (this._current - '0'.charCodeAt(0));
                                            this.next();
                                        } while (++i < 3 && Syntax.isdigit(this._current));
                                        // In unicode, there are no bounds on a 3-digit decimal.
                                        this.__save(c);
                                    }
                                    continue;
                            }
                            this.__save(c);
                            this.next();
                            continue;
                        }
                    default:
                        this.save_and_next();
                }
            }
            this.save_and_next(); // skip delimiter
            var rawtoken = this._buff.toString();
            this._semS = rawtoken.substring(1, rawtoken.length - 1);
        }
        save() {
            this._buff.append(this._current);
        }
        __save(c) {
            this._buff.append(c);
        }
        save_and_next() {
            this.save();
            this.next();
        }
        /** Getter for source. */
        get source() {
            return this._source;
        }
        txtToken(tok) {
            switch (tok) {
                case Syntax.TK_NAME:
                case Syntax.TK_STRING:
                case Syntax.TK_NUMBER:
                    return this._buff.toString();
                default:
                    return Syntax.xToken2str(tok);
            }
        }
        /** Equivalent to <code>luaX_lexerror</code>. */
        xLexerror(msg, tok) {
            msg = this.source + ":" + this._linenumber + ": " + msg;
            if (tok != 0) {
                msg = msg + " near '" + this.txtToken(tok) + "'";
            }
            this._L.pushString(msg);
            this._L.dThrow(Lua_1.Lua.ERRSYNTAX);
        }
        /** Equivalent to <code>luaX_next</code>. */
        xNext() {
            this._lastline = this._linenumber;
            if (this._lookahead != Syntax.TK_EOS) // is there a look-ahead token?
             {
                this._token = this._lookahead; // Use this one,
                this._tokenR = this._lookaheadR;
                this._tokenS = this._lookaheadS;
                this._lookahead = Syntax.TK_EOS; // and discharge it.
            }
            else {
                this._token = this.llex();
                this._tokenR = this._semR;
                this._tokenS = this._semS;
            }
        }
        /** Equivalent to <code>luaX_syntaxerror</code>. */
        xSyntaxerror(msg) {
            this.xLexerror(msg, this._token);
        }
        static xToken2str(token) {
            if (token < Syntax.FIRST_RESERVED) {
                // assert token == (char)token;
                if (Syntax.iscntrl(token)) {
                    return "char(" + token + ")";
                }
                return String.fromCharCode(token);
            }
            return Syntax._tokens[token - Syntax.FIRST_RESERVED];
        }
        // From lparser.c
        static block_follow(token) {
            switch (token) {
                case Syntax.TK_ELSE:
                case Syntax.TK_ELSEIF:
                case Syntax.TK_END:
                case Syntax.TK_UNTIL:
                case Syntax.TK_EOS:
                    return true;
                default:
                    return false;
            }
        }
        check(c) {
            if (this._token != c) {
                this.error_expected(c);
            }
        }
        /**
         * @param what   the token that is intended to end the match.
         * @param who    the token that begins the match.
         * @param where  the line number of <var>what</var>.
         */
        check_match(what, who, where) {
            if (!this.testnext(what)) {
                if (where == this._linenumber) {
                    this.error_expected(what);
                }
                else {
                    this.xSyntaxerror("'" + Syntax.xToken2str(what) + "' expected (to close '" +
                        Syntax.xToken2str(who) + "' at line " + where + ")");
                }
            }
        }
        close_func() {
            this.removevars(0);
            this._fs.kRet(0, 0); // final return;
            this._fs.close();
            // :todo: check this is a valid assertion to make
            //# assert fs != fs.prev
            this._fs = this._fs.prev;
        }
        static opcode_name(op) {
            switch (op) {
                case Lua_1.Lua.OP_MOVE:
                    return "MOVE";
                case Lua_1.Lua.OP_LOADK:
                    return "LOADK";
                case Lua_1.Lua.OP_LOADBOOL:
                    return "LOADBOOL";
                case Lua_1.Lua.OP_LOADNIL:
                    return "LOADNIL";
                case Lua_1.Lua.OP_GETUPVAL:
                    return "GETUPVAL";
                case Lua_1.Lua.OP_GETGLOBAL:
                    return "GETGLOBAL";
                case Lua_1.Lua.OP_GETTABLE:
                    return "GETTABLE";
                case Lua_1.Lua.OP_SETGLOBAL:
                    return "SETGLOBAL";
                case Lua_1.Lua.OP_SETUPVAL:
                    return "SETUPVAL";
                case Lua_1.Lua.OP_SETTABLE:
                    return "SETTABLE";
                case Lua_1.Lua.OP_NEWTABLE:
                    return "NEWTABLE";
                case Lua_1.Lua.OP_SELF:
                    return "SELF";
                case Lua_1.Lua.OP_ADD:
                    return "ADD";
                case Lua_1.Lua.OP_SUB:
                    return "SUB";
                case Lua_1.Lua.OP_MUL:
                    return "MUL";
                case Lua_1.Lua.OP_DIV:
                    return "DIV";
                case Lua_1.Lua.OP_MOD:
                    return "MOD";
                case Lua_1.Lua.OP_POW:
                    return "POW";
                case Lua_1.Lua.OP_UNM:
                    return "UNM";
                case Lua_1.Lua.OP_NOT:
                    return "NOT";
                case Lua_1.Lua.OP_LEN:
                    return "LEN";
                case Lua_1.Lua.OP_CONCAT:
                    return "CONCAT";
                case Lua_1.Lua.OP_JMP:
                    return "JMP";
                case Lua_1.Lua.OP_EQ:
                    return "EQ";
                case Lua_1.Lua.OP_LT:
                    return "LT";
                case Lua_1.Lua.OP_LE:
                    return "LE";
                case Lua_1.Lua.OP_TEST:
                    return "TEST";
                case Lua_1.Lua.OP_TESTSET:
                    return "TESTSET";
                case Lua_1.Lua.OP_CALL:
                    return "CALL";
                case Lua_1.Lua.OP_TAILCALL:
                    return "TAILCALL";
                case Lua_1.Lua.OP_RETURN:
                    return "RETURN";
                case Lua_1.Lua.OP_FORLOOP:
                    return "FORLOOP";
                case Lua_1.Lua.OP_FORPREP:
                    return "FORPREP";
                case Lua_1.Lua.OP_TFORLOOP:
                    return "TFORLOOP";
                case Lua_1.Lua.OP_SETLIST:
                    return "SETLIST";
                case Lua_1.Lua.OP_CLOSE:
                    return "CLOSE";
                case Lua_1.Lua.OP_CLOSURE:
                    return "CLOSURE";
                case Lua_1.Lua.OP_VARARG:
                    return "VARARG";
                default:
                    return "??" + op;
            }
        }
        codestring(e, s) {
            e.init(Expdesc_1.Expdesc.VK, this._fs.kStringK(s));
        }
        checkname(e) {
            this.codestring(e, this.str_checkname());
        }
        enterlevel() {
            this._L.nCcalls++;
        }
        error_expected(tok) {
            this.xSyntaxerror("'" + Syntax.xToken2str(tok) + "' expected");
        }
        leavelevel() {
            this._L.nCcalls--;
        }
        /** Equivalent to luaY_parser. */
        static parser(L, _in, name) {
            var ls = new Syntax(L, _in, name);
            var fs = new FuncState_1.FuncState(ls);
            ls.open_func(fs);
            fs.f.isVararg = true;
            ls.xNext();
            ls.chunk();
            ls.check(Syntax.TK_EOS);
            ls.close_func();
            //# assert fs.prev == null
            //# assert fs.f.nups == 0
            //# assert ls.fs == null
            return fs.f;
        }
        removevars(tolevel) {
            // :todo: consider making a method in FuncState.
            while (this._fs.nactvar > tolevel) {
                this._fs.getlocvar(--this._fs.nactvar).endpc = this._fs.pc;
            }
        }
        singlevar(_var) {
            var varname = this.str_checkname();
            if (this.singlevaraux(this._fs, varname, _var, true) == Expdesc_1.Expdesc.VGLOBAL) {
                _var.info = this._fs.kStringK(varname);
            }
        }
        singlevaraux(f, n, _var, base) {
            if (f == null) // no more levels?
             {
                _var.init(Expdesc_1.Expdesc.VGLOBAL, Lua_1.Lua.NO_REG); // default is global variable
                return Expdesc_1.Expdesc.VGLOBAL;
            }
            else {
                var v = f.searchvar(n);
                if (v >= 0) {
                    _var.init(Expdesc_1.Expdesc.VLOCAL, v);
                    if (!base) {
                        f.markupval(v); // local will be used as an upval
                    }
                    return Expdesc_1.Expdesc.VLOCAL;
                }
                else // not found at current level; try upper one
                 {
                    if (this.singlevaraux(f.prev, n, _var, false) == Expdesc_1.Expdesc.VGLOBAL) {
                        return Expdesc_1.Expdesc.VGLOBAL;
                    }
                    _var.upval(this.indexupvalue(f, n, _var)); // else was LOCAL or UPVAL
                    return Expdesc_1.Expdesc.VUPVAL;
                }
            }
        }
        str_checkname() {
            this.check(Syntax.TK_NAME);
            var s = this._tokenS;
            this.xNext();
            return s;
        }
        testnext(c) {
            if (this._token == c) {
                this.xNext();
                return true;
            }
            return false;
        }
        // GRAMMAR RULES
        chunk() {
            // chunk -> { stat [';'] }
            var islast = false;
            this.enterlevel();
            while (!islast && !Syntax.block_follow(this._token)) {
                islast = this.statement();
                this.testnext(';'.charCodeAt(0));
                //# assert fs.f.maxstacksize >= fs.freereg && fs.freereg >= fs.nactvar
                this._fs.freereg = this._fs.nactvar;
            }
            this.leavelevel();
        }
        constructor_(t) {
            // constructor -> ??
            var line = this._linenumber;
            var pc = this._fs.kCodeABC(Lua_1.Lua.OP_NEWTABLE, 0, 0, 0);
            var cc = new ConsControl_1.ConsControl(t);
            t.init(Expdesc_1.Expdesc.VRELOCABLE, pc);
            cc.v.init(Expdesc_1.Expdesc.VVOID, 0); /* no value (yet) */
            this._fs.kExp2nextreg(t); /* fix it at stack top (for gc) */
            this.checknext('{'.charCodeAt(0));
            do {
                //# assert cc.v.k == Expdesc.VVOID || cc.tostore > 0
                if (this._token == '}'.charCodeAt(0))
                    break;
                this.closelistfield(cc);
                switch (String.fromCharCode(this._token)) {
                    case String.fromCharCode(Syntax.TK_NAME): /* may be listfields or recfields */
                        this.xLookahead();
                        if (this._lookahead != '='.charCodeAt(0)) /* expression? */
                            this.listfield(cc);
                        else
                            this.recfield(cc);
                        break;
                    case '[': /* constructor_item -> recfield */
                        this.recfield(cc);
                        break;
                    default: /* constructor_part -> listfield */
                        this.listfield(cc);
                        break;
                }
            } while (this.testnext(','.charCodeAt(0)) || this.testnext(';'.charCodeAt(0)));
            this.check_match('}'.charCodeAt(0), '{'.charCodeAt(0), line);
            this.lastlistfield(cc);
            var code = this._fs.f.code; //int [] 
            code[pc] = Lua_1.Lua.SETARG_B(code[pc], Syntax.oInt2fb(cc.na)); /* set initial array size */
            code[pc] = Lua_1.Lua.SETARG_C(code[pc], Syntax.oInt2fb(cc.nh)); /* set initial table size */
        }
        static oInt2fb(x) {
            var e = 0; /* exponent */
            while (x < 0 || x >= 16) {
                x = (x + 1) >>> 1;
                e++;
            }
            return (x < 8) ? x : (((e + 1) << 3) | (x - 8));
        }
        recfield(cc) {
            /* recfield -> (NAME | `['exp1`]') = exp1 */
            var reg = this._fs.freereg;
            var key = new Expdesc_1.Expdesc();
            var val = new Expdesc_1.Expdesc();
            if (this._token == Syntax.TK_NAME) {
                // yChecklimit(fs, cc.nh, MAX_INT, "items in a constructor");
                this.checkname(key);
            }
            else /* token == '[' */
                this.yindex(key);
            cc.nh++;
            this.checknext('='.charCodeAt(0));
            this._fs.kExp2RK(key);
            this.expr(val);
            this._fs.kCodeABC(Lua_1.Lua.OP_SETTABLE, cc.t.info, this._fs.kExp2RK(key), this._fs.kExp2RK(val));
            this._fs.freereg = reg; /* free registers */
        }
        lastlistfield(cc) {
            if (cc.tostore == 0)
                return;
            if (Syntax.hasmultret(cc.v.k)) {
                this._fs.kSetmultret(cc.v);
                this._fs.kSetlist(cc.t.info, cc.na, Lua_1.Lua.MULTRET);
                cc.na--; /* do not count last expression (unknown number of elements) */
            }
            else {
                if (cc.v.k != Expdesc_1.Expdesc.VVOID)
                    this._fs.kExp2nextreg(cc.v);
                this._fs.kSetlist(cc.t.info, cc.na, cc.tostore);
            }
        }
        closelistfield(cc) {
            if (cc.v.k == Expdesc_1.Expdesc.VVOID)
                return; /* there is no list item */
            this._fs.kExp2nextreg(cc.v);
            cc.v.k = Expdesc_1.Expdesc.VVOID;
            if (cc.tostore == Lua_1.Lua.LFIELDS_PER_FLUSH) {
                this._fs.kSetlist(cc.t.info, cc.na, cc.tostore); /* flush */
                cc.tostore = 0; /* no more items pending */
            }
        }
        expr(v) {
            this.subexpr(v, 0);
        }
        /** @return number of expressions in expression list. */
        explist1(v) {
            // explist1 -> expr { ',' expr }
            var n = 1; // at least one expression
            this.expr(v);
            while (this.testnext(','.charCodeAt(0))) {
                this._fs.kExp2nextreg(v);
                this.expr(v);
                ++n;
            }
            return n;
        }
        exprstat() {
            // stat -> func | assignment
            var v = new LHSAssign_1.LHSAssign();
            this.primaryexp(v.v);
            if (v.v.k == Expdesc_1.Expdesc.VCALL) // stat -> func
             {
                this._fs.setargc(v.v, 1); // call statement uses no results
            }
            else // stat -> assignment
             {
                v.prev = null;
                this.assignment(v, 1);
            }
        }
        /*
        ** check whether, in an assignment to a local variable, the local variable
        ** is needed in a previous assignment (to a table). If so, save original
        ** local value in a safe place and use this safe copy in the previous
        ** assignment.
        */
        check_conflict(lh, v) {
            var extra = this._fs.freereg; /* eventual position to save local variable */
            var conflict = false;
            for (; lh != null; lh = lh.prev) {
                if (lh.v.k == Expdesc_1.Expdesc.VINDEXED) {
                    if (lh.v.info == v.info) /* conflict? */ {
                        conflict = true;
                        lh.v.info = extra; /* previous assignment will use safe copy */
                    }
                    if (lh.v.aux == v.info) /* conflict? */ {
                        conflict = true;
                        lh.v.aux = extra; /* previous assignment will use safe copy */
                    }
                }
            }
            if (conflict) {
                this._fs.kCodeABC(Lua_1.Lua.OP_MOVE, this._fs.freereg, v.info, 0); /* make copy */
                this._fs.kReserveregs(1);
            }
        }
        assignment(lh, nvars) {
            var e = new Expdesc_1.Expdesc();
            var kind = lh.v.k;
            if (!(Expdesc_1.Expdesc.VLOCAL <= kind && kind <= Expdesc_1.Expdesc.VINDEXED))
                this.xSyntaxerror("syntax error");
            if (this.testnext(','.charCodeAt(0))) /* assignment -> `,' primaryexp assignment */ {
                var nv = new LHSAssign_1.LHSAssign();
                nv.init(lh); //TODO:
                this.primaryexp(nv.v);
                if (nv.v.k == Expdesc_1.Expdesc.VLOCAL)
                    this.check_conflict(lh, nv.v);
                this.assignment(nv, nvars + 1);
            }
            else /* assignment -> `=' explist1 */ {
                var nexps;
                this.checknext('='.charCodeAt(0));
                nexps = this.explist1(e);
                if (nexps != nvars) {
                    this.adjust_assign(nvars, nexps, e);
                    if (nexps > nvars)
                        this._fs.freereg -= nexps - nvars; /* remove extra values */
                }
                else {
                    this._fs.kSetoneret(e); /* close last expression */
                    this._fs.kStorevar(lh.v, e);
                    return; /* avoid default */
                }
            }
            e.init(Expdesc_1.Expdesc.VNONRELOC, this._fs.freereg - 1); /* default assignment */
            this._fs.kStorevar(lh.v, e);
        }
        funcargs(f) {
            var args = new Expdesc_1.Expdesc();
            var line = this._linenumber;
            switch (String.fromCharCode(this._token)) {
                case '(': // funcargs -> '(' [ explist1 ] ')'
                    if (line != this.lastline) {
                        this.xSyntaxerror("ambiguous syntax (function call x new statement)");
                    }
                    this.xNext();
                    if (this._token == ')'.charCodeAt(0)) // arg list is empty?
                     {
                        args.kind = Expdesc_1.Expdesc.VVOID;
                    }
                    else {
                        this.explist1(args);
                        this._fs.kSetmultret(args);
                    }
                    this.check_match(')'.charCodeAt(0), '('.charCodeAt(0), line);
                    break;
                case '{': // funcargs -> constructor
                    this.constructor_(args);
                    break;
                case String.fromCharCode(Syntax.TK_STRING): // funcargs -> STRING
                    this.codestring(args, this._tokenS);
                    this.xNext(); // must use tokenS before 'next'
                    break;
                default:
                    this.xSyntaxerror("function arguments expected");
                    return;
            }
            // assert (f.kind() == VNONRELOC);
            var nparams;
            var base = f.info; // base register for call
            if (args.hasmultret()) {
                nparams = Lua_1.Lua.MULTRET; // open call
            }
            else {
                if (args.kind != Expdesc_1.Expdesc.VVOID) {
                    this._fs.kExp2nextreg(args); // close last argument
                }
                nparams = this._fs.freereg - (base + 1);
            }
            f.init(Expdesc_1.Expdesc.VCALL, this._fs.kCodeABC(Lua_1.Lua.OP_CALL, base, nparams + 1, 2));
            this._fs.kFixline(line);
            this._fs.freereg = base + 1; // call removes functions and arguments
            // and leaves (unless changed) one result.
        }
        prefixexp(v) {
            // prefixexp -> NAME | '(' expr ')'
            switch (String.fromCharCode(this._token)) {
                case '(':
                    {
                        var line = this._linenumber;
                        this.xNext();
                        this.expr(v);
                        this.check_match(')'.charCodeAt(0), '('.charCodeAt(0), line);
                        this._fs.kDischargevars(v);
                        return;
                    }
                case String.fromCharCode(Syntax.TK_NAME):
                    this.singlevar(v);
                    return;
                default:
                    this.xSyntaxerror("unexpected symbol");
                    return;
            }
        }
        primaryexp(v) {
            // primaryexp ->
            //    prefixexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs }
            this.prefixexp(v);
            while (true) {
                switch (String.fromCharCode(this._token)) {
                    case '.': /* field */
                        this.field(v);
                        break;
                    case '[': /* `[' exp1 `]' */
                        {
                            var key = new Expdesc_1.Expdesc();
                            this._fs.kExp2anyreg(v);
                            this.yindex(key);
                            this._fs.kIndexed(v, key);
                        }
                        break;
                    case ':': /* `:' NAME funcargs */
                        {
                            var key2 = new Expdesc_1.Expdesc();
                            this.xNext();
                            this.checkname(key2);
                            this._fs.kSelf(v, key2);
                            this.funcargs(v);
                        }
                        break;
                    case '(':
                    case String.fromCharCode(Syntax.TK_STRING):
                    case '{': // funcargs
                        this._fs.kExp2nextreg(v);
                        this.funcargs(v);
                        break;
                    default:
                        return;
                }
            }
        }
        retstat() {
            // stat -> RETURN explist
            this.xNext(); // skip RETURN
            // registers with returned values (first, nret)
            var first = 0;
            var nret;
            if (Syntax.block_follow(this._token) || this._token == ';'.charCodeAt(0)) {
                // return no values
                first = 0;
                nret = 0;
            }
            else {
                var e = new Expdesc_1.Expdesc();
                nret = this.explist1(e);
                if (Syntax.hasmultret(e.k)) {
                    this._fs.kSetmultret(e);
                    if (e.k == Expdesc_1.Expdesc.VCALL && nret == 1) /* tail call? */ {
                        this._fs.setcode(e, Lua_1.Lua.SET_OPCODE(this._fs.getcode(e), Lua_1.Lua.OP_TAILCALL));
                        //# assert Lua.ARGA(fs.getcode(e)) == fs.nactvar
                    }
                    first = this._fs.nactvar;
                    nret = Lua_1.Lua.MULTRET; /* return all values */
                }
                else {
                    if (nret == 1) // only one single value?
                     {
                        first = this._fs.kExp2anyreg(e);
                    }
                    else {
                        this._fs.kExp2nextreg(e); /* values must go to the `stack' */
                        first = this._fs.nactvar; /* return all `active' values */
                        //# assert nret == fs.freereg - first
                    }
                }
            }
            this._fs.kRet(first, nret);
        }
        simpleexp(v) {
            // simpleexp -> NUMBER | STRING | NIL | true | false | ... |
            //              constructor | FUNCTION body | primaryexp
            switch (this._token) {
                case Syntax.TK_NUMBER:
                    v.init(Expdesc_1.Expdesc.VKNUM, 0);
                    v.nval = this._tokenR;
                    break;
                case Syntax.TK_STRING:
                    this.codestring(v, this._tokenS);
                    break;
                case Syntax.TK_NIL:
                    v.init(Expdesc_1.Expdesc.VNIL, 0);
                    break;
                case Syntax.TK_TRUE:
                    v.init(Expdesc_1.Expdesc.VTRUE, 0);
                    break;
                case Syntax.TK_FALSE:
                    v.init(Expdesc_1.Expdesc.VFALSE, 0);
                    break;
                case Syntax.TK_DOTS: /* vararg */
                    if (!this._fs.f.isVararg)
                        this.xSyntaxerror("cannot use \"...\" outside a vararg function");
                    v.init(Expdesc_1.Expdesc.VVARARG, this._fs.kCodeABC(Lua_1.Lua.OP_VARARG, 0, 1, 0));
                    break;
                case '{'.charCodeAt(0): /* constructor */
                    this.constructor_(v);
                    return;
                case Syntax.TK_FUNCTION:
                    this.xNext();
                    this.body(v, false, this._linenumber);
                    return;
                default:
                    this.primaryexp(v);
                    return;
            }
            this.xNext();
        }
        statement() {
            var line = this._linenumber;
            switch (this._token) {
                case Syntax.TK_IF: // stat -> ifstat
                    this.ifstat(line);
                    return false;
                case Syntax.TK_WHILE: // stat -> whilestat
                    this.whilestat(line);
                    return false;
                case Syntax.TK_DO: // stat -> DO block END
                    this.xNext(); // skip DO
                    this.block();
                    this.check_match(Syntax.TK_END, Syntax.TK_DO, line);
                    return false;
                case Syntax.TK_FOR: // stat -> forstat
                    this.forstat(line);
                    return false;
                case Syntax.TK_REPEAT: // stat -> repeatstat
                    this.repeatstat(line);
                    return false;
                case Syntax.TK_FUNCTION:
                    this.funcstat(line); // stat -> funcstat
                    return false;
                case Syntax.TK_LOCAL: // stat -> localstat
                    this.xNext(); // skip LOCAL
                    if (this.testnext(Syntax.TK_FUNCTION)) // local function?
                        this.localfunc();
                    else
                        this.localstat();
                    return false;
                case Syntax.TK_RETURN:
                    this.retstat();
                    return true; // must be last statement
                case Syntax.TK_BREAK: // stat -> breakstat
                    this.xNext(); // skip BREAK
                    this.breakstat();
                    return true; // must be last statement
                default:
                    this.exprstat();
                    return false;
            }
        }
        /** Converts token into binary operator.  */
        static getbinopr(op) {
            switch (String.fromCharCode(op)) {
                case '+':
                    return Syntax.OPR_ADD;
                case '-':
                    return Syntax.OPR_SUB;
                case '*':
                    return Syntax.OPR_MUL;
                case '/':
                    return Syntax.OPR_DIV;
                case '%':
                    return Syntax.OPR_MOD;
                case '^':
                    return Syntax.OPR_POW;
                case String.fromCharCode(Syntax.TK_CONCAT):
                    return Syntax.OPR_CONCAT;
                case String.fromCharCode(Syntax.TK_NE):
                    return Syntax.OPR_NE;
                case String.fromCharCode(Syntax.TK_EQ):
                    return Syntax.OPR_EQ;
                case '<':
                    return Syntax.OPR_LT;
                case String.fromCharCode(Syntax.TK_LE):
                    return Syntax.OPR_LE;
                case '>':
                    return Syntax.OPR_GT;
                case String.fromCharCode(Syntax.TK_GE):
                    return Syntax.OPR_GE;
                case String.fromCharCode(Syntax.TK_AND):
                    return Syntax.OPR_AND;
                case String.fromCharCode(Syntax.TK_OR):
                    return Syntax.OPR_OR;
                default:
                    return Syntax.OPR_NOBINOPR;
            }
        }
        static getunopr(op) {
            switch (String.fromCharCode(op)) {
                case String.fromCharCode(Syntax.TK_NOT):
                    return Syntax.OPR_NOT;
                case '-':
                    return Syntax.OPR_MINUS;
                case '#':
                    return Syntax.OPR_LEN;
                default:
                    return Syntax.OPR_NOUNOPR;
            }
        }
        /**
         * Operator precedence parser.
         * <code>subexpr -> (simpleexp) | unop subexpr) { binop subexpr }</code>
         * where <var>binop</var> is any binary operator with a priority
         * higher than <var>limit</var>.
         */
        subexpr(v, limit) {
            this.enterlevel();
            var uop = Syntax.getunopr(this._token);
            if (uop != Syntax.OPR_NOUNOPR) {
                this.xNext();
                this.subexpr(v, Syntax.UNARY_PRIORITY);
                this._fs.kPrefix(uop, v);
            }
            else {
                this.simpleexp(v);
            }
            // expand while operators have priorities higher than 'limit'
            var op = Syntax.getbinopr(this._token);
            while (op != Syntax.OPR_NOBINOPR && Syntax.PRIORITY[op][0] > limit) {
                var v2 = new Expdesc_1.Expdesc();
                this.xNext();
                this._fs.kInfix(op, v);
                // read sub-expression with higher priority
                var nextop = this.subexpr(v2, Syntax.PRIORITY[op][1]);
                this._fs.kPosfix(op, v, v2);
                op = nextop;
            }
            this.leavelevel();
            return op;
        }
        enterblock(f, bl, isbreakable) {
            bl.breaklist = FuncState_1.FuncState.NO_JUMP;
            bl.isbreakable = isbreakable;
            bl.nactvar = f.nactvar;
            bl.upval = false;
            bl.previous = f.bl;
            f.bl = bl;
            //# assert f.freereg == f.nactvar
        }
        leaveblock(f) {
            var bl = f.bl;
            f.bl = bl.previous;
            this.removevars(bl.nactvar);
            if (bl.upval)
                f.kCodeABC(Lua_1.Lua.OP_CLOSE, bl.nactvar, 0, 0);
            /* loops have no body */
            //# assert (!bl.isbreakable) || (!bl.upval)
            //# assert bl.nactvar == f.nactvar
            f.freereg = f.nactvar; /* free registers */
            f.kPatchtohere(bl.breaklist);
        }
        /*
        ** {======================================================================
        ** Rules for Statements
        ** =======================================================================
        */
        block() {
            /* block -> chunk */
            var bl = new BlockCnt_1.BlockCnt();
            this.enterblock(this._fs, bl, false);
            this.chunk();
            //# assert bl.breaklist == FuncState.NO_JUMP
            this.leaveblock(this._fs);
        }
        breakstat() {
            var bl = this._fs.bl;
            var upval = false;
            while (bl != null && !bl.isbreakable) {
                //TODO:||=
                upval || (upval = bl.upval);
                bl = bl.previous;
            }
            if (bl == null)
                this.xSyntaxerror("no loop to break");
            if (upval)
                this._fs.kCodeABC(Lua_1.Lua.OP_CLOSE, bl.nactvar, 0, 0);
            bl.breaklist = this._fs.kConcat(bl.breaklist, this._fs.kJump());
        }
        funcstat(line) {
            /* funcstat -> FUNCTION funcname body */
            var b = new Expdesc_1.Expdesc();
            var v = new Expdesc_1.Expdesc();
            this.xNext(); /* skip FUNCTION */
            var needself = this.funcname(v);
            this.body(b, needself, line);
            this._fs.kStorevar(v, b);
            this._fs.kFixline(line); /* definition `happens' in the first line */
        }
        checknext(c) {
            this.check(c);
            this.xNext();
        }
        parlist() {
            /* parlist -> [ param { `,' param } ] */
            var f = this._fs.f;
            var nparams = 0;
            if (this._token != ')'.charCodeAt(0)) /* is `parlist' not empty? */ {
                do {
                    switch (this._token) {
                        case Syntax.TK_NAME: /* param -> NAME */
                            {
                                this.new_localvar(this.str_checkname(), nparams++);
                                break;
                            }
                        case Syntax.TK_DOTS: /* param -> `...' */
                            {
                                this.xNext();
                                f.isVararg = true;
                                break;
                            }
                        default:
                            this.xSyntaxerror("<name> or '...' expected");
                    }
                } while ((!f.isVararg) && this.testnext(','.charCodeAt(0)));
            }
            this.adjustlocalvars(nparams);
            f.numparams = this._fs.nactvar; /* VARARG_HASARG not now used */
            this._fs.kReserveregs(this._fs.nactvar); /* reserve register for parameters */
        }
        getlocvar(i) {
            var fstate = this._fs;
            return fstate.f.locvars[fstate.actvar[i]];
        }
        adjustlocalvars(nvars) {
            this._fs.nactvar += nvars;
            for (; nvars != 0; nvars--) {
                this.getlocvar(this._fs.nactvar - nvars).startpc = this._fs.pc;
            }
        }
        new_localvarliteral(v, n) {
            this.new_localvar(v, n);
        }
        errorlimit(limit, what) {
            var msg = this._fs.f.linedefined == 0 ?
                "main function has more than " + limit + " " + what :
                "function at line " + this._fs.f.linedefined + " has more than " + limit + " " + what;
            this.xLexerror(msg, 0);
        }
        yChecklimit(v, l, m) {
            if (v > l)
                this.errorlimit(l, m);
        }
        new_localvar(name, n) {
            this.yChecklimit(this._fs.nactvar + n + 1, Lua_1.Lua.MAXVARS, "local variables");
            this._fs.actvar[this._fs.nactvar + n] = this.registerlocalvar(name);
        }
        registerlocalvar(varname) {
            var f = this._fs.f;
            f.ensureLocvars(this._L, this._fs.nlocvars, /*Short*/ Number.MAX_SAFE_INTEGER); //TODO:
            f.locvars[this._fs.nlocvars].varname = varname;
            return this._fs.nlocvars++;
        }
        body(e, needself, line) {
            /* body ->  `(' parlist `)' chunk END */
            var new_fs = new FuncState_1.FuncState(this);
            this.open_func(new_fs);
            new_fs.f.linedefined = line;
            this.checknext('('.charCodeAt(0));
            if (needself) {
                this.new_localvarliteral("self", 0);
                this.adjustlocalvars(1);
            }
            this.parlist();
            this.checknext(')'.charCodeAt(0));
            this.chunk();
            new_fs.f.lastlinedefined = this._linenumber;
            this.check_match(Syntax.TK_END, Syntax.TK_FUNCTION, line);
            this.close_func();
            this.pushclosure(new_fs, e);
        }
        UPVAL_K(upvaldesc) {
            return (upvaldesc >>> 8) & 0xFF;
        }
        UPVAL_INFO(upvaldesc) {
            return upvaldesc & 0xFF;
        }
        UPVAL_ENCODE(k, info) {
            //# assert (k & 0xFF) == k && (info & 0xFF) == info
            return ((k & 0xFF) << 8) | (info & 0xFF);
        }
        pushclosure(func, v) {
            var f = this._fs.f;
            f.ensureProtos(this._L, this._fs.np);
            var ff = func.f;
            f.p[this._fs.np++] = ff;
            v.init(Expdesc_1.Expdesc.VRELOCABLE, this._fs.kCodeABx(Lua_1.Lua.OP_CLOSURE, 0, this._fs.np - 1));
            for (var i = 0; i < ff.nups; i++) {
                var upvalue = func.upvalues[i];
                var o = (this.UPVAL_K(upvalue) == Expdesc_1.Expdesc.VLOCAL) ? Lua_1.Lua.OP_MOVE :
                    Lua_1.Lua.OP_GETUPVAL;
                this._fs.kCodeABC(o, 0, this.UPVAL_INFO(upvalue), 0);
            }
        }
        funcname(v) {
            /* funcname -> NAME {field} [`:' NAME] */
            var needself = false;
            this.singlevar(v);
            while (this._token == '.'.charCodeAt(0))
                this.field(v);
            if (this._token == ':'.charCodeAt(0)) {
                needself = true;
                this.field(v);
            }
            return needself;
        }
        field(v) {
            /* field -> ['.' | ':'] NAME */
            var key = new Expdesc_1.Expdesc();
            this._fs.kExp2anyreg(v);
            this.xNext(); /* skip the dot or colon */
            this.checkname(key);
            this._fs.kIndexed(v, key);
        }
        repeatstat(line) {
            /* repeatstat -> REPEAT block UNTIL cond */
            var repeat_init = this._fs.kGetlabel();
            var bl1 = new BlockCnt_1.BlockCnt();
            var bl2 = new BlockCnt_1.BlockCnt();
            this.enterblock(this._fs, bl1, true); /* loop block */
            this.enterblock(this._fs, bl2, false); /* scope block */
            this.xNext(); /* skip REPEAT */
            this.chunk();
            this.check_match(Syntax.TK_UNTIL, Syntax.TK_REPEAT, line);
            var condexit = this.cond(); /* read condition (inside scope block) */
            if (!bl2.upval) /* no upvalues? */ {
                this.leaveblock(this._fs); /* finish scope */
                this._fs.kPatchlist(condexit, repeat_init); /* close the loop */
            }
            else /* complete semantics when there are upvalues */ {
                this.breakstat(); /* if condition then break */
                this._fs.kPatchtohere(condexit); /* else... */
                this.leaveblock(this._fs); /* finish scope... */
                this._fs.kPatchlist(this._fs.kJump(), repeat_init); /* and repeat */
            }
            this.leaveblock(this._fs); /* finish loop */
        }
        cond() {
            /* cond -> exp */
            var v = new Expdesc_1.Expdesc();
            this.expr(v); /* read condition */
            if (v.k == Expdesc_1.Expdesc.VNIL)
                v.k = Expdesc_1.Expdesc.VFALSE; /* `falses' are all equal here */
            this._fs.kGoiftrue(v);
            return v.f;
        }
        open_func(funcstate) {
            var f = new Proto_1.Proto(); /* registers 0/1 are always valid */
            f.init2(this.source, 2);
            funcstate.f = f;
            funcstate.ls = this;
            funcstate.L = this._L;
            funcstate.prev = this._fs; /* linked list of funcstates */
            this._fs = funcstate;
        }
        localstat() {
            /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
            var nvars = 0;
            var nexps;
            var e = new Expdesc_1.Expdesc();
            do {
                this.new_localvar(this.str_checkname(), nvars++);
            } while (this.testnext(','.charCodeAt(0)));
            if (this.testnext('='.charCodeAt(0))) {
                nexps = this.explist1(e);
            }
            else {
                e.k = Expdesc_1.Expdesc.VVOID;
                nexps = 0;
            }
            this.adjust_assign(nvars, nexps, e);
            this.adjustlocalvars(nvars);
        }
        forstat(line) {
            /* forstat -> FOR (fornum | forlist) END */
            var bl = new BlockCnt_1.BlockCnt();
            this.enterblock(this._fs, bl, true); /* scope for loop and control variables */
            this.xNext(); /* skip `for' */
            var varname = this.str_checkname(); /* first variable name */
            switch (String.fromCharCode(this._token)) {
                case '=':
                    this.fornum(varname, line);
                    break;
                case ',':
                case String.fromCharCode(Syntax.TK_IN):
                    this.forlist(varname);
                    break;
                default:
                    this.xSyntaxerror("\"=\" or \"in\" expected");
            }
            this.check_match(Syntax.TK_END, Syntax.TK_FOR, line);
            this.leaveblock(this._fs); /* loop scope (`break' jumps to this point) */
        }
        fornum(varname, line) {
            /* fornum -> NAME = exp1,exp1[,exp1] forbody */
            var base = this._fs.freereg;
            this.new_localvarliteral("(for index)", 0);
            this.new_localvarliteral("(for limit)", 1);
            this.new_localvarliteral("(for step)", 2);
            this.new_localvar(varname, 3);
            this.checknext('='.charCodeAt(0));
            this.exp1(); /* initial value */
            this.checknext(','.charCodeAt(0));
            this.exp1(); /* limit */
            if (this.testnext(','.charCodeAt(0)))
                this.exp1(); /* optional step */
            else /* default step = 1 */ {
                this._fs.kCodeABx(Lua_1.Lua.OP_LOADK, this._fs.freereg, this._fs.kNumberK(1));
                this._fs.kReserveregs(1);
            }
            this.forbody(base, line, 1, true);
        }
        exp1() {
            var e = new Expdesc_1.Expdesc();
            this.expr(e);
            var k = e.k;
            this._fs.kExp2nextreg(e);
            return k;
        }
        forlist(indexname) {
            /* forlist -> NAME {,NAME} IN explist1 forbody */
            var e = new Expdesc_1.Expdesc();
            var nvars = 0;
            var base = this._fs.freereg;
            /* create control variables */
            this.new_localvarliteral("(for generator)", nvars++);
            this.new_localvarliteral("(for state)", nvars++);
            this.new_localvarliteral("(for control)", nvars++);
            /* create declared variables */
            this.new_localvar(indexname, nvars++);
            while (this.testnext(','.charCodeAt(0)))
                this.new_localvar(this.str_checkname(), nvars++);
            this.checknext(Syntax.TK_IN);
            var line = this._linenumber;
            this.adjust_assign(3, this.explist1(e), e);
            this._fs.kCheckstack(3); /* extra space to call generator */
            this.forbody(base, line, nvars - 3, false);
        }
        forbody(base, line, nvars, isnum) {
            /* forbody -> DO block */
            var bl = new BlockCnt_1.BlockCnt();
            this.adjustlocalvars(3); /* control variables */
            this.checknext(Syntax.TK_DO);
            var prep = isnum ? this._fs.kCodeAsBx(Lua_1.Lua.OP_FORPREP, base, FuncState_1.FuncState.NO_JUMP) : this._fs.kJump();
            this.enterblock(this._fs, bl, false); /* scope for declared variables */
            this.adjustlocalvars(nvars);
            this._fs.kReserveregs(nvars);
            this.block();
            this.leaveblock(this._fs); /* end of scope for declared variables */
            this._fs.kPatchtohere(prep);
            var endfor = isnum ?
                this._fs.kCodeAsBx(Lua_1.Lua.OP_FORLOOP, base, FuncState_1.FuncState.NO_JUMP) :
                this._fs.kCodeABC(Lua_1.Lua.OP_TFORLOOP, base, 0, nvars);
            this._fs.kFixline(line); /* pretend that `OP_FOR' starts the loop */
            this._fs.kPatchlist((isnum ? endfor : this._fs.kJump()), prep + 1);
        }
        ifstat(line) {
            /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
            var escapelist = FuncState_1.FuncState.NO_JUMP;
            var flist = this.test_then_block(); /* IF cond THEN block */
            while (this._token == Syntax.TK_ELSEIF) {
                escapelist = this._fs.kConcat(escapelist, this._fs.kJump());
                this._fs.kPatchtohere(flist);
                flist = this.test_then_block(); /* ELSEIF cond THEN block */
            }
            if (this._token == Syntax.TK_ELSE) {
                escapelist = this._fs.kConcat(escapelist, this._fs.kJump());
                this._fs.kPatchtohere(flist);
                this.xNext(); /* skip ELSE (after patch, for correct line info) */
                this.block(); /* `else' part */
            }
            else
                escapelist = this._fs.kConcat(escapelist, flist);
            this._fs.kPatchtohere(escapelist);
            this.check_match(Syntax.TK_END, Syntax.TK_IF, line);
        }
        test_then_block() {
            /* test_then_block -> [IF | ELSEIF] cond THEN block */
            this.xNext(); /* skip IF or ELSEIF */
            var condexit = this.cond();
            this.checknext(Syntax.TK_THEN);
            this.block(); /* `then' part */
            return condexit;
        }
        whilestat(line) {
            /* whilestat -> WHILE cond DO block END */
            var bl = new BlockCnt_1.BlockCnt();
            this.xNext(); /* skip WHILE */
            var whileinit = this._fs.kGetlabel();
            var condexit = this.cond();
            this.enterblock(this._fs, bl, true);
            this.checknext(Syntax.TK_DO);
            this.block();
            this._fs.kPatchlist(this._fs.kJump(), whileinit);
            this.check_match(Syntax.TK_END, Syntax.TK_WHILE, line);
            this.leaveblock(this._fs);
            this._fs.kPatchtohere(condexit); /* false conditions finish the loop */
        }
        static hasmultret(k) {
            return k == Expdesc_1.Expdesc.VCALL || k == Expdesc_1.Expdesc.VVARARG;
        }
        adjust_assign(nvars, nexps, e) {
            var extra = nvars - nexps;
            if (Syntax.hasmultret(e.k)) {
                extra++; /* includes call itself */
                if (extra < 0)
                    extra = 0;
                this._fs.kSetreturns(e, extra); /* last exp. provides the difference */
                if (extra > 1)
                    this._fs.kReserveregs(extra - 1);
            }
            else {
                if (e.k != Expdesc_1.Expdesc.VVOID)
                    this._fs.kExp2nextreg(e); /* close last expression */
                if (extra > 0) {
                    var reg = this._fs.freereg;
                    this._fs.kReserveregs(extra);
                    this._fs.kNil(reg, extra);
                }
            }
        }
        localfunc() {
            var b = new Expdesc_1.Expdesc();
            this.new_localvar(this.str_checkname(), 0);
            var v = new Expdesc_1.Expdesc();
            v.init(Expdesc_1.Expdesc.VLOCAL, this._fs.freereg);
            this._fs.kReserveregs(1);
            this.adjustlocalvars(1);
            this.body(b, false, this._linenumber);
            this._fs.kStorevar(v, b);
            /* debug information will only see the variable after this point! */
            this._fs.getlocvar(this._fs.nactvar - 1).startpc = this._fs.pc;
        }
        yindex(v) {
            /* index -> '[' expr ']' */
            this.xNext(); /* skip the '[' */
            this.expr(v);
            this._fs.kExp2val(v);
            this.checknext(']'.charCodeAt(0));
        }
        xLookahead() {
            //# assert lookahead == TK_EOS
            this._lookahead = this.llex();
            this._lookaheadR = this._semR;
            this._lookaheadS = this._semS;
        }
        listfield(cc) {
            this.expr(cc.v);
            this.yChecklimit(cc.na, Lua_1.Lua.MAXARG_Bx, "items in a constructor");
            cc.na++;
            cc.tostore++;
        }
        indexupvalue(funcstate, name, v) {
            var f = funcstate.f;
            var oldsize = f.sizeupvalues;
            for (var i = 0; i < f.nups; i++) {
                var entry = funcstate.upvalues[i];
                if (this.UPVAL_K(entry) == v.k && this.UPVAL_INFO(entry) == v.info) {
                    //# assert name.equals(f.upvalues[i])
                    return i;
                }
            }
            /* new one */
            this.yChecklimit(f.nups + 1, Lua_1.Lua.MAXUPVALUES, "upvalues");
            f.ensureUpvals(this._L, f.nups);
            f.upvalues[f.nups] = name;
            //# assert v.k == Expdesc.VLOCAL || v.k == Expdesc.VUPVAL
            funcstate.upvalues[f.nups] = this.UPVAL_ENCODE(v.k, v.info);
            return f.nups++;
        }
        //新增
        get L() {
            return this._L;
        }
    }
    exports.Syntax = Syntax;
    /** End of File, must be -1 as that is what read() returns. */
    Syntax.EOZ = -1;
    Syntax.FIRST_RESERVED = 257;
    // WARNING: if you change the order of this enumeration,
    // grep "ORDER RESERVED"
    Syntax.TK_AND = Syntax.FIRST_RESERVED + 0;
    Syntax.TK_BREAK = Syntax.FIRST_RESERVED + 1;
    Syntax.TK_DO = Syntax.FIRST_RESERVED + 2;
    Syntax.TK_ELSE = Syntax.FIRST_RESERVED + 3;
    Syntax.TK_ELSEIF = Syntax.FIRST_RESERVED + 4;
    Syntax.TK_END = Syntax.FIRST_RESERVED + 5;
    Syntax.TK_FALSE = Syntax.FIRST_RESERVED + 6;
    Syntax.TK_FOR = Syntax.FIRST_RESERVED + 7;
    Syntax.TK_FUNCTION = Syntax.FIRST_RESERVED + 8;
    Syntax.TK_IF = Syntax.FIRST_RESERVED + 9;
    Syntax.TK_IN = Syntax.FIRST_RESERVED + 10;
    Syntax.TK_LOCAL = Syntax.FIRST_RESERVED + 11;
    Syntax.TK_NIL = Syntax.FIRST_RESERVED + 12;
    Syntax.TK_NOT = Syntax.FIRST_RESERVED + 13;
    Syntax.TK_OR = Syntax.FIRST_RESERVED + 14;
    Syntax.TK_REPEAT = Syntax.FIRST_RESERVED + 15;
    Syntax.TK_RETURN = Syntax.FIRST_RESERVED + 16;
    Syntax.TK_THEN = Syntax.FIRST_RESERVED + 17;
    Syntax.TK_TRUE = Syntax.FIRST_RESERVED + 18;
    Syntax.TK_UNTIL = Syntax.FIRST_RESERVED + 19;
    Syntax.TK_WHILE = Syntax.FIRST_RESERVED + 20;
    Syntax.TK_CONCAT = Syntax.FIRST_RESERVED + 21;
    Syntax.TK_DOTS = Syntax.FIRST_RESERVED + 22;
    Syntax.TK_EQ = Syntax.FIRST_RESERVED + 23;
    Syntax.TK_GE = Syntax.FIRST_RESERVED + 24;
    Syntax.TK_LE = Syntax.FIRST_RESERVED + 25;
    Syntax.TK_NE = Syntax.FIRST_RESERVED + 26;
    Syntax.TK_NUMBER = Syntax.FIRST_RESERVED + 27;
    Syntax.TK_NAME = Syntax.FIRST_RESERVED + 28;
    Syntax.TK_STRING = Syntax.FIRST_RESERVED + 29;
    Syntax.TK_EOS = Syntax.FIRST_RESERVED + 30;
    Syntax.NUM_RESERVED = Syntax.TK_WHILE - Syntax.FIRST_RESERVED + 1;
    /** Equivalent to luaX_tokens.  ORDER RESERVED */
    Syntax._tokens = [
        "and", "break", "do", "else", "elseif",
        "end", "false", "for", "function", "if",
        "in", "local", "nil", "not", "or", "repeat",
        "return", "then", "true", "until", "while",
        "..", "...", "==", ">=", "<=", "~=",
        "<number>", "<name>", "<string>", "<eof>"
    ];
    // grep "ORDER OPR" if you change these enums.
    // default access so that FuncState can access them.
    Syntax.OPR_ADD = 0;
    Syntax.OPR_SUB = 1;
    Syntax.OPR_MUL = 2;
    Syntax.OPR_DIV = 3;
    Syntax.OPR_MOD = 4;
    Syntax.OPR_POW = 5;
    Syntax.OPR_CONCAT = 6;
    Syntax.OPR_NE = 7;
    Syntax.OPR_EQ = 8;
    Syntax.OPR_LT = 9;
    Syntax.OPR_LE = 10;
    Syntax.OPR_GT = 11;
    Syntax.OPR_GE = 12;
    Syntax.OPR_AND = 13;
    Syntax.OPR_OR = 14;
    Syntax.OPR_NOBINOPR = 15;
    Syntax.OPR_MINUS = 0;
    Syntax.OPR_NOT = 1;
    Syntax.OPR_LEN = 2;
    Syntax.OPR_NOUNOPR = 3;
    // ORDER OPR
    /**
    * Priority table.  left-priority of an operator is
    * <code>priority[op][0]</code>, its right priority is
    * <code>priority[op][1]</code>.  Please do not modify this table.
    */
    Syntax.PRIORITY = [
        [6, 6], [6, 6], [7, 7], [7, 7], [7, 7],
        [10, 9], [5, 4],
        [3, 3], [3, 3],
        [3, 3], [3, 3], [3, 3], [3, 3],
        [2, 2], [1, 1] // logical (and/or)
    ];
    /** Priority for unary operators. */
    Syntax.UNARY_PRIORITY = 8;
});

},{"../java/Character":5,"../java/Hashtable":9,"../java/NumberFormatException":17,"../java/StringBuffer":26,"./BlockCnt":31,"./ConsControl":33,"./Expdesc":38,"./FuncState":41,"./LHSAssign":42,"./Lua":45,"./Proto":56}],61:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./LuaJavaCallback", "../java/StringBuffer", "./Lua"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableLib = void 0;
    const LuaJavaCallback_1 = require("./LuaJavaCallback");
    const StringBuffer_1 = require("../java/StringBuffer");
    const Lua_1 = require("./Lua");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/TableLib.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Contains Lua's table library.
     * The library can be opened using the {@link #open} method.
     */
    class TableLib extends LuaJavaCallback_1.LuaJavaCallback {
        /** Constructs instance, filling in the 'which' member. */
        constructor(which) {
            super();
            this._which = which;
        }
        /**
         * Implements all of the functions in the Lua table library.  Do not
         * call directly.
         * @param L  the Lua state in which to execute.
         * @return number of returned parameters, as per convention.
         */
        luaFunction(L) {
            switch (this._which) {
                case TableLib.CONCAT:
                    return TableLib.concat(L);
                case TableLib.INSERT:
                    return TableLib.insert(L);
                case TableLib.MAXN:
                    return TableLib.maxn(L);
                case TableLib.REMOVE:
                    return TableLib.remove(L);
                case TableLib.SORT:
                    return TableLib.sort(L);
                //FIXME: added
                case TableLib.GETN:
                    return TableLib.getn(L);
            }
            return 0;
        }
        /**
        * Opens the string library into the given Lua state.  This registers
        * the symbols of the string library in a newly created table called
        * "string".
        * @param L  The Lua state into which to open.
        */
        static open(L) {
            L.__register("table");
            TableLib.r(L, "concat", TableLib.CONCAT);
            TableLib.r(L, "insert", TableLib.INSERT);
            TableLib.r(L, "getn", TableLib.GETN); //FIXME: added
            TableLib.r(L, "maxn", TableLib.MAXN);
            TableLib.r(L, "remove", TableLib.REMOVE);
            TableLib.r(L, "sort", TableLib.SORT);
        }
        /** Register a function. */
        static r(L, name, which) {
            var f = new TableLib(which);
            var lib = L.getGlobal("table");
            L.setField(lib, name, f);
        }
        /** Implements table.concat. */
        static concat(L) {
            var sep = L.optString(2, "");
            L.checkType(1, Lua_1.Lua.TTABLE);
            var i = L.optInt(3, 1);
            var last = L.optInt(4, Lua_1.Lua.objLen(L.value(1)));
            var b = new StringBuffer_1.StringBuffer();
            var t = L.value(1);
            for (; i <= last; ++i) {
                var v = Lua_1.Lua.rawGetI(t, i);
                L.argCheck(Lua_1.Lua.isString(v), 1, "table contains non-strings");
                b.appendString(L.toString_(v));
                if (i != last)
                    b.appendString(L.toString_(sep));
            }
            L.pushString(b.toString());
            return 1;
        }
        /** Implements table.insert. */
        static insert(L) {
            var e = TableLib.aux_getn(L, 1) + 1; // first empty element
            var pos; // where to insert new element
            var t = L.value(1);
            switch (L.getTop()) {
                case 2: // called with only 2 arguments
                    pos = e; // insert new element at the end
                    break;
                case 3:
                    {
                        var i;
                        pos = L.checkInt(2); // 2nd argument is the position
                        if (pos > e)
                            e = pos; // grow array if necessary
                        for (i = e; i > pos; --i) // move up elements
                         {
                            // t[i] = t[i-1]
                            L.rawSetI(t, i, Lua_1.Lua.rawGetI(t, i - 1));
                        }
                    }
                    break;
                default:
                    return L.error("wrong number of arguments to 'insert'");
            }
            L.rawSetI(t, pos, L.value(-1)); // t[pos] = v
            return 0;
        }
        /** Implements table.maxn. */
        static maxn(L) {
            var max = 0;
            L.checkType(1, Lua_1.Lua.TTABLE);
            var t = L.value(1);
            var e = t.keys();
            while (e.hasMoreElements()) {
                var o = e.nextElement();
                if (Lua_1.Lua.____type(o) == Lua_1.Lua.TNUMBER) {
                    var v = L.toNumber(o);
                    if (v > max)
                        max = v;
                }
            }
            L.pushNumber(max);
            return 1;
        }
        /** Implements table.remove. */
        static remove(L) {
            var e = TableLib.aux_getn(L, 1);
            var pos = L.optInt(2, e);
            if (e == 0)
                return 0; // table is 'empty'
            var t = L.value(1);
            var o = Lua_1.Lua.rawGetI(t, pos); // result = t[pos]
            for (; pos < e; ++pos) {
                L.rawSetI(t, pos, Lua_1.Lua.rawGetI(t, pos + 1)); // t[pos] = t[pos+1]
            }
            L.rawSetI(t, e, Lua_1.Lua.NIL); // t[e] = nil
            L.pushObject(o);
            return 1;
        }
        /** Implements table.sort. */
        static sort(L) {
            var n = TableLib.aux_getn(L, 1);
            if (!L.isNoneOrNil(2)) // is there a 2nd argument?
                L.checkType(2, Lua_1.Lua.TFUNCTION);
            L.setTop(2); // make sure there is two arguments
            TableLib.auxsort(L, 1, n);
            return 0;
        }
        static auxsort(L, l, u) {
            var t = L.value(1);
            while (l < u) // for tail recursion
             {
                var i;
                var j;
                // sort elements a[l], a[l+u/2], and a[u]
                var o1 = Lua_1.Lua.rawGetI(t, l);
                var o2 = Lua_1.Lua.rawGetI(t, u);
                if (TableLib.sort_comp(L, o2, o1)) // a[u] < a[l]?
                 {
                    L.rawSetI(t, l, o2);
                    L.rawSetI(t, u, o1);
                }
                if (u - l == 1)
                    break; // only 2 elements
                i = (l + u) / 2;
                o1 = Lua_1.Lua.rawGetI(t, i);
                o2 = Lua_1.Lua.rawGetI(t, l);
                if (TableLib.sort_comp(L, o1, o2)) // a[i]<a[l]?
                 {
                    L.rawSetI(t, i, o2);
                    L.rawSetI(t, l, o1);
                }
                else {
                    o2 = Lua_1.Lua.rawGetI(t, u);
                    if (TableLib.sort_comp(L, o2, o1)) // a[u]<a[i]?
                     {
                        L.rawSetI(t, i, o2);
                        L.rawSetI(t, u, o1);
                    }
                }
                if (u - l == 2)
                    break; // only 3 elements
                var p = Lua_1.Lua.rawGetI(t, i); // Pivot
                o2 = Lua_1.Lua.rawGetI(t, u - 1);
                L.rawSetI(t, i, o2);
                L.rawSetI(t, u - 1, p);
                // a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2
                i = l;
                j = u - 1;
                // NB: Pivot P is in p
                while (true) // invariant: a[l..i] <= P <= a[j..u]
                 {
                    // repeat ++i until a[i] >= P
                    while (true) {
                        o1 = Lua_1.Lua.rawGetI(t, ++i);
                        if (!TableLib.sort_comp(L, o1, p))
                            break;
                        if (i > u)
                            L.error("invalid order function for sorting");
                    }
                    // repreat --j until a[j] <= P
                    while (true) {
                        o2 = Lua_1.Lua.rawGetI(t, --j);
                        if (!TableLib.sort_comp(L, p, o2))
                            break;
                        if (j < l)
                            L.error("invalid order function for sorting");
                    }
                    if (j < i)
                        break;
                    L.rawSetI(t, i, o2);
                    L.rawSetI(t, j, o1);
                }
                o1 = Lua_1.Lua.rawGetI(t, u - 1);
                o2 = Lua_1.Lua.rawGetI(t, i);
                L.rawSetI(t, u - 1, o2);
                L.rawSetI(t, i, o1); // swap pivot (a[u-1]) with a[i]
                // a[l..i-1 <= a[i] == P <= a[i+1..u]
                // adjust so that smaller half is in [j..i] and larger one in [l..u]
                if (i - l < u - i) {
                    j = l;
                    i = i - 1;
                    l = i + 2;
                }
                else {
                    j = i + 1;
                    i = u;
                    u = j - 2;
                }
                TableLib.auxsort(L, j, i); // call recursively the smaller one
            } // repeat the routine for the larger one
        }
        static sort_comp(L, a, b) {
            if (!Lua_1.Lua.isNil(L.value(2))) // function?
             {
                L.pushValue(2);
                L.pushObject(a);
                L.pushObject(b);
                L.call(2, 1);
                var res = L.toBoolean(L.value(-1));
                L.pop(1);
                return res;
            }
            else // a < b?
             {
                return L.lessThan(a, b);
            }
        }
        static aux_getn(L, n) {
            L.checkType(n, Lua_1.Lua.TTABLE);
            var t = L.value(n);
            return t.getn();
        }
        //FIXME: added
        static getn(L) {
            L.pushNumber(TableLib.aux_getn(L, 1));
            return 1;
        }
    }
    exports.TableLib = TableLib;
    // Each function in the table library corresponds to an instance of
    // this class which is associated (the 'which' member) with an integer
    // which is unique within this class.  They are taken from the following
    // set.  
    TableLib.CONCAT = 1;
    TableLib.INSERT = 2;
    TableLib.MAXN = 3;
    TableLib.REMOVE = 4;
    TableLib.SORT = 5;
    TableLib.GETN = 6;
});

},{"../java/StringBuffer":26,"./Lua":45,"./LuaJavaCallback":49}],62:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Slot"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpVal = void 0;
    const Slot_1 = require("./Slot");
    /*  $Header: //info.ravenbrook.com/project/jili/version/1.1/code/mnj/lua/UpVal.java#1 $
     * Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
     * All rights reserved.
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject
     * to the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //see jillcode(Java Implementation of Lua Language, Jill):
    //	http://code.google.com/p/jillcode/
    //这里的代码移植自jillcode(Lua的Java实现，Jill):
    //	http://code.google.com/p/jillcode/	
    /**
     * Models an upvalue.  This class is internal to Jill and should not be
     * used by clients.
     * This is the analogue of the UpVal type in PUC-Rio's Lua
     * implementation, hence the name.
     * An UpVal instance is a reference to a variable.
     * When initially created generally the variable is kept on the VM
     * stack.  When the function that defines that variable returns, the
     * corresponding stack slots are destroyed.  In order that the UpVal
     * continues to reference the variable, it is closed (using the
     * <code>close</code> method).  Lua functions that reference, via an
     * upvalue, the same instance of the same variable, will share an
     * <code>UpVal</code> (somewhere in their <code>upval</code> array
     * member); hence they share updates to the variable.
     */
    class UpVal {
        /**
         * A fresh upvalue from an offset, and a slot.
         * Conceptually <var>offset</var> and <var>slot</var> convey the same
         * information, only one is necessary since the offset implies the
         * slot and vice-versa.  <var>slot</var> is used to directly reference
         * the value (this avoids an indirection to the VM stack). <var>offset</var>
         * is used when searching for UpVals in the openupval list; this
         * happens when closing UpVals (function return) or creating them
         * (execution of functon declaration).
         * @param offset  index into Lua thread's VM stack, must be a valid index.
         * @param s  Slot corresponding to offset.
         * @throws NullPointerException if L is null.
         */
        constructor(offset, s) {
            /**
             * The offset field.  Stored here, but not actually used directly by
             * this class.
             * Used (by {@link Lua}) when searching for {@link UpVal} instances.
             * An open UpVal has a valid offset field.  Its slot is shared
             * with a slot of the VM stack.
             * A closed UpVal has offset == -1.  It's slot will be a fresh copy
             * and not shared with any other.
             */
            this._offset = 0;
            this._offset = offset;
            this._s = s;
        }
        /**
         * Getter for underlying value.
         */
        get value() {
            return this._s.asObject();
        }
        /**
         * Setter for underlying value.
         */
        set value(o) {
            this._s.setObject(o);
        }
        /**
         * The offset.
         */
        get offset() {
            return this._offset;
        }
        /**
         * Closes an UpVal.  This ensures that the storage operated on by
         * {@link #getValue() getValue} and {@link #setValue(Object) setValue}
         * is not shared by any other object.
         * This is typically used when a function returns (executes
         * the <code>OP_RET</code> VM instruction).  Effectively this
         * transfers a variable binding from the stack to the heap.
         */
        close() {
            var _s2 = this._s;
            this._s = new Slot_1.Slot();
            this._s.init1(_s2);
            this._offset = -1;
        }
    }
    exports.UpVal = UpVal;
});

},{"./Slot":57}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL2d6L0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImRpc3QvaW5kZXguanMiLCJkaXN0L2phdmEvQnl0ZUFycmF5LmpzIiwiZGlzdC9qYXZhL0J5dGVBcnJheU91dHB1dFN0cmVhbS5qcyIsImRpc3QvamF2YS9DYWxlbmRhci5qcyIsImRpc3QvamF2YS9DaGFyYWN0ZXIuanMiLCJkaXN0L2phdmEvRGF0YU91dHB1dFN0cmVhbS5qcyIsImRpc3QvamF2YS9FT0ZFeGNlcHRpb24uanMiLCJkaXN0L2phdmEvRW51bWVyYXRpb24uanMiLCJkaXN0L2phdmEvSGFzaHRhYmxlLmpzIiwiZGlzdC9qYXZhL0hhc2h0YWJsZUVudW0uanMiLCJkaXN0L2phdmEvSU9FeGNlcHRpb24uanMiLCJkaXN0L2phdmEvSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLmpzIiwiZGlzdC9qYXZhL0lucHV0U3RyZWFtLmpzIiwiZGlzdC9qYXZhL0lucHV0U3RyZWFtUmVhZGVyLmpzIiwiZGlzdC9qYXZhL01hdGhVdGlsLmpzIiwiZGlzdC9qYXZhL051bGxQb2ludGVyRXhjZXB0aW9uLmpzIiwiZGlzdC9qYXZhL051bWJlckZvcm1hdEV4Y2VwdGlvbi5qcyIsImRpc3QvamF2YS9PdXRPZk1lbW9yeUVycm9yLmpzIiwiZGlzdC9qYXZhL091dHB1dFN0cmVhbS5qcyIsImRpc3QvamF2YS9QcmludFN0cmVhbS5qcyIsImRpc3QvamF2YS9SYW5kb20uanMiLCJkaXN0L2phdmEvUmVhZGVyLmpzIiwiZGlzdC9qYXZhL1J1bnRpbWUuanMiLCJkaXN0L2phdmEvUnVudGltZUV4Y2VwdGlvbi5qcyIsImRpc3QvamF2YS9TdGFjay5qcyIsImRpc3QvamF2YS9TdHJpbmdCdWZmZXIuanMiLCJkaXN0L2phdmEvU3lzdGVtVXRpbC5qcyIsImRpc3QvamF2YS9UaW1lWm9uZS5qcyIsImRpc3QvbHVhL0Jhc2VMaWIuanMiLCJkaXN0L2x1YS9CYXNlTGliUmVhZGVyLmpzIiwiZGlzdC9sdWEvQmxvY2tDbnQuanMiLCJkaXN0L2x1YS9DYWxsSW5mby5qcyIsImRpc3QvbHVhL0NvbnNDb250cm9sLmpzIiwiZGlzdC9sdWEvRGVidWcuanMiLCJkaXN0L2x1YS9EdW1wU3RhdGUuanMiLCJkaXN0L2x1YS9EdW1wZWRJbnB1dC5qcyIsImRpc3QvbHVhL0VudW0uanMiLCJkaXN0L2x1YS9FeHBkZXNjLmpzIiwiZGlzdC9sdWEvRm9ybWF0SXRlbS5qcyIsImRpc3QvbHVhL0Zyb21SZWFkZXIuanMiLCJkaXN0L2x1YS9GdW5jU3RhdGUuanMiLCJkaXN0L2x1YS9MSFNBc3NpZ24uanMiLCJkaXN0L2x1YS9Mb2FkZXIuanMiLCJkaXN0L2x1YS9Mb2NWYXIuanMiLCJkaXN0L2x1YS9MdWEuanMiLCJkaXN0L2x1YS9MdWFFcnJvci5qcyIsImRpc3QvbHVhL0x1YUZ1bmN0aW9uLmpzIiwiZGlzdC9sdWEvTHVhSW50ZXJuYWwuanMiLCJkaXN0L2x1YS9MdWFKYXZhQ2FsbGJhY2suanMiLCJkaXN0L2x1YS9MdWFUYWJsZS5qcyIsImRpc3QvbHVhL0x1YVVzZXJkYXRhLmpzIiwiZGlzdC9sdWEvTWF0Y2hTdGF0ZS5qcyIsImRpc3QvbHVhL01hdGhMaWIuanMiLCJkaXN0L2x1YS9PU0xpYi5qcyIsImRpc3QvbHVhL1BhY2thZ2VMaWIuanMiLCJkaXN0L2x1YS9Qcm90by5qcyIsImRpc3QvbHVhL1Nsb3QuanMiLCJkaXN0L2x1YS9TdHJpbmdMaWIuanMiLCJkaXN0L2x1YS9TdHJpbmdSZWFkZXIuanMiLCJkaXN0L2x1YS9TeW50YXguanMiLCJkaXN0L2x1YS9UYWJsZUxpYi5qcyIsImRpc3QvbHVhL1VwVmFsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ254QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbndEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCIuL2x1YS9MdWFcIiwgXCIuL2x1YS9QYWNrYWdlTGliXCIsIFwiLi9sdWEvTWF0aExpYlwiLCBcIi4vbHVhL0Jhc2VMaWJcIiwgXCIuL2x1YS9PU0xpYlwiLCBcIi4vbHVhL1RhYmxlTGliXCIsIFwiLi9sdWEvU3RyaW5nTGliXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9sdWEvTHVhXCIpO1xyXG4gICAgY29uc3QgUGFja2FnZUxpYl8xID0gcmVxdWlyZShcIi4vbHVhL1BhY2thZ2VMaWJcIik7XHJcbiAgICBjb25zdCBNYXRoTGliXzEgPSByZXF1aXJlKFwiLi9sdWEvTWF0aExpYlwiKTtcclxuICAgIGNvbnN0IEJhc2VMaWJfMSA9IHJlcXVpcmUoXCIuL2x1YS9CYXNlTGliXCIpO1xyXG4gICAgY29uc3QgT1NMaWJfMSA9IHJlcXVpcmUoXCIuL2x1YS9PU0xpYlwiKTtcclxuICAgIGNvbnN0IFRhYmxlTGliXzEgPSByZXF1aXJlKFwiLi9sdWEvVGFibGVMaWJcIik7XHJcbiAgICBjb25zdCBTdHJpbmdMaWJfMSA9IHJlcXVpcmUoXCIuL2x1YS9TdHJpbmdMaWJcIik7XHJcbiAgICBmdW5jdGlvbiB0cmFjZShzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUocy5yZXBsYWNlKC9cXG4vZywgJzxicj4nKSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LndyaXRlKCc8YnI+Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKHMpO1xyXG4gICAgfVxyXG4gICAgdmFyIHRlc3QwMDEgPSBcIm4gPSA5OSArICgxICogMTApIC8gMiAtIDAuNTtcXG5cIiArXHJcbiAgICAgICAgXCJpZiBuID4gMTAgdGhlbiByZXR1cm4gJ09oLCDnnJ/nmoTmr5QxMOi/mOWkp+WTpjonLi5uIGVuZFxcblwiICtcclxuICAgICAgICBcInJldHVybiBuXFxuXCI7XHJcbiAgICB2YXIgdGVzdDAwMiA9IFwicmV0dXJuIF9WRVJTSU9OXCI7XHJcbiAgICB2YXIgdGVzdDAwMyA9IFwicmV0dXJuIG5pbFwiO1xyXG4gICAgdmFyIGlzTG9hZExpYiA9IHRydWU7XHJcbiAgICAvL3RyeSB7XHJcbiAgICB0cmFjZShcIlN0YXJ0IHRlc3QuLi5cIik7XHJcbiAgICB2YXIgTCA9IG5ldyBMdWFfMS5MdWEoKTtcclxuICAgIGlmIChpc0xvYWRMaWIpIHtcclxuICAgICAgICBCYXNlTGliXzEuQmFzZUxpYi5vcGVuKEwpO1xyXG4gICAgICAgIFBhY2thZ2VMaWJfMS5QYWNrYWdlTGliLm9wZW4oTCk7XHJcbiAgICAgICAgTWF0aExpYl8xLk1hdGhMaWIub3BlbihMKTtcclxuICAgICAgICBPU0xpYl8xLk9TTGliLm9wZW4oTCk7XHJcbiAgICAgICAgU3RyaW5nTGliXzEuU3RyaW5nTGliLm9wZW4oTCk7XHJcbiAgICAgICAgVGFibGVMaWJfMS5UYWJsZUxpYi5vcGVuKEwpO1xyXG4gICAgICAgIGlzTG9hZExpYiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgTC5zZXRUb3AoMCk7XHJcbiAgICB2YXIgc3RhdHVzID0gTC5kb1N0cmluZyh0ZXN0MDAzKTtcclxuICAgIGlmIChzdGF0dXMgIT0gMCkge1xyXG4gICAgICAgIHZhciBlcnJPYmogPSBMLnZhbHVlKDEpO1xyXG4gICAgICAgIHZhciB0b3N0cmluZyA9IEwuZ2V0R2xvYmFsKFwidG9zdHJpbmdcIik7XHJcbiAgICAgICAgTC5wdXNoT2JqZWN0KHRvc3RyaW5nKTtcclxuICAgICAgICBMLnB1c2hPYmplY3QoZXJyT2JqKTtcclxuICAgICAgICBMLmNhbGwoMSwgMSk7XHJcbiAgICAgICAgdmFyIGVyck9ialN0ciA9IEwudG9TdHJpbmdfKEwudmFsdWUoLTEpKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjb21waWxpbmcgOiBcIiArIEwudmFsdWUoMSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IEwudmFsdWUoMSk7XHJcbiAgICAgICAgdmFyIHRvc3RyaW5nXyA9IEwuZ2V0R2xvYmFsKFwidG9zdHJpbmdcIik7XHJcbiAgICAgICAgTC5wdXNoT2JqZWN0KHRvc3RyaW5nXyk7XHJcbiAgICAgICAgTC5wdXNoT2JqZWN0KHJlc3VsdCk7XHJcbiAgICAgICAgTC5jYWxsKDEsIDEpOyAvLyBjYWxsIEJhc2VMaWIudG9zdHJpbmcgPSBmdW5jdGlvbigpIHsuLi59XHJcbiAgICAgICAgdmFyIHJlc3VsdFN0ciA9IEwudG9TdHJpbmdfKEwudmFsdWUoLTEpKTtcclxuICAgICAgICB0cmFjZShcIlJlc3VsdCA+Pj4gXCIgKyByZXN1bHRTdHIpO1xyXG4gICAgfVxyXG59KTtcclxuLy99IGNhdGNoIChlKSB7XHJcbi8vICAgIC8vdHJhY2UoZS5nZXRTdGFja1RyYWNlKCkpOyAvL0ZJWE1FOlxyXG4vLyAgICB0cmFjZShlLnN0YWNrKTtcclxuLy99XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5CeXRlQXJyYXkgPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBCeXRlQXJyYXkge1xyXG4gICAgICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkJ5dGVBcnJheS5sZW5ndGggbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICAvL0ZJWE1FOlxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJCeXRlQXJyYXkuY2xlYXIoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2I6bnVtYmVyW11cclxuICAgICAgICB3cml0ZUJ5dGVzKGIsIG9mZiwgbGVuKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETzpcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiQnl0ZUFycmF5LndyaXRlQnl0ZXMoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZUJ5dGUoeCkge1xyXG4gICAgICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkJ5dGVBcnJheS53cml0ZUJ5dGUoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRCeUluZGV4KGluZGV4LCB2YWwpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiQnl0ZUFycmF5LnNldEJ5SW5kZXgoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZVVURkJ5dGVzKHgpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiQnl0ZUFycmF5LndyaXRlVVRGQnl0ZXMoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQoeCkge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJCeXRlQXJyYXkuZ2V0KCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRVVEZCeXRlcyhhKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkJ5dGVBcnJheS5yZWFkVVRGQnl0ZXMoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZEJ5dGUoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkJ5dGVBcnJheS5yZWFkQnl0ZSgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvd0Vycm9yKHN0cikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkJ5dGVBcnJheSA9IEJ5dGVBcnJheTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ5dGVBcnJheS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vQnl0ZUFycmF5XCIsIFwiLi9PdXRwdXRTdHJlYW1cIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkJ5dGVBcnJheU91dHB1dFN0cmVhbSA9IHZvaWQgMDtcclxuICAgIGNvbnN0IEJ5dGVBcnJheV8xID0gcmVxdWlyZShcIi4vQnl0ZUFycmF5XCIpO1xyXG4gICAgY29uc3QgT3V0cHV0U3RyZWFtXzEgPSByZXF1aXJlKFwiLi9PdXRwdXRTdHJlYW1cIik7XHJcbiAgICBjbGFzcyBCeXRlQXJyYXlPdXRwdXRTdHJlYW0gZXh0ZW5kcyBPdXRwdXRTdHJlYW1fMS5PdXRwdXRTdHJlYW0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9ieXRlcyA9IG5ldyBCeXRlQXJyYXlfMS5CeXRlQXJyYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9CeXRlQXJyYXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ieXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J5dGVzLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0ZJWE1FOm51bWJlcltdXHJcbiAgICAgICAgd3JpdGUoYikge1xyXG4gICAgICAgICAgICB0aGlzLl9ieXRlcy53cml0ZUJ5dGVzKGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0ZJWE1FOm51bWJlcltdXHJcbiAgICAgICAgd3JpdGVCeXRlcyhiLCBvZmYsIGxlbikge1xyXG4gICAgICAgICAgICB0aGlzLl9ieXRlcy53cml0ZUJ5dGVzKGIsIG9mZiwgbGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9UT0RPOiDov5nkuKrmlrnms5XmnInlvoXkv67mlLlcclxuICAgICAgICAvL1dyaXRlcyBhIGNoYXIgdG8gdGhlIHVuZGVybHlpbmcgb3V0cHV0IHN0cmVhbSBhcyBhIDItYnl0ZSB2YWx1ZSwgaGlnaCBieXRlIGZpcnN0XHJcbiAgICAgICAgd3JpdGVDaGFyKGIpIHtcclxuICAgICAgICAgICAgLy8gdmFyIGJ5dGVzOkJ5dGVBcnJheSA9IG5ldyBCeXRlQXJyYXkoKTtcclxuICAgICAgICAgICAgLy8gYnl0ZXMud3JpdGVNdWx0aUJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZShiKSwgXCJcIik7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuX2J5dGVzLndyaXRlQnl0ZXMoYnl0ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9ieXRlcy53cml0ZUJ5dGUoYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5CeXRlQXJyYXlPdXRwdXRTdHJlYW0gPSBCeXRlQXJyYXlPdXRwdXRTdHJlYW07XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlQXJyYXlPdXRwdXRTdHJlYW0uanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkNhbGVuZGFyID0gdm9pZCAwO1xyXG4gICAgY2xhc3MgQ2FsZW5kYXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2dldChmaWVsZCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENhbGVuZGFyLlNFQ09ORDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXRTZWNvbmRzKCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENhbGVuZGFyLk1JTlVURTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENhbGVuZGFyLkhPVVI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2FsZW5kYXIuTU9OVEg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGUuZ2V0TW9udGgoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2FsZW5kYXIuWUVBUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDYWxlbmRhci5EQVlfT0ZfV0VFSzpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRBWV9PRl9XRUVLIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENhbGVuZGFyLkRBWV9PRl9NT05USDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXREYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbGVuZGFyLl9nZXQoKTogZmllbGQgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zZXQoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2FsZW5kYXIuU0VDT05EOlxyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX2RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRTZWNvbmRzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIENhbGVuZGFyLk1JTlVURTpcclxuICAgICAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLl9kYXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0TWludXRlcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDYWxlbmRhci5IT1VSOlxyXG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuX2RhdGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXRIb3Vycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDYWxlbmRhci5NT05USDpcclxuICAgICAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLl9kYXRlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2V0TW9udGgodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2FsZW5kYXIuWUVBUjpcclxuICAgICAgICAgICAgICAgICAgICAoX2UgPSB0aGlzLl9kYXRlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2V0RnVsbFllYXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbGVuZGFyLl9zZXQoKTogZmllbGQgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGdldEluc3RhbmNlKHR6KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDYWxlbmRhci5faW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWUoZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlID0gZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0VGltZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5DYWxlbmRhciA9IENhbGVuZGFyO1xyXG4gICAgQ2FsZW5kYXIuU0VDT05EID0gMTtcclxuICAgIENhbGVuZGFyLk1JTlVURSA9IDI7XHJcbiAgICBDYWxlbmRhci5IT1VSID0gMztcclxuICAgIENhbGVuZGFyLkRBWV9PRl9NT05USCA9IDQ7XHJcbiAgICBDYWxlbmRhci5NT05USCA9IDU7XHJcbiAgICBDYWxlbmRhci5ZRUFSID0gNjtcclxuICAgIENhbGVuZGFyLkRBWV9PRl9XRUVLID0gNztcclxuICAgIENhbGVuZGFyLlNVTkRBWSA9IDg7XHJcbiAgICBDYWxlbmRhci5NT05EQVkgPSA5O1xyXG4gICAgQ2FsZW5kYXIuVFVFU0RBWSA9IDEwO1xyXG4gICAgQ2FsZW5kYXIuV0VETkVTREFZID0gMTE7XHJcbiAgICBDYWxlbmRhci5USFVSU0RBWSA9IDEyO1xyXG4gICAgQ2FsZW5kYXIuRlJJREFZID0gMTM7XHJcbiAgICBDYWxlbmRhci5TQVRVUkRBWSA9IDE0O1xyXG4gICAgQ2FsZW5kYXIuSkFOVUFSWSA9IDE1O1xyXG4gICAgQ2FsZW5kYXIuRkVCUlVBUlkgPSAxNjtcclxuICAgIENhbGVuZGFyLk1BUkNIID0gMTc7XHJcbiAgICBDYWxlbmRhci5BUFJJTCA9IDE4O1xyXG4gICAgQ2FsZW5kYXIuTUFZID0gMTk7XHJcbiAgICBDYWxlbmRhci5KVU5FID0gMjA7XHJcbiAgICBDYWxlbmRhci5KVUxZID0gMjE7XHJcbiAgICBDYWxlbmRhci5BVUdVU1QgPSAyMjtcclxuICAgIENhbGVuZGFyLlNFUFRFTUJFUiA9IDIzO1xyXG4gICAgQ2FsZW5kYXIuT0NUT0JFUiA9IDI0O1xyXG4gICAgQ2FsZW5kYXIuTk9WRU1CRVIgPSAyNTtcclxuICAgIENhbGVuZGFyLkRFQ0VNQkVSID0gMjY7XHJcbiAgICBDYWxlbmRhci5faW5zdGFuY2UgPSBuZXcgQ2FsZW5kYXIoKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbGVuZGFyLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5DaGFyYWN0ZXIgPSB2b2lkIDA7XHJcbiAgICAvLyDms6jmhI/vvJpDaGFyYWN0ZXIudG9TdHJpbmfnlKhTdHJpbmcuZnJvbUNoYXJDb2RlKCnku6Pmm79cclxuICAgIGNsYXNzIENoYXJhY3RlciB7XHJcbiAgICAgICAgc3RhdGljIGlzVXBwZXJDYXNlKGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaCA+PSAnQScuY2hhckNvZGVBdCgwKSAmJiBjaCA8PSAnWicuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGlzTG93ZXJDYXNlKGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaCA+PSAnYScuY2hhckNvZGVBdCgwKSAmJiBjaCA8PSAneicuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGlzRGlnaXQoY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoID49ICcwJy5jaGFyQ29kZUF0KDApICYmIGNoIDw9ICc5Jy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgdG9Mb3dlckNhc2UoY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5DaGFyYWN0ZXIgPSBDaGFyYWN0ZXI7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGFyYWN0ZXIuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkRhdGFPdXRwdXRTdHJlYW0gPSB2b2lkIDA7XHJcbiAgICAvKipcclxuICAgICAqIOaVsOaNrui+k+WHuua1geWFgeiuuOW6lOeUqOeoi+W6j+S7pemAguW9k+aWueW8j+WwhuWfuuacrCBKYXZhIOaVsOaNruexu+Wei+WGmeWFpei+k+WHuua1geS4reOAglxyXG4gICAgICog54S25ZCO77yM5bqU55So56iL5bqP5Y+v5Lul5L2/55So5pWw5o2u6L6T5YWl5rWB5bCG5pWw5o2u6K+75YWl44CCXHJcbiAgICAgKlxyXG4gICAgICog5bCB6KOF5p6E6YCg5Ye95pWw5Lit55qET3V0cHV0U3RyZWFt77yM6ICM6L+Z5Liq57G755qE54m554K55piv57uf6K6h5LqG5YaZ5YWl5a2X6IqC5pWw44CCXHJcbiAgICAgKiDlrp7njrDov5nkuKrnsbvvvIzln7rmnKzkuIrlj6rnlKh3cml0ZUJ5dGXlpITnkIZcclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiDlrp7pmYXkvKDlhaXnmoTmmK8gQnl0ZUFycmF5T3V0cHV0U3RyZWFt77yM6KeBU3RyaW5nTGliXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIERhdGFPdXRwdXRTdHJlYW0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHdyaXRlcikge1xyXG4gICAgICAgICAgICB0aGlzLndyaXR0ZW4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLndyaXR0ZW4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl93cml0ZXIgPSB3cml0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoKCkge1xyXG4gICAgICAgICAgICB0aGlzLl93cml0ZXIuZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWRcclxuICAgICAgICBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0dGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0ZJWE1FOm51bWJlcltdXHJcbiAgICAgICAgd3JpdGUoYiwgb2ZmLCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKG9mZiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBvZmYgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGVuID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2YXIgYnl0ZXMgPSBuZXcgQnl0ZUFycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGJ5dGVzLndyaXRlQnl0ZXMoYiwgb2ZmLCBsZW4pO1xyXG4gICAgICAgICAgICAvLyB0aGlzLl93cml0ZXIhLndyaXRlKGJ5dGVzKTtcclxuICAgICAgICAgICAgLy90aGlzLndyaXR0ZW4gKz0gYnl0ZXMubGVuZ3RoOyAgIFxyXG4gICAgICAgICAgICB0aGlzLl93cml0ZXIud3JpdGVCeXRlcyhiLCBvZmYsIGxlbik7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdHRlbiArPSBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcHVibGljIHdyaXRlKGI6aW50KTp2b2lkXHJcbiAgICAgICAgLy97XHJcbiAgICAgICAgLy9cdFxyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIHdyaXRlQm9vbGVhbih2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVCb29sZWFuKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgLy8gdmFyIGJ5dGVzID0gbmV3IEJ5dGVBcnJheSgpO1xyXG4gICAgICAgICAgICAvLyBieXRlcy53cml0ZUJvb2xlYW4odik7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuX3dyaXRlci53cml0ZShieXRlcyk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMud3JpdHRlbiArPSBieXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdyaXRlQnl0ZSh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVCeXRlKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgLy8gLy8/Pz9cclxuICAgICAgICAgICAgLy8gLy90aGlzLl93cml0ZXIud3JpdGVDaGFyKHYpO1xyXG4gICAgICAgICAgICAvLyB2YXIgYnl0ZXMgPSBuZXcgQnl0ZUFycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGJ5dGVzLndyaXRlQnl0ZSh2KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5fd3JpdGVyLndyaXRlKGJ5dGVzKTtcclxuICAgICAgICAgICAgLy8gdGhpcy53cml0dGVuICs9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd3JpdGVCeXRlcyhzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVCeXRlcygpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIC8vIHZhciBieXRlcyA9IG5ldyBCeXRlQXJyYXkoKTtcclxuICAgICAgICAgICAgLy8gYnl0ZXMud3JpdGVNdWx0aUJ5dGUocywgXCJcIik7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuX3dyaXRlci53cml0ZShieXRlcyk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMud3JpdHRlbiArPSBieXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vVE9ETzog6L+Z5Liq5pa55rOV5pyJ5b6F5L+u5pS5XHJcbiAgICAgICAgd3JpdGVDaGFyKHYpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiRGF0YU91dHB1dFN0cmVhbS53cml0ZUNoYXIoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICAvLyB2YXIgYnl0ZXMgPSBuZXcgQnl0ZUFycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGJ5dGVzLndyaXRlTXVsdGlCeXRlKFN0cmluZy5mcm9tQ2hhckNvZGUodiksIFwiXCIpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLl93cml0ZXIud3JpdGUoYnl0ZXMpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLndyaXR0ZW4gKz0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1RPRE86IOi/meS4quaWueazleacieW+heS/ruaUuVxyXG4gICAgICAgIHdyaXRlQ2hhcnMocykge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJEYXRhT3V0cHV0U3RyZWFtLndyaXRlQ2hhcnMoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICAvLyB2YXIgYnl0ZXMgPSBuZXcgQnl0ZUFycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGJ5dGVzLndyaXRlTXVsdGlCeXRlKHMsIFwiXCIpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLl93cml0ZXIud3JpdGUoYnl0ZXMpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLndyaXR0ZW4gKz0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZURvdWJsZSh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVEb3VibGUoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICAvLyB2YXIgYnl0ZXMgPSBuZXcgQnl0ZUFycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGJ5dGVzLndyaXRlRG91YmxlKHYpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLl93cml0ZXIud3JpdGUoYnl0ZXMpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLndyaXR0ZW4gKz0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZUZsb2F0KHYpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiRGF0YU91dHB1dFN0cmVhbS53cml0ZUZsb2F0KCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgLy8gdmFyIGJ5dGVzID0gbmV3IEJ5dGVBcnJheSgpO1xyXG4gICAgICAgICAgICAvLyBieXRlcy53cml0ZUZsb2F0KHYpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLl93cml0ZXIud3JpdGUoYnl0ZXMpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLndyaXR0ZW4gKz0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZUludCh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVJbnQoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICAvLyB2YXIgYnl0ZXMgPSBuZXcgQnl0ZUFycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGJ5dGVzLndyaXRlSW50KHYpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLl93cml0ZXIud3JpdGUoYnl0ZXMpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLndyaXR0ZW4gKz0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+i/memHjOWPr+iDveaciemXrumimFxyXG4gICAgICAgIHdyaXRlTG9uZyh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVMb25nKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgLy8gdmFyIGJ5dGVzID0gbmV3IEJ5dGVBcnJheSgpO1xyXG4gICAgICAgICAgICAvLyBieXRlcy53cml0ZUludCh2KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5fd3JpdGVyLndyaXRlKGJ5dGVzKTtcclxuICAgICAgICAgICAgLy8gdGhpcy53cml0dGVuICs9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd3JpdGVTaG9ydCh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVTaG9ydCgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIC8vIHZhciBieXRlcyA9IG5ldyBCeXRlQXJyYXkoKTtcclxuICAgICAgICAgICAgLy8gYnl0ZXMud3JpdGVTaG9ydCh2KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5fd3JpdGVyLndyaXRlKGJ5dGVzKTtcclxuICAgICAgICAgICAgLy8gdGhpcy53cml0dGVuICs9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd3JpdGVVVEYoc3RyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIkRhdGFPdXRwdXRTdHJlYW0ud3JpdGVVVEYoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICAvLyB2YXIgYnl0ZXMgPSBuZXcgQnl0ZUFycmF5KCk7XHJcbiAgICAgICAgICAgIC8vIGJ5dGVzLndyaXRlVVRGQnl0ZXMoc3RyKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5fd3JpdGVyLndyaXRlKGJ5dGVzKTtcclxuICAgICAgICAgICAgLy8gdGhpcy53cml0dGVuICs9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3dFcnJvcihzdHIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coc3RyKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5EYXRhT3V0cHV0U3RyZWFtID0gRGF0YU91dHB1dFN0cmVhbTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFPdXRwdXRTdHJlYW0uanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkVPRkV4Y2VwdGlvbiA9IHZvaWQgMDtcclxuICAgIGNsYXNzIEVPRkV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzdHIpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHN0cjtcclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tUcmFjZSA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0ZJWE1FOiBub3QgdXNlZFxyXG4gICAgICAgIGdldFN0YWNrVHJhY2UoKSB7XHJcbiAgICAgICAgICAgIC8vdGhpcy5fc3RhY2tUcmFjZSA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLnN0YWNrO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tUcmFjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkVPRkV4Y2VwdGlvbiA9IEVPRkV4Y2VwdGlvbjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVPRkV4Y2VwdGlvbi5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuRW51bWVyYXRpb24gPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBFbnVtZXJhdGlvbiB7XHJcbiAgICAgICAgaGFzTW9yZUVsZW1lbnRzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRFbGVtZW50KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkVudW1lcmF0aW9uID0gRW51bWVyYXRpb247XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbnVtZXJhdGlvbi5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vSGFzaHRhYmxlRW51bVwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuSGFzaHRhYmxlID0gdm9pZCAwO1xyXG4gICAgY29uc3QgSGFzaHRhYmxlRW51bV8xID0gcmVxdWlyZShcIi4vSGFzaHRhYmxlRW51bVwiKTtcclxuICAgIGNsYXNzIEhhc2h0YWJsZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoaW5pdGlhbENhcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChpbml0aWFsQ2FwYWNpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbENhcGFjaXR5ID0gMTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9EaWN0aW9uYXJ55pSv5oyB55SoT2JqZWN05L2c5Li66ZSu77yM6ICMQXJyYXnkvJrlr7nplK7ov5vooYx0b1N0cmluZ+eahOi9rOaNolxyXG4gICAgICAgICAgICB0aGlzLl9kaWMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlaGFzaCgpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5cygpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1fID0gbmV3IEhhc2h0YWJsZUVudW1fMS5IYXNodGFibGVFbnVtKCk7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2RpYykge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnVtXy5zZXRBcnIoYXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudW1fO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZ2V0KGtleSkge1xyXG4gICAgICAgICAgICAvLyAgICBpZiAodHlwZW9mIHRoaXMuX2RpYyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKCdoZXJlJyk7XHJcbiAgICAgICAgICAgIC8vICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpYy5nZXQoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHV0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gICAgaWYgKHR5cGVvZiB0aGlzLl9kaWMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZygnaGVyZScpO1xyXG4gICAgICAgICAgICAvLyAgICB9XHJcbiAgICAgICAgICAgIHZhciBwcmUgPSB0aGlzLl9kaWMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYy5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICAgICAgdmFyIHByZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaWMuZ2V0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHByZSA9IHRoaXMuX2RpYy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpYy5zZXQoa2V5LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGlzLl9kaWNba2V5XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpYy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuSGFzaHRhYmxlID0gSGFzaHRhYmxlO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaHRhYmxlLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9FbnVtZXJhdGlvblwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuSGFzaHRhYmxlRW51bSA9IHZvaWQgMDtcclxuICAgIGNvbnN0IEVudW1lcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9FbnVtZXJhdGlvblwiKTtcclxuICAgIC8vIOazqOaEj++8mui/meS4quexu+S4jeW6lOivpeeUsUhhc2h0YWJsZeS7peWklueahOexu+WIm+W7ulxyXG4gICAgY2xhc3MgSGFzaHRhYmxlRW51bSBleHRlbmRzIEVudW1lcmF0aW9uXzEuRW51bWVyYXRpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcnIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9pZHggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sZW4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hcnIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9pZHggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sZW4gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNNb3JlRWxlbWVudHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZHggPCB0aGlzLl9sZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRFbGVtZW50KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyW3RoaXMuX2lkeCsrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/ms6jmhI/vvJrku4XmmrTpnLLnu5lIYXNodGFibGXkvb/nlKjnmoTmlrnms5VcclxuICAgICAgICBzZXRBcnIoYXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXJyID0gYXJyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWR4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlbiA9IHRoaXMuX2Fyci5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkhhc2h0YWJsZUVudW0gPSBIYXNodGFibGVFbnVtO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaHRhYmxlRW51bS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuSU9FeGNlcHRpb24gPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBJT0V4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzdHIpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHN0cjtcclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tUcmFjZSA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0ZJWE1FOiBub3QgdXNlZFxyXG4gICAgICAgIGdldFN0YWNrVHJhY2UoKSB7XHJcbiAgICAgICAgICAgIC8vdGhpcy5fc3RhY2tUcmFjZSA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLnN0YWNrO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tUcmFjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLklPRXhjZXB0aW9uID0gSU9FeGNlcHRpb247XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JT0V4Y2VwdGlvbi5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gdm9pZCAwO1xyXG4gICAgY2xhc3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cikge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gc3RyO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSkuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6IG5vdCB1c2VkXHJcbiAgICAgICAgZ2V0U3RhY2tUcmFjZSgpIHtcclxuICAgICAgICAgICAgLy90aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSkuc3RhY2s7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFja1RyYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5JbnB1dFN0cmVhbSA9IHZvaWQgMDtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIOatpOaKveixoeexu+aYr+ihqOekuuWtl+iKgui+k+WFpea1geeahOaJgOacieexu+eahOi2heexu+OAglxyXG4gICAgICog6ZyA6KaB5a6a5LmJIElucHV0U3RyZWFtIOeahOWtkOexu+eahOW6lOeUqOeoi+W6j1xyXG4gICAgICog5b+F6aG75aeL57uI5o+Q5L6b6L+U5Zue5LiL5LiA5Liq6L6T5YWl5a2X6IqC55qE5pa55rOV44CCXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBJbnB1dFN0cmVhbSB7XHJcbiAgICAgICAgLy9GSVhNRTogbnVtYmVyW10tPkJ5dGVBcnJheVxyXG4gICAgICAgIHJlYWRCeXRlcyhiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIklucHV0U3RyZWFtLnJlYWRCeXRlcygpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDku47ovpPlhaXmtYHor7vlj5bkuIvkuIDkuKrmlbDmja7lrZfoioLjgIJcclxuICAgICAgICByZWFkKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJJbnB1dFN0cmVhbS5yZWFkQ2hhcigpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiSW5wdXRTdHJlYW0ucmVzZXQoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrKHJlYWRhaGVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJJbnB1dFN0cmVhbS5tYXJrKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya1N1cHBvcnRlZCgpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiSW5wdXRTdHJlYW0ubWFya1N1cHBvcnRlZCgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIklucHV0U3RyZWFtLmNsb3NlKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXZhaWxhYmxlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJJbnB1dFN0cmVhbS5hdmFpbGFibGUoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2tpcChuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIklucHV0U3RyZWFtLnNraXAoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZE11bHRpQnl0ZXMoYnl0ZXMsIG9mZiwgbGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIklucHV0U3RyZWFtLnJlYWRCeXRlcygpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvd0Vycm9yKHN0cikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLklucHV0U3RyZWFtID0gSW5wdXRTdHJlYW07XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dFN0cmVhbS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vUmVhZGVyXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5JbnB1dFN0cmVhbVJlYWRlciA9IHZvaWQgMDtcclxuICAgIGNvbnN0IFJlYWRlcl8xID0gcmVxdWlyZShcIi4vUmVhZGVyXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKlx055So5LqO6K+75Y+W5a2X56ym5rWB55qE5oq96LGh57G744CCXHJcbiAgICAgKlx05a2Q57G75b+F6aG75a6e546w55qE5pa55rOV5Y+q5pyJIHJlYWQoY2hhcltdLCBpbnQsIGludCkg5ZKMIGNsb3NlKCnjgIJcclxuICAgICAqXHTkvYbmmK/vvIzlpJrmlbDlrZDnsbvlsIbph43lhpnmraTlpITlrprkuYnnmoTkuIDkupvmlrnms5XvvIxcclxuICAgICAqXHTku6Xmj5Dkvpvmm7Tpq5jnmoTmlYjnjoflkowv5oiW5YW25LuW5Yqf6IO944CCXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogIElucHV0U3RyZWFtUmVhZGVyIOaYr+Wtl+iKgua1gemAmuWQkeWtl+espua1geeahOahpeaige+8mlxyXG4gICAgICogXHTlroPkvb/nlKjmjIflrprnmoQgY2hhcnNldCDor7vlj5blrZfoioLlubblsIblhbbop6PnoIHkuLrlrZfnrKbjgIJcclxuICAgICAqIFx05a6D5L2/55So55qE5a2X56ym6ZuG5Y+v5Lul55Sx5ZCN56ew5oyH5a6a5oiW5pi+5byP57uZ5a6a77yMXHJcbiAgICAgKiBcdOWQpuWImeWPr+iDveaOpeWPl+W5s+WPsOm7mOiupOeahOWtl+espumbhuOAglxyXG4gICAgICogXHTmr4/mrKHosIPnlKggSW5wdXRTdHJlYW1SZWFkZXIg5Lit55qE5LiA5LiqIHJlYWQoKSDmlrnms5Xpg73kvJrlr7zoh7Tku47ln7rnoYDovpPlhaXmtYHor7vlj5bkuIDkuKrmiJblpJrkuKrlrZfoioLjgIJcclxuICAgICAqIFx06KaB5ZCv55So5LuO5a2X6IqC5Yiw5a2X56ym55qE5pyJ5pWI6L2s5o2i77yM5Y+v5Lul5o+Q5YmN5LuO5Z+656GA5rWB6K+75Y+W5pu05aSa55qE5a2X6IqC77yMXHJcbiAgICAgKiBcdOS9v+WFtui2hei/h+a7oei2s+W9k+WJjeivu+WPluaTjeS9nOaJgOmcgOeahOWtl+iKguOAglxyXG4gICAgICogXHTkuLrkuobovr7liLDmnIDpq5jmlYjnjofvvIzlj6/opoHogIPomZHlnKggQnVmZmVyZWRSZWFkZXIg5YaF5YyF6KOFIElucHV0U3RyZWFtUmVhZGVy44CCXHJcbiAgICAgKi9cclxuICAgIC8v6KeBTHVhSW50ZXJuYWzvvIzliJvlu7rkuIDkuKrluKblrZfnrKbpm4bvvIhVVEY477yJ55qE6K+75Ye65ZmoXHJcbiAgICAvL2nlj6/og73mmK9EdW1wZWRJbnB1dFxyXG4gICAgLy9jaGFyc2V0TmFtZeWPr+iDveaYr1wiVVRGOFwiXHJcbiAgICBjbGFzcyBJbnB1dFN0cmVhbVJlYWRlciBleHRlbmRzIFJlYWRlcl8xLlJlYWRlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoaSwgY2hhcnNldE5hbWUpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5faSA9IGk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYXJzZXROYW1lID0gY2hhcnNldE5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsb3NlKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmsocmVhZEFoZWFkTGltaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5faS5tYXJrKHJlYWRBaGVhZExpbWl0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya1N1cHBvcnRlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2kubWFya1N1cHBvcnRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faS5yZWFkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRCeXRlcyhjYnVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pLnJlYWRCeXRlcyhjYnVmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mnKzlt6XnqIvmnKrkvb/nlKhcclxuICAgICAgICByZWFkTXVsdGlCeXRlcyhjYnVmLCBvZmYsIGxlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faS5yZWFkTXVsdGlCeXRlcyhjYnVmLCBvZmYsIGxlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vVE9ETzo/XHJcbiAgICAgICAgcmVhZHkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy5faS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDmnKzlt6XnqIvmnKrkvb/nlKhcclxuICAgICAgICBza2lwKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2kuc2tpcChuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLklucHV0U3RyZWFtUmVhZGVyID0gSW5wdXRTdHJlYW1SZWFkZXI7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dFN0cmVhbVJlYWRlci5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuTWF0aFV0aWwgPSB2b2lkIDA7XHJcbiAgICAvL3NlZSBodHRwOi8vY29kZXNuaXBwLml0L2NvZGUvOTM5XHJcbiAgICBjbGFzcyBNYXRoVXRpbCB7XHJcbiAgICAgICAgLy8g5byn5bqm6L2s5o2i5Li66KeS5bqmXHJcbiAgICAgICAgLy8gY29udmVydCByYWRpYW5zIHRvIGRlZ3JlZXMgIFxyXG4gICAgICAgIHN0YXRpYyB0b0RlZ3JlZXMocmFkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocmFkIC8gMTgwICogTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zICBcclxuICAgICAgICAvLyDop5LluqbovazmjaLkuLrlvKfluqZcclxuICAgICAgICBzdGF0aWMgdG9SYWRpYW5zKGRlZykge1xyXG4gICAgICAgICAgICByZXR1cm4gKGRlZyAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTWF0aFV0aWwgPSBNYXRoVXRpbDtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdGhVdGlsLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5OdWxsUG9pbnRlckV4Y2VwdGlvbiA9IHZvaWQgMDtcclxuICAgIGNsYXNzIE51bGxQb2ludGVyRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cikge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gc3RyO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSkuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6IG5vdCB1c2VkXHJcbiAgICAgICAgZ2V0U3RhY2tUcmFjZSgpIHtcclxuICAgICAgICAgICAgLy90aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSkuc3RhY2s7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFja1RyYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTnVsbFBvaW50ZXJFeGNlcHRpb24gPSBOdWxsUG9pbnRlckV4Y2VwdGlvbjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bGxQb2ludGVyRXhjZXB0aW9uLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5OdW1iZXJGb3JtYXRFeGNlcHRpb24gPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBOdW1iZXJGb3JtYXRFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XHJcbiAgICAgICAgY29uc3RydWN0b3Ioc3RyKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBzdHI7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrVHJhY2UgPSBuZXcgRXJyb3IodGhpcy5tZXNzYWdlKS5zdGFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWRcclxuICAgICAgICBnZXRTdGFja1RyYWNlKCkge1xyXG4gICAgICAgICAgICAvL3RoaXMuX3N0YWNrVHJhY2UgPSBuZXcgRXJyb3IodGhpcy5tZXNzYWdlKS5zdGFjaztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrVHJhY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5OdW1iZXJGb3JtYXRFeGNlcHRpb24gPSBOdW1iZXJGb3JtYXRFeGNlcHRpb247XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdW1iZXJGb3JtYXRFeGNlcHRpb24uanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLk91dE9mTWVtb3J5RXJyb3IgPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBPdXRPZk1lbW9yeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cikge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gc3RyO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSkuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6IG5vdCB1c2VkXHJcbiAgICAgICAgZ2V0U3RhY2tUcmFjZSgpIHtcclxuICAgICAgICAgICAgLy90aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSkuc3RhY2s7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFja1RyYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuT3V0T2ZNZW1vcnlFcnJvciA9IE91dE9mTWVtb3J5RXJyb3I7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdXRPZk1lbW9yeUVycm9yLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5PdXRwdXRTdHJlYW0gPSB2b2lkIDA7XHJcbiAgICAvKipcclxuICAgICAqIOatpOaKveixoeexu+aYr+ihqOekuui+k+WHuuWtl+iKgua1geeahOaJgOacieexu+eahOi2heexu+OAglxyXG4gICAgICog6L6T5Ye65rWB5o6l5Y+X6L6T5Ye65a2X6IqC5bm25bCG6L+Z5Lqb5a2X6IqC5Y+R6YCB5Yiw5p+Q5Liq5o6l5pS25Zmo44CCXHJcbiAgICAgKiDpnIDopoHlrprkuYkgT3V0cHV0U3RyZWFtIOWtkOexu+eahOW6lOeUqOeoi+W6j+W/hemhu+Wni+e7iOaPkOS+m1xyXG4gICAgICog6Iez5bCR5LiA56eN5Y+v5YaZ5YWl5LiA5Liq6L6T5Ye65a2X6IqC55qE5pa55rOV44CCXHJcbiAgICAgKlxyXG4gICAgICog6L+Z5Liq57G75LiN5bqU6K+l5a6e5L6L5YyWXHJcbiAgICAgKiDnlaXliqDkv67mlLnvvIzorqnmiYDmnInlhpnmlrnms5Xpg73lj6/ku6Xov5Tlm57lhpnlhaXlrZfoioLmlbBcclxuICAgICAqL1xyXG4gICAgY2xhc3MgT3V0cHV0U3RyZWFtIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWRcclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiT3V0cHV0U3RyZWFtLmNsb3NlKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWRcclxuICAgICAgICBmbHVzaCgpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiT3V0cHV0U3RyZWFtLmZsdXNoKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWQgLy9GSVhNRTpcclxuICAgICAgICB3cml0ZShiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIk91dHB1dFN0cmVhbS53cml0ZSgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6IG5vdCB1c2VkIC8vbnVtYmVyW11cclxuICAgICAgICB3cml0ZUJ5dGVzKGIsIG9mZiwgbGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIk91dHB1dFN0cmVhbS53cml0ZUJ5dGVzKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWRcclxuICAgICAgICB3cml0ZUNoYXIoYikge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJPdXRwdXRTdHJlYW0ud3JpdGVDaGFyKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWRcclxuICAgICAgICB0aHJvd0Vycm9yKHN0cikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLk91dHB1dFN0cmVhbSA9IE91dHB1dFN0cmVhbTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dHB1dFN0cmVhbS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuUHJpbnRTdHJlYW0gPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBQcmludFN0cmVhbSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIFByaW50U3RyZWFtLmluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGluaXQoKSB7XHJcbiAgICAgICAgICAgIFByaW50U3RyZWFtLk91dHB1dEFyciA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICBQcmludFN0cmVhbS5PdXRwdXRBcnIucHVzaChcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgIHByaW50KHN0cikge1xyXG4gICAgICAgICAgICBQcmludFN0cmVhbS5PdXRwdXRBcnJbUHJpbnRTdHJlYW0uT3V0cHV0QXJyLmxlbmd0aCAtIDFdICs9IHN0cjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgIHByaW50bG4oKSB7XHJcbiAgICAgICAgICAgIFByaW50U3RyZWFtLk91dHB1dEFyci5wdXNoKFwiXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcblwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLlByaW50U3RyZWFtID0gUHJpbnRTdHJlYW07XHJcbiAgICBQcmludFN0cmVhbS5PdXRwdXRBcnIgPSBudWxsO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpbnRTdHJlYW0uanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLlJhbmRvbSA9IHZvaWQgMDtcclxuICAgIGNsYXNzIFJhbmRvbSB7XHJcbiAgICAgICAgbmV4dERvdWJsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRJbnQoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFNlZWQoc2VlZCkge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuUmFuZG9tID0gUmFuZG9tO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmFuZG9tLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5SZWFkZXIgPSB2b2lkIDA7XHJcbiAgICAvKipcclxuICAgICAqXHTnlKjkuo7or7vlj5blrZfnrKbmtYHnmoTmir3osaHnsbvjgIJcclxuICAgICAqXHTlrZDnsbvlv4Xpobvlrp7njrDnmoTmlrnms5Xlj6rmnIkgcmVhZChjaGFyW10sIGludCwgaW50KSDlkowgY2xvc2UoKeOAglxyXG4gICAgICpcdOS9huaYr++8jOWkmuaVsOWtkOexu+WwhumHjeWGmeatpOWkhOWumuS5ieeahOS4gOS6m+aWueazle+8jFxyXG4gICAgICpcdOS7peaPkOS+m+abtOmrmOeahOaViOeOh+WSjC/miJblhbbku5blip/og73jgIJcclxuICAgICAqL1xyXG4gICAgY2xhc3MgUmVhZGVyIHtcclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiUmVhZGVyLmNsb3NlKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFyayhyZWFkYWhlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiUmVhZGVyLm1hcmsoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrU3VwcG9ydGVkKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJSZWFkZXIubWFya1N1cHBvcnRlZCgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZCgpIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiUmVhZGVyLnJlYWQoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTogbm90IHVzZWQgLy9GSVhNRTpudW1iZXJbXVxyXG4gICAgICAgIHJlYWRCeXRlcyhjYnVmKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIlJlYWRlci5yZWFkQnl0ZXMoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZE11bHRpQnl0ZXMoY2J1Ziwgb2ZmLCBsZW4pIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiUmVhZGVyLnJlYWRNdWx0aUJ5dGVzKCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6IG5vdCB1c2VkXHJcbiAgICAgICAgcmVhZHkoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIlJlYWRlci5yZWFkeSgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzZXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIlJlYWRlci5yZXNldCgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6bm90IHVzZWRcclxuICAgICAgICBza2lwKG4pIHtcclxuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiUmVhZGVyLnNraXAoKSBub3QgaW1wbGVtZW50XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5paw5aKeXHJcbiAgICAgICAgdGhyb3dFcnJvcihzdHIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coc3RyKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5SZWFkZXIgPSBSZWFkZXI7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFkZXIuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLlJ1bnRpbWUgPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBSdW50aW1lIHtcclxuICAgICAgICBzdGF0aWMgZ2V0UnVudGltZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJ1bnRpbWUuX2luc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b3RhbE1lbW9yeSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vRklYTUU6XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZyZWVNZW1vcnkoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUnVudGltZS5mcmVlTWVtb3J5KCkgbm90IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5SdW50aW1lID0gUnVudGltZTtcclxuICAgIFJ1bnRpbWUuX2luc3RhbmNlID0gbmV3IFJ1bnRpbWUoKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJ1bnRpbWUuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLlJ1bnRpbWVFeGNlcHRpb24gPSB2b2lkIDA7XHJcbiAgICBjbGFzcyBSdW50aW1lRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cikge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gc3RyO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHN0cikuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6IG5vdCB1c2VkXHJcbiAgICAgICAgZ2V0U3RhY2tUcmFjZSgpIHtcclxuICAgICAgICAgICAgLy90aGlzLl9zdGFja1RyYWNlID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSkuc3RhY2s7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFja1RyYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuUnVudGltZUV4Y2VwdGlvbiA9IFJ1bnRpbWVFeGNlcHRpb247XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SdW50aW1lRXhjZXB0aW9uLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5TdGFjayA9IHZvaWQgMDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhY2sg57G76KGo56S65ZCO6L+b5YWI5Ye677yITElGT++8ieeahOWvueixoeWghuagiOOAglxyXG4gICAgICog5a6D6YCa6L+H5LqU5Liq5pON5L2c5a+557G7IFZlY3RvciDov5vooYzkuobmianlsZUg77yMXHJcbiAgICAgKiDlhYHorrjlsIblkJHph4/op4bkuLrloIbmoIjjgIJcclxuICAgICAqIOWug+aPkOS+m+S6humAmuW4uOeahCBwdXNoIOWSjCBwb3Ag5pON5L2c77yMXHJcbiAgICAgKiDku6Xlj4rlj5bmoIjpobbngrnnmoQgcGVlayDmlrnms5XjgIFcclxuICAgICAqIOa1i+ivleWghuagiOaYr+WQpuS4uuepuueahCBlbXB0eSDmlrnms5XjgIFcclxuICAgICAqIOWcqOWghuagiOS4reafpeaJvumhueW5tuehruWumuWIsOagiOmhtui3neemu+eahCBzZWFyY2gg5pa55rOV44CCXHJcbiAgICAgKiDpppbmrKHliJvlu7rloIbmoIjml7bvvIzlroPkuI3ljIXlkKvmlbDmja7pobnjgIJcclxuICAgICAqXHJcbiAgICAgKiDlnKhKYXZh5LitU3RhY2vnu6fmib9WZWN0b3LvvIzpnIDopoHms6jmhI/ovazmjaLpl67popjjgIJcclxuICAgICAqL1xyXG4gICAgY2xhc3MgU3RhY2sge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcnIgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogIOebuOW9k+S6jnB1c2hcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRFbGVtZW50KG8pIHtcclxuICAgICAgICAgICAgdGhpcy5fYXJyLnB1c2gobyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RFbGVtZW50KCkge1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fYXJyLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vdHJhY2UoXCJsYXN0RWxlbWVudDpcIiwgdGhpcy5fYXJyW2xlbiAtIDFdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJbbGVuIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRklYTUU6bm90IHVzZWRcclxuICAgICAgICBnZXRTaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTpub3QgdXNlZFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiuvue9ruatpOWQkemHj+eahOWkp+Wwj+OAglxyXG4gICAgICAgICAqIF3lpoLmnpzmlrDlpKflsI/lpKfkuo7lvZPliY3lpKflsI/vvIzliJnkvJrlnKjlkJHph4/nmoTmnKvlsL7mt7vliqDnm7jlupTmlbDph4/nmoQgbnVsbCDpobnjgIJcclxuICAgICAgICAgKiDlpoLmnpzmlrDlpKflsI/lsI/kuo7lvZPliY3lpKflsI/vvIxcclxuICAgICAgICAgKiDliJnkuKLlvIPntKLlvJUgbmV3U2l6ZSDlpITlj4rlhbbkuYvlkI7nmoTmiYDmnInpobnjgIJcclxuICAgICAgICAgKi9cclxuICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgc2V0U2l6ZShzaXplKSB7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fYXJyLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHNpemUgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPiBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZSAtIGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fYXJyLnB1c2gobmV3IE9iamVjdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXJyLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcnIucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvcCgpIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX2Fyci5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudEF0KGkpIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX2FycltpXTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLlN0YWNrID0gU3RhY2s7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGFjay5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuU3RyaW5nQnVmZmVyID0gdm9pZCAwO1xyXG4gICAgY2xhc3MgU3RyaW5nQnVmZmVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzdHIpIHtcclxuICAgICAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3N0ciA9IHN0cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lubbkuI3liJvlu7rku7vkvZXlrZfnrKbvvIzlj6rmmK/pooTnlZnnqbrpl7RcclxuICAgICAgICBpbml0KGkpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/kuLvopoHnlKjkuo7muIXnqbrplb/luqbvvIzkuIDoiKzkuLowXHJcbiAgICAgICAgc2V0TGVuZ3RoKGkpIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyID0gdGhpcy5fc3RyLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZ0J1ZmZlci5zZXRMZW5ndGgoKSBlcnJvcjogaSA8IDBcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFwcGVuZChjaCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHIgPSB0aGlzLl9zdHIuY29uY2F0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXBwZW5kU3RyaW5nQnVmZmVyKGJ1Zikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHIgPSB0aGlzLl9zdHIuY29uY2F0KGJ1Zi5fc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXBwZW5kU3RyaW5nKHN0cikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHIgPSB0aGlzLl9zdHIuY29uY2F0KHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOenu+mZpOatpOW6j+WIl+eahOWtkOWtl+espuS4suS4reeahOWtl+espuOAguivpeWtkOWtl+espuS4suS7juaMh+WumueahCBzdGFydCDlpITlvIDlp4vvvIxcclxuICAgICAgICAgKiDkuIDnm7TliLDntKLlvJUgZW5kIC0gMSDlpITnmoTlrZfnrKbvvIzlpoLmnpzkuI3lrZjlnKjov5nnp43lrZfnrKbvvIzliJnkuIDnm7TliLDluo/liJflsL7pg6jjgIJcclxuICAgICAgICAgKiDlpoLmnpwgc3RhcnQg562J5LqOIGVuZO+8jOWImeS4jeWPkeeUn+S7u+S9leabtOaUueOAglxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogZGVsZXRl5ZyoSmF2YeS4reS4jeaYr+WFs+mUruWtl++8jOS9huWcqEFTM+S4reaYr+WFs+mUruWtl1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9kZWxldGUoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RyaW5nQnVmZmVyLl9kZWxldGUoXCIgKyBzdGFydCArIFwiLFwiICsgZW5kICsgXCIpXCIpO1xyXG4gICAgICAgICAgICBpZiAoZW5kID4gdGhpcy5fc3RyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5fc3RyLmxlbmd0aDsgLy9lbmTlj6/og73mmK/kuKrov4flpKfnmoTmlbBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoMCA8PSBzdGFydCAmJiBzdGFydCA8IGVuZCAmJiBlbmQgPD0gdGhpcy5fc3RyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyID0gdGhpcy5fc3RyLnN1YnN0cmluZygwLCBzdGFydCkgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0ci5zdWJzdHJpbmcoZW5kKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nQnVmZmVyLmRlbGV0ZSgpIGVycm9yXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydChhdCwgY2gpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RyID0gdGhpcy5fc3RyLnN1YnN0cmluZygwLCBhdCkgK1xyXG4gICAgICAgICAgICAgICAgU3RyaW5nKGNoKSArXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHIuc3Vic3RyaW5nKGF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0U3RyaW5nQnVmZmVyKGF0LCBidWYpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RyID0gdGhpcy5fc3RyLnN1YnN0cmluZygwLCBhdCkgK1xyXG4gICAgICAgICAgICAgICAgYnVmLl9zdHIgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyLnN1YnN0cmluZyhhdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlbmd0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYXJBdChpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGVDaGFyQXQoaW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGV0ZShpbmRleCwgaW5kZXggKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLlN0cmluZ0J1ZmZlciA9IFN0cmluZ0J1ZmZlcjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ0J1ZmZlci5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vUHJpbnRTdHJlYW1cIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLlN5c3RlbVV0aWwgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBQcmludFN0cmVhbV8xID0gcmVxdWlyZShcIi4vUHJpbnRTdHJlYW1cIik7XHJcbiAgICBjbGFzcyBTeXN0ZW1VdGlsIHtcclxuICAgICAgICBzdGF0aWMgYXJyYXljb3B5KHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHNyYyAhPSBudWxsICYmIGRlc3QgIT0gbnVsbCAmJiBzcmMgaW5zdGFuY2VvZiBBcnJheSAmJiBkZXN0IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZXN0UG9zOyBpIDwgZGVzdFBvcyArIGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtpXSA9IHNyY1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYXJyYXljb3B5OlwiLCBpLCAoc3JjIGFzIEFycmF5KVtpXSk7IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBnYygpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGlkZW50aXR5SGFzaENvZGUob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgZ2V0UmVzb3VyY2VBc1N0cmVhbShzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgY3VycmVudFRpbWVNaWxsaXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuU3lzdGVtVXRpbCA9IFN5c3RlbVV0aWw7XHJcbiAgICBTeXN0ZW1VdGlsLm91dCA9IG5ldyBQcmludFN0cmVhbV8xLlByaW50U3RyZWFtKCk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TeXN0ZW1VdGlsLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5UaW1lWm9uZSA9IHZvaWQgMDtcclxuICAgIGNsYXNzIFRpbWVab25lIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5faWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9pZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRmxhc2joh6rliqjosIPmlbTlpI/ku6Tml7ZcclxuICAgICAgICB1c2VEYXlsaWdodFRpbWUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+iOt+WPluacrOWcsOaXtumXtFxyXG4gICAgICAgIHN0YXRpYyBnZXREZWZhdWx0KCkge1xyXG4gICAgICAgICAgICBpZiAoVGltZVpvbmUudHouX2lkID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBUaW1lWm9uZS50ei5faWQgPSBcImRlZmF1bHRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIFRpbWVab25lLnR6O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+iOt+WPlkdNVOaXtumXtFxyXG4gICAgICAgIHN0YXRpYyBnZXRUaW1lWm9uZShJRCkge1xyXG4gICAgICAgICAgICBpZiAoSUQgIT0gXCJHTVRcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUaW1lWm9uZS5nZXRUaW1lWm9uZSgpOiBub3Qgc3VwcG9ydCBuYW1lXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGltZVpvbmUuZ2V0VGltZVpvbmUoKTogbm90IHN1cHBvcnQgbmFtZVwiKTtcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIFRpbWVab25lLnR6OyAvL0ZJWE1FOlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChUaW1lWm9uZS50ekdNVC5faWQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIFRpbWVab25lLnR6R01ULl9pZCA9IFwiR01UXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBUaW1lWm9uZS50ekdNVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/ml7bljLrlrZfnrKbkuLJcclxuICAgICAgICBnZXRJRCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuVGltZVpvbmUgPSBUaW1lWm9uZTtcclxuICAgIFRpbWVab25lLnR6ID0gbmV3IFRpbWVab25lKCk7XHJcbiAgICBUaW1lWm9uZS50ekdNVCA9IG5ldyBUaW1lWm9uZSgpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZVpvbmUuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCIuLi9qYXZhL051bWJlckZvcm1hdEV4Y2VwdGlvblwiLCBcIi4uL2phdmEvU3lzdGVtVXRpbFwiLCBcIi4vQmFzZUxpYlJlYWRlclwiLCBcIi4vRHVtcGVkSW5wdXRcIiwgXCIuL0x1YVwiLCBcIi4vTHVhSmF2YUNhbGxiYWNrXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5CYXNlTGliID0gdm9pZCAwO1xyXG4gICAgY29uc3QgTnVtYmVyRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vamF2YS9OdW1iZXJGb3JtYXRFeGNlcHRpb25cIik7XHJcbiAgICBjb25zdCBTeXN0ZW1VdGlsXzEgPSByZXF1aXJlKFwiLi4vamF2YS9TeXN0ZW1VdGlsXCIpO1xyXG4gICAgY29uc3QgQmFzZUxpYlJlYWRlcl8xID0gcmVxdWlyZShcIi4vQmFzZUxpYlJlYWRlclwiKTtcclxuICAgIGNvbnN0IER1bXBlZElucHV0XzEgPSByZXF1aXJlKFwiLi9EdW1wZWRJbnB1dFwiKTtcclxuICAgIGNvbnN0IEx1YV8xID0gcmVxdWlyZShcIi4vTHVhXCIpO1xyXG4gICAgY29uc3QgTHVhSmF2YUNhbGxiYWNrXzEgPSByZXF1aXJlKFwiLi9MdWFKYXZhQ2FsbGJhY2tcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvQmFzZUxpYi5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbnMgTHVhJ3MgYmFzZSBsaWJyYXJ5LiAgVGhlIGJhc2UgbGlicmFyeSBpcyBnZW5lcmFsbHlcclxuICAgICAqIGNvbnNpZGVyZWQgZXNzZW50aWFsIGZvciBydW5uaW5nIGFueSBMdWEgcHJvZ3JhbS4gIFRoZSBiYXNlIGxpYnJhcnlcclxuICAgICAqIGNhbiBiZSBvcGVuZWQgdXNpbmcgdGhlIHtAbGluayAjb3Blbn0gbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBCYXNlTGliIGV4dGVuZHMgTHVhSmF2YUNhbGxiYWNrXzEuTHVhSmF2YUNhbGxiYWNrIHtcclxuICAgICAgICAvKiogQ29uc3RydWN0cyBpbnN0YW5jZSwgZmlsbGluZyBpbiB0aGUgJ3doaWNoJyBtZW1iZXIuICovXHJcbiAgICAgICAgY29uc3RydWN0b3Iod2hpY2gpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICogRm9yIHdyYXBwZWQgdGhyZWFkcyBjcmVhdGVkIGJ5IGNvcm91dGluZS53cmFwLCB0aGlzIHJlZmVyZW5jZXMgdGhlXHJcbiAgICAgICAgICAgICogTHVhIHRocmVhZCBvYmplY3QuXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGhyZWFkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy53aGljaCA9IHdoaWNoO1xyXG4gICAgICAgICAgICBCYXNlTGliLk91dHB1dEFyciA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICBCYXNlTGliLk91dHB1dEFyci5wdXNoKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW5zdGFuY2UgY29uc3RydWN0b3IgdXNlZCBieSBjb3JvdXRpbmUud3JhcC4gKi9cclxuICAgICAgICBpbml0KEwpIHtcclxuICAgICAgICAgICAgdGhpcy53aGljaCA9IEJhc2VMaWIuV1JBUF9BVVg7XHJcbiAgICAgICAgICAgIHRoaXMudGhyZWFkID0gTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW1wbGVtZW50cyBhbGwgb2YgdGhlIGZ1bmN0aW9ucyBpbiB0aGUgTHVhIGJhc2UgbGlicmFyeS4gIERvIG5vdFxyXG4gICAgICAgICAqIGNhbGwgZGlyZWN0bHkuXHJcbiAgICAgICAgICogQHBhcmFtIEwgIHRoZSBMdWEgc3RhdGUgaW4gd2hpY2ggdG8gZXhlY3V0ZS5cclxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiByZXR1cm5lZCBwYXJhbWV0ZXJzLCBhcyBwZXIgY29udmVudGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsdWFGdW5jdGlvbihMKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy53aGljaCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLkFTU0VSVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5hc3NlcnRGdW5jdGlvbihMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5DT0xMRUNUR0FSQkFHRTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5jb2xsZWN0Z2FyYmFnZShMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5ET0ZJTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIuZG9maWxlKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLkVSUk9SOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlTGliLmVycm9yKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLkdFVEZFTlY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIuZ2V0ZmVudihMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5HRVRNRVRBVEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIuZ2V0bWV0YXRhYmxlKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLklQQUlSUzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5pcGFpcnMoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuTE9BRDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5sb2FkKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLkxPQURGSUxFOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlTGliLmxvYWRmaWxlKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLkxPQURTVFJJTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIubG9hZHN0cmluZyhMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5ORVhUOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlTGliLm5leHQoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuUEFJUlM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucGFpcnMoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuUENBTEw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucGNhbGwoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuUFJJTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucHJpbnQoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuUkFXRVFVQUw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucmF3ZXF1YWwoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuUkFXR0VUOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlTGliLnJhd2dldChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5SQVdTRVQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucmF3c2V0KEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLlNFTEVDVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5zZWxlY3QoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuU0VURkVOVjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5zZXRmZW52KEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLlNFVE1FVEFUQUJMRTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5zZXRtZXRhdGFibGUoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuVE9OVU1CRVI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIudG9udW1iZXIoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuVE9TVFJJTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIudG9zdHJpbmcoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuVFlQRTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi50eXBlKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLlVOUEFDSzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi51bnBhY2soTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuWFBDQUxMOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlTGliLnhwY2FsbChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5JUEFJUlNfQVVYOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlTGliLmlwYWlyc2F1eChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5QQUlSU19BVVg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucGFpcnNhdXgoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VMaWIuQ1JFQVRFOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlTGliLmNyZWF0ZShMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5SRVNVTUU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucmVzdW1lKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLlJVTk5JTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIucnVubmluZyhMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5TVEFUVVM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIuc3RhdHVzKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlTGliLldSQVA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIud3JhcChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5ZSUVMRDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi55aWVsZChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUxpYi5XUkFQX0FVWDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwYXV4KEwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcGVucyB0aGUgYmFzZSBsaWJyYXJ5IGludG8gdGhlIGdpdmVuIEx1YSBzdGF0ZS4gIFRoaXMgcmVnaXN0ZXJzXHJcbiAgICAgICAgICogdGhlIHN5bWJvbHMgb2YgdGhlIGJhc2UgbGlicmFyeSBpbiB0aGUgZ2xvYmFsIHRhYmxlLlxyXG4gICAgICAgICAqIEBwYXJhbSBMICBUaGUgTHVhIHN0YXRlIGludG8gd2hpY2ggdG8gb3Blbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgb3BlbihMKSB7XHJcbiAgICAgICAgICAgIC8vIHNldCBnbG9iYWwgX0dcclxuICAgICAgICAgICAgTC5zZXRHbG9iYWwoXCJfR1wiLCBMLmdldEdsb2JhbHMoKSk7XHJcbiAgICAgICAgICAgIC8vIHNldCBnbG9iYWwgX1ZFUlNJT05cclxuICAgICAgICAgICAgTC5zZXRHbG9iYWwoXCJfVkVSU0lPTlwiLCBMdWFfMS5MdWEuVkVSU0lPTik7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcImFzc2VydFwiLCBCYXNlTGliLkFTU0VSVCk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcImNvbGxlY3RnYXJiYWdlXCIsIEJhc2VMaWIuQ09MTEVDVEdBUkJBR0UpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJkb2ZpbGVcIiwgQmFzZUxpYi5ET0ZJTEUpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJlcnJvclwiLCBCYXNlTGliLkVSUk9SKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5yKEwsIFwiZ2V0ZmVudlwiLCBCYXNlTGliLkdFVEZFTlYpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJnZXRtZXRhdGFibGVcIiwgQmFzZUxpYi5HRVRNRVRBVEFCTEUpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJpcGFpcnNcIiwgQmFzZUxpYi5JUEFJUlMpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJsb2FkZmlsZVwiLCBCYXNlTGliLkxPQURGSUxFKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5yKEwsIFwibG9hZFwiLCBCYXNlTGliLkxPQUQpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJsb2Fkc3RyaW5nXCIsIEJhc2VMaWIuTE9BRFNUUklORyk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcIm5leHRcIiwgQmFzZUxpYi5ORVhUKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5yKEwsIFwicGFpcnNcIiwgQmFzZUxpYi5QQUlSUyk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInBjYWxsXCIsIEJhc2VMaWIuUENBTEwpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJwcmludFwiLCBCYXNlTGliLlBSSU5UKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5yKEwsIFwicmF3ZXF1YWxcIiwgQmFzZUxpYi5SQVdFUVVBTCk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInJhd2dldFwiLCBCYXNlTGliLlJBV0dFVCk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInJhd3NldFwiLCBCYXNlTGliLlJBV1NFVCk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInNlbGVjdFwiLCBCYXNlTGliLlNFTEVDVCk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInNldGZlbnZcIiwgQmFzZUxpYi5TRVRGRU5WKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5yKEwsIFwic2V0bWV0YXRhYmxlXCIsIEJhc2VMaWIuU0VUTUVUQVRBQkxFKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5yKEwsIFwidG9udW1iZXJcIiwgQmFzZUxpYi5UT05VTUJFUik7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInRvc3RyaW5nXCIsIEJhc2VMaWIuVE9TVFJJTkcpO1xyXG4gICAgICAgICAgICBCYXNlTGliLnIoTCwgXCJ0eXBlXCIsIEJhc2VMaWIuVFlQRSk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInVucGFja1wiLCBCYXNlTGliLlVOUEFDSyk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIucihMLCBcInhwY2FsbFwiLCBCYXNlTGliLlhQQ0FMTCk7XHJcbiAgICAgICAgICAgIEwuX19yZWdpc3RlcihcImNvcm91dGluZVwiKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5jKEwsIFwiY3JlYXRlXCIsIEJhc2VMaWIuQ1JFQVRFKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5jKEwsIFwicmVzdW1lXCIsIEJhc2VMaWIuUkVTVU1FKTtcclxuICAgICAgICAgICAgQmFzZUxpYi5jKEwsIFwicnVubmluZ1wiLCBCYXNlTGliLlJVTk5JTkcpO1xyXG4gICAgICAgICAgICBCYXNlTGliLmMoTCwgXCJzdGF0dXNcIiwgQmFzZUxpYi5TVEFUVVMpO1xyXG4gICAgICAgICAgICBCYXNlTGliLmMoTCwgXCJ3cmFwXCIsIEJhc2VMaWIuV1JBUCk7XHJcbiAgICAgICAgICAgIEJhc2VMaWIuYyhMLCBcInlpZWxkXCIsIEJhc2VMaWIuWUlFTEQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogUmVnaXN0ZXIgYSBmdW5jdGlvbi4gKi9cclxuICAgICAgICBzdGF0aWMgcihMLCBuYW1lLCB3aGljaCkge1xyXG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBCYXNlTGliKHdoaWNoKTtcclxuICAgICAgICAgICAgTC5zZXRHbG9iYWwobmFtZSwgZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBSZWdpc3RlciBhIGZ1bmN0aW9uIGluIHRoZSBjb3JvdXRpbmUgdGFibGUuICovXHJcbiAgICAgICAgc3RhdGljIGMoTCwgbmFtZSwgd2hpY2gpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgQmFzZUxpYih3aGljaCk7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQoTC5nZXRHbG9iYWwoXCJjb3JvdXRpbmVcIiksIG5hbWUsIGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBhc3NlcnQuICA8Y29kZT5hc3NlcnQ8L2NvZGU+IGlzIGEga2V5d29yZCBpbiBzb21lXHJcbiAgICAgICAgICogdmVyc2lvbnMgb2YgSmF2YSwgc28gdGhpcyBmdW5jdGlvbiBoYXMgYSBtYW5nbGVkIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGFzc2VydEZ1bmN0aW9uKEwpIHtcclxuICAgICAgICAgICAgTC5jaGVja0FueSgxKTtcclxuICAgICAgICAgICAgaWYgKCFMLnRvQm9vbGVhbihMLnZhbHVlKDEpKSkge1xyXG4gICAgICAgICAgICAgICAgTC5lcnJvcihMLm9wdFN0cmluZygyLCBcImFzc2VydGlvbiBmYWlsZWQhXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTC5nZXRUb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgY29sbGVjdGdhcmJhZ2UuICovXHJcbiAgICAgICAgc3RhdGljIGNvbGxlY3RnYXJiYWdlKEwpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSBMLmNoZWNrT3B0aW9uKDEsIFwiY29sbGVjdFwiLCBCYXNlTGliLkNHT1BUUyk7XHJcbiAgICAgICAgICAgIHZhciBleCA9IEwub3B0SW50KDIsIDApO1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gTC5nYyhCYXNlTGliLkNHT1BUU05VTVtvXSwgZXgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKEJhc2VMaWIuQ0dPUFRTTlVNW29dKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5HQ0NPVU5UOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBMLmdjKEx1YV8xLkx1YS5HQ0NPVU5UQiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEwucHVzaE51bWJlcihyZXMgKyBiIC8gMTAyNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLkdDU1RFUDpcclxuICAgICAgICAgICAgICAgICAgICBMLnB1c2hCb29sZWFuKHJlcyAhPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoTnVtYmVyKHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgZG9maWxlLiAqL1xyXG4gICAgICAgIHN0YXRpYyBkb2ZpbGUoTCkge1xyXG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBMLm9wdFN0cmluZygxLCBudWxsKTtcclxuICAgICAgICAgICAgdmFyIG4gPSBMLmdldFRvcCgpO1xyXG4gICAgICAgICAgICBpZiAoTC5sb2FkRmlsZShmbmFtZSkgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgTC5lcnJvcihMLnZhbHVlKC0xKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTC5jYWxsKDAsIEx1YV8xLkx1YS5NVUxUUkVUKTtcclxuICAgICAgICAgICAgcmV0dXJuIEwuZ2V0VG9wKCkgLSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBlcnJvci4gKi9cclxuICAgICAgICBzdGF0aWMgZXJyb3IoTCkge1xyXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBMLm9wdEludCgyLCAxKTtcclxuICAgICAgICAgICAgTC5zZXRUb3AoMSk7XHJcbiAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuaXNTdHJpbmcoTC52YWx1ZSgxKSkgJiYgbGV2ZWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBMLmluc2VydChMLndoZXJlKGxldmVsKSwgMSk7XHJcbiAgICAgICAgICAgICAgICBMLmNvbmNhdCgyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLmVycm9yKEwudmFsdWUoMSkpO1xyXG4gICAgICAgICAgICAvLyBOT1RSRUFDSEVEXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSGVscGVyIGZvciBnZXRmZW52IGFuZCBzZXRmZW52LiAqL1xyXG4gICAgICAgIHN0YXRpYyBnZXRmdW5jKEwpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSBMLnZhbHVlKDEpO1xyXG4gICAgICAgICAgICBpZiAoTHVhXzEuTHVhLmlzRnVuY3Rpb24obykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxldmVsID0gTC5vcHRJbnQoMSwgMSk7XHJcbiAgICAgICAgICAgICAgICBMLmFyZ0NoZWNrKGxldmVsID49IDAsIDEsIFwibGV2ZWwgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXIgPSBMLmdldFN0YWNrKGxldmVsKTtcclxuICAgICAgICAgICAgICAgIGlmIChhciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5hcmdFcnJvcigxLCBcImludmFsaWQgbGV2ZWxcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBMLmdldEluZm8oXCJmXCIsIGFyKTtcclxuICAgICAgICAgICAgICAgIG8gPSBMLnZhbHVlKC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuaXNOaWwobykpIHtcclxuICAgICAgICAgICAgICAgICAgICBMLmVycm9yKFwibm8gZnVuY3Rpb24gZW52aXJvbm1lbnQgZm9yIHRhaWwgY2FsbCBhdCBsZXZlbCBcIiArIGxldmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEwucG9wKDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgZ2V0ZmVudi4gKi9cclxuICAgICAgICBzdGF0aWMgZ2V0ZmVudihMKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gQmFzZUxpYi5nZXRmdW5jKEwpO1xyXG4gICAgICAgICAgICBpZiAoTHVhXzEuTHVhLmlzSmF2YUZ1bmN0aW9uKG8pKSB7XHJcbiAgICAgICAgICAgICAgICBMLnB1c2hPYmplY3QoTC5nZXRHbG9iYWxzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBvO1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoT2JqZWN0KGYuZW52KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgZ2V0bWV0YXRhYmxlLiAqL1xyXG4gICAgICAgIHN0YXRpYyBnZXRtZXRhdGFibGUoTCkge1xyXG4gICAgICAgICAgICBMLmNoZWNrQW55KDEpO1xyXG4gICAgICAgICAgICB2YXIgbXQgPSBMLmdldE1ldGF0YWJsZShMLnZhbHVlKDEpKTtcclxuICAgICAgICAgICAgaWYgKG10ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaE5pbCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByb3RlY3RlZG10ID0gTC5nZXRNZXRhZmllbGQoTC52YWx1ZSgxKSwgXCJfX21ldGF0YWJsZVwiKTtcclxuICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5pc05pbChwcm90ZWN0ZWRtdCkpIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaE9iamVjdChtdCk7IC8vIHJldHVybiBtZXRhdGFibGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaE9iamVjdChwcm90ZWN0ZWRtdCk7IC8vIHJldHVybiBfX21ldGF0YWJsZSBmaWVsZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBsb2FkLiAqL1xyXG4gICAgICAgIHN0YXRpYyBsb2FkKEwpIHtcclxuICAgICAgICAgICAgdmFyIGNuYW1lID0gTC5vcHRTdHJpbmcoMiwgXCI9KGxvYWQpXCIpO1xyXG4gICAgICAgICAgICBMLmNoZWNrVHlwZSgxLCBMdWFfMS5MdWEuVEZVTkNUSU9OKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBuZXcgQmFzZUxpYlJlYWRlcl8xLkJhc2VMaWJSZWFkZXIoTCwgTC52YWx1ZSgxKSk7XHJcbiAgICAgICAgICAgIHZhciBzdGF0dXM7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9IEwuX19sb2FkKHIsIGNuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIubG9hZF9hdXgoTCwgc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgbG9hZGZpbGUuICovXHJcbiAgICAgICAgc3RhdGljIGxvYWRmaWxlKEwpIHtcclxuICAgICAgICAgICAgdmFyIGZuYW1lID0gTC5vcHRTdHJpbmcoMSwgbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBCYXNlTGliLmxvYWRfYXV4KEwsIEwubG9hZEZpbGUoZm5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgbG9hZHN0cmluZy4gKi9cclxuICAgICAgICBzdGF0aWMgbG9hZHN0cmluZyhMKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgdmFyIGNodW5rbmFtZSA9IEwub3B0U3RyaW5nKDIsIHMpO1xyXG4gICAgICAgICAgICBpZiAocy5zdWJzdHIoMCwgMSkgPT0gXCIweDFCXCIpIC8vXCJcXDAzM1wiKVxyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gXCJiaW5hcnlcIiBkdW1wZWQgaW50byBzdHJpbmcgdXNpbmcgc3RyaW5nLmR1bXAuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQmFzZUxpYi5sb2FkX2F1eChMLCBMLmxvYWQobmV3IER1bXBlZElucHV0XzEuRHVtcGVkSW5wdXQocyksIGNodW5rbmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VMaWIubG9hZF9hdXgoTCwgTC5sb2FkU3RyaW5nKHMsIGNodW5rbmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBsb2FkX2F1eChMLCBzdGF0dXMpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSAwKSAvLyBPSz9cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgTC5pbnNlcnQoTHVhXzEuTHVhLk5JTCwgLTEpOyAvLyBwdXQgYmVmb3JlIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAyOyAvLyByZXR1cm4gbmlsIHBsdXMgZXJyb3IgbWVzc2FnZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIG5leHQuICovXHJcbiAgICAgICAgc3RhdGljIG5leHQoTCkge1xyXG4gICAgICAgICAgICBMLmNoZWNrVHlwZSgxLCBMdWFfMS5MdWEuVFRBQkxFKTtcclxuICAgICAgICAgICAgTC5zZXRUb3AoMik7IC8vIENyZWF0ZSBhIDJuZCBhcmd1bWVudCBpcyB0aGVyZSBpc24ndCBvbmVcclxuICAgICAgICAgICAgaWYgKEwubmV4dCgxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTC5wdXNoT2JqZWN0KEx1YV8xLkx1YS5OSUwpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgaXBhaXJzLiAqL1xyXG4gICAgICAgIHN0YXRpYyBpcGFpcnMoTCkge1xyXG4gICAgICAgICAgICBMLmNoZWNrVHlwZSgxLCBMdWFfMS5MdWEuVFRBQkxFKTtcclxuICAgICAgICAgICAgTC5wdXNoT2JqZWN0KEJhc2VMaWIuSVBBSVJTX0FVWF9GVU4pO1xyXG4gICAgICAgICAgICBMLnB1c2hWYWx1ZSgxKTtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEdlbmVyYXRvciBmb3IgaXBhaXJzLiAqL1xyXG4gICAgICAgIHN0YXRpYyBpcGFpcnNhdXgoTCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IEwuY2hlY2tJbnQoMik7XHJcbiAgICAgICAgICAgIEwuY2hlY2tUeXBlKDEsIEx1YV8xLkx1YS5UVEFCTEUpO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIHZhciB2ID0gTHVhXzEuTHVhLnJhd0dldEkoTC52YWx1ZSgxKSwgaSk7XHJcbiAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuaXNOaWwodikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihpKTtcclxuICAgICAgICAgICAgTC5wdXNoT2JqZWN0KHYpO1xyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgcGFpcnMuICBQVUMtUmlvIHVzZXMgXCJuZXh0XCIgYXMgdGhlIGdlbmVyYXRvciBmb3IgcGFpcnMuXHJcbiAgICAgICAgICogSmlsbCBkb2Vzbid0IGRvIHRoYXQgYmVjYXVzZSBpdCB3b3VsZCBiZSB3YXkgdG9vIHNsb3cuICBXZSB1c2UgdGhlXHJcbiAgICAgICAgICoge0BsaW5rIGphdmEudXRpbC5FbnVtZXJhdGlvbn0gcmV0dXJuZWQgZnJvbVxyXG4gICAgICAgICAqIHtAbGluayBqYXZhLnV0aWwuSGFzaHRhYmxlI2tleXN9LiAgVGhlIHtAbGluayAjcGFpcnNhdXh9IG1ldGhvZFxyXG4gICAgICAgICAqIGltcGxlbWVudHMgdGhlIHN0ZXAtYnktc3RlcCBpdGVyYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIHBhaXJzKEwpIHtcclxuICAgICAgICAgICAgTC5jaGVja1R5cGUoMSwgTHVhXzEuTHVhLlRUQUJMRSk7XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChCYXNlTGliLlBBSVJTX0FVWF9GVU4pOyAvLyByZXR1cm4gZ2VuZXJhdG9yLFxyXG4gICAgICAgICAgICB2YXIgdCA9IEwudmFsdWUoMSk7XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChbdCwgdC5rZXlzKCldKTsgLy9UT0RPOiAgIFx0XHRcdFx0IC8vIHN0YXRlLFxyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3QoTHVhXzEuTHVhLk5JTCk7IC8vIGFuZCBpbml0aWFsIHZhbHVlLlxyXG4gICAgICAgICAgICByZXR1cm4gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEdlbmVyYXRvciBmb3IgcGFpcnMuICBUaGlzIGV4cGVjdHMgYSA8dmFyPnN0YXRlPC92YXI+IGFuZFxyXG4gICAgICAgICAqIDx2YXI+dmFyPC92YXI+IGFzIChMdWEpIGFyZ3VtZW50cy5cclxuICAgICAgICAgKiBUaGUgc3RhdGUgaXMgc2V0dXAgYnkge0BsaW5rICNwYWlyc30gYW5kIGlzIGFcclxuICAgICAgICAgKiBwYWlyIG9mIHtMdWFUYWJsZSwgRW51bWVyYXRpb259IHN0b3JlZCBpbiBhIDItZWxlbWVudCBhcnJheS4gIFRoZVxyXG4gICAgICAgICAqIDx2YXI+dmFyPC92YXI+IGlzIG5vdCB1c2VkLiAgVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgUFVDLVJpb1xyXG4gICAgICAgICAqIGltcGxlbWVudGF0aW9uLCB3aGVyZSB0aGUgc3RhdGUgaXMgdGhlIHRhYmxlLCBhbmQgdGhlIHZhciBpcyB1c2VkXHJcbiAgICAgICAgICogdG8gZ2VuZXJhdGVkIHRoZSBuZXh0IGtleSBpbiBzZXF1ZW5jZS4gIFRoZSBpbXBsZW1lbnRhdGlvbiwgb2ZcclxuICAgICAgICAgKiBwYWlycyBhbmQgcGFpcnNhdXgsIGhhcyBubyBjb250cm9sIG92ZXIgPHZhcj52YXI8L3Zhcj4sICBMdWEnc1xyXG4gICAgICAgICAqIHNlbWFudGljcyBvZiA8Y29kZT5mb3I8L2NvZGU+IGZvcmNlIGl0IHRvIGJlIHRoZSBwcmV2aW91cyByZXN1bHRcclxuICAgICAgICAgKiByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiAgSW4gSmlsbCB0aGlzIHZhbHVlIGlzIG5vdCBzdWl0YWJsZSB0b1xyXG4gICAgICAgICAqIHVzZSBmb3IgZW51bWVyYXRpb24sIHdoaWNoIGlzIHdoeSBpdCBpc24ndCB1c2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBwYWlyc2F1eChMKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gTC52YWx1ZSgxKTsgLy8oT2JqZWN0W10pXHJcbiAgICAgICAgICAgIHZhciB0ID0gYVswXTtcclxuICAgICAgICAgICAgdmFyIGUgPSBhWzFdO1xyXG4gICAgICAgICAgICBpZiAoIWUuaGFzTW9yZUVsZW1lbnRzKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBlLm5leHRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChrZXkpO1xyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3QodC5nZXRsdWEoa2V5KSk7XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBwY2FsbC4gKi9cclxuICAgICAgICBzdGF0aWMgcGNhbGwoTCkge1xyXG4gICAgICAgICAgICBMLmNoZWNrQW55KDEpO1xyXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gTC5wY2FsbChMLmdldFRvcCgpIC0gMSwgTHVhXzEuTHVhLk1VTFRSRVQsIG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IChzdGF0dXMgPT0gMCk7XHJcbiAgICAgICAgICAgIEwuaW5zZXJ0KEx1YV8xLkx1YS52YWx1ZU9mQm9vbGVhbihiKSwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBMLmdldFRvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBwcmludC4gKi9cclxuICAgICAgICBzdGF0aWMgcHJpbnQoTCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IEwuZ2V0VG9wKCk7XHJcbiAgICAgICAgICAgIHZhciB0b3N0cmluZyA9IEwuZ2V0R2xvYmFsKFwidG9zdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoT2JqZWN0KHRvc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIEwucHVzaFZhbHVlKGkpO1xyXG4gICAgICAgICAgICAgICAgTC5jYWxsKDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBMLnRvU3RyaW5nXyhMLnZhbHVlKC0xKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEwuZXJyb3IoXCIndG9zdHJpbmcnIG11c3QgcmV0dXJuIGEgc3RyaW5nIHRvICdwcmludCdcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLk91dHB1dEFyclt0aGlzLk91dHB1dEFyci5sZW5ndGggLSAxXSArPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuT1VULnByaW50KCdcXHQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuT3V0cHV0QXJyW3RoaXMuT3V0cHV0QXJyLmxlbmd0aCAtIDFdICs9IHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLk9VVC5wcmludChzKTtcclxuICAgICAgICAgICAgICAgIEwucG9wKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuT3V0cHV0QXJyLnB1c2goXCJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuT1VULnByaW50bG4oKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHJhd2VxdWFsLiAqL1xyXG4gICAgICAgIHN0YXRpYyByYXdlcXVhbChMKSB7XHJcbiAgICAgICAgICAgIEwuY2hlY2tBbnkoMSk7XHJcbiAgICAgICAgICAgIEwuY2hlY2tBbnkoMik7XHJcbiAgICAgICAgICAgIEwucHVzaEJvb2xlYW4oTHVhXzEuTHVhLnJhd0VxdWFsKEwudmFsdWUoMSksIEwudmFsdWUoMikpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHJhd2dldC4gKi9cclxuICAgICAgICBzdGF0aWMgcmF3Z2V0KEwpIHtcclxuICAgICAgICAgICAgTC5jaGVja1R5cGUoMSwgTHVhXzEuTHVhLlRUQUJMRSk7XHJcbiAgICAgICAgICAgIEwuY2hlY2tBbnkoMik7XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChMdWFfMS5MdWEucmF3R2V0KEwudmFsdWUoMSksIEwudmFsdWUoMikpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHJhd3NldC4gKi9cclxuICAgICAgICBzdGF0aWMgcmF3c2V0KEwpIHtcclxuICAgICAgICAgICAgTC5jaGVja1R5cGUoMSwgTHVhXzEuTHVhLlRUQUJMRSk7XHJcbiAgICAgICAgICAgIEwuY2hlY2tBbnkoMik7XHJcbiAgICAgICAgICAgIEwuY2hlY2tBbnkoMyk7XHJcbiAgICAgICAgICAgIEwucmF3U2V0KEwudmFsdWUoMSksIEwudmFsdWUoMiksIEwudmFsdWUoMykpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgc2VsZWN0LiAqL1xyXG4gICAgICAgIHN0YXRpYyBzZWxlY3QoTCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IEwuZ2V0VG9wKCk7XHJcbiAgICAgICAgICAgIGlmIChMLnR5cGUoMSkgPT0gTHVhXzEuTHVhLlRTVFJJTkcgJiYgXCIjXCIgPT0gTC50b1N0cmluZ18oTC52YWx1ZSgxKSkpIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaE51bWJlcihuIC0gMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IEwuY2hlY2tJbnQoMSk7XHJcbiAgICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaSA9IG4gKyBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPiBuKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLmFyZ0NoZWNrKDEgPD0gaSwgMSwgXCJpbmRleCBvdXQgb2YgcmFuZ2VcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBuIC0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgc2V0ZmVudi4gKi9cclxuICAgICAgICBzdGF0aWMgc2V0ZmVudihMKSB7XHJcbiAgICAgICAgICAgIEwuY2hlY2tUeXBlKDIsIEx1YV8xLkx1YS5UVEFCTEUpO1xyXG4gICAgICAgICAgICB2YXIgbyA9IEJhc2VMaWIuZ2V0ZnVuYyhMKTtcclxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gTC52YWx1ZSgxKTtcclxuICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5pc051bWJlcihmaXJzdCkgJiYgTC50b051bWJlcihmaXJzdCkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gOnRvZG86IGNoYW5nZSBlbnZpcm9ubWVudCBvZiBjdXJyZW50IHRocmVhZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEx1YV8xLkx1YS5pc0phdmFGdW5jdGlvbihvKSB8fCAhTC5zZXRGZW52KG8sIEwudmFsdWUoMikpKSB7XHJcbiAgICAgICAgICAgICAgICBMLmVycm9yKFwiJ3NldGZlbnYnIGNhbm5vdCBjaGFuZ2UgZW52aXJvbm1lbnQgb2YgZ2l2ZW4gb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChvKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHNldG1ldGF0YWJsZS4gKi9cclxuICAgICAgICBzdGF0aWMgc2V0bWV0YXRhYmxlKEwpIHtcclxuICAgICAgICAgICAgTC5jaGVja1R5cGUoMSwgTHVhXzEuTHVhLlRUQUJMRSk7XHJcbiAgICAgICAgICAgIHZhciB0ID0gTC50eXBlKDIpO1xyXG4gICAgICAgICAgICBMLmFyZ0NoZWNrKHQgPT0gTHVhXzEuTHVhLlROSUwgfHwgdCA9PSBMdWFfMS5MdWEuVFRBQkxFLCAyLCBcIm5pbCBvciB0YWJsZSBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgaWYgKCFMdWFfMS5MdWEuaXNOaWwoTC5nZXRNZXRhZmllbGQoTC52YWx1ZSgxKSwgXCJfX21ldGF0YWJsZVwiKSkpIHtcclxuICAgICAgICAgICAgICAgIEwuZXJyb3IoXCJjYW5ub3QgY2hhbmdlIGEgcHJvdGVjdGVkIG1ldGF0YWJsZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLnNldE1ldGF0YWJsZShMLnZhbHVlKDEpLCBMLnZhbHVlKDIpKTtcclxuICAgICAgICAgICAgTC5zZXRUb3AoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyB0b251bWJlci4gKi9cclxuICAgICAgICBzdGF0aWMgdG9udW1iZXIoTCkge1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IEwub3B0SW50KDIsIDEwKTtcclxuICAgICAgICAgICAgaWYgKGJhc2UgPT0gMTApIC8vIHN0YW5kYXJkIGNvbnZlcnNpb25cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEwuY2hlY2tBbnkoMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbyA9IEwudmFsdWUoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhXzEuTHVhLmlzTnVtYmVyKG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoTnVtYmVyKEwudG9OdW1iZXIobykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBMLmNoZWNrU3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgTC5hcmdDaGVjaygyIDw9IGJhc2UgJiYgYmFzZSA8PSAzNiwgMiwgXCJiYXNlIG91dCBvZiByYW5nZVwiKTtcclxuICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBjb25zaWRlciBzdHJpcHBpbmcgc3BhY2UgYW5kIHNoYXJpbmcgc29tZSBjb2RlIHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIEx1YS52bVRvc3RyaW5nXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gcGFyc2VJbnQocyk7IC8vSW50ZWdlci5wYXJzZUludChzLCBiYXNlKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICAgICAgICAgIEwucHVzaE51bWJlcihpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlXyBpbnN0YW5jZW9mIE51bWJlckZvcm1hdEV4Y2VwdGlvbl8xLk51bWJlckZvcm1hdEV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlXy5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChMdWFfMS5MdWEuTklMKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHRvc3RyaW5nLiAqL1xyXG4gICAgICAgIHN0YXRpYyB0b3N0cmluZyhMKSB7XHJcbiAgICAgICAgICAgIEwuY2hlY2tBbnkoMSk7XHJcbiAgICAgICAgICAgIHZhciBvID0gTC52YWx1ZSgxKTtcclxuICAgICAgICAgICAgaWYgKEwuY2FsbE1ldGEoMSwgXCJfX3Rvc3RyaW5nXCIpKSAvLyBpcyB0aGVyZSBhIG1ldGFmaWVsZD9cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxOyAvLyB1c2UgaXRzIHZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChMLnR5cGUoMSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLlROVU1CRVI6XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoU3RyaW5nKEwudG9TdHJpbmdfKG8pKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLlRTVFJJTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoT2JqZWN0KG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuVEJPT0xFQU46XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEwudG9Cb29sZWFuKG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEwucHVzaExpdGVyYWwoXCJ0cnVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTC5wdXNoTGl0ZXJhbChcImZhbHNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLlROSUw6XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoTGl0ZXJhbChcIm5pbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoU3RyaW5nKG8udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHR5cGUuICovXHJcbiAgICAgICAgc3RhdGljIHR5cGUoTCkge1xyXG4gICAgICAgICAgICBMLmNoZWNrQW55KDEpO1xyXG4gICAgICAgICAgICBMLnB1c2hTdHJpbmcoTC50eXBlTmFtZU9mSW5kZXgoMSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgdW5wYWNrLiAqL1xyXG4gICAgICAgIHN0YXRpYyB1bnBhY2soTCkge1xyXG4gICAgICAgICAgICBMLmNoZWNrVHlwZSgxLCBMdWFfMS5MdWEuVFRBQkxFKTtcclxuICAgICAgICAgICAgdmFyIHQgPSBMLnZhbHVlKDEpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IEwub3B0SW50KDIsIDEpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IEwub3B0SW50KDMsIHQuZ2V0bigpKTtcclxuICAgICAgICAgICAgdmFyIG4gPSBlIC0gaSArIDE7IC8vIG51bWJlciBvZiBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAobiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDsgLy8gZW1wdHkgcmFuZ2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpIGFscmVhZHkgaW5pdGlhbGlzZWQgdG8gc3RhcnQgaW5kZXgsIHdoaWNoIGlzbid0IG5lY2Vzc2FyaWx5IDFcclxuICAgICAgICAgICAgZm9yICg7IGkgPD0gZTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBMLnB1c2hPYmplY3QodC5nZXRudW0oaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyB4cGNhbGwuICovXHJcbiAgICAgICAgc3RhdGljIHhwY2FsbChMKSB7XHJcbiAgICAgICAgICAgIEwuY2hlY2tBbnkoMik7XHJcbiAgICAgICAgICAgIHZhciBlcnJmdW5jID0gTC52YWx1ZSgyKTtcclxuICAgICAgICAgICAgTC5zZXRUb3AoMSk7IC8vIHJlbW92ZSBlcnJvciBmdW5jdGlvbiBmcm9tIHN0YWNrXHJcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBMLnBjYWxsKDAsIEx1YV8xLkx1YS5NVUxUUkVULCBlcnJmdW5jKTtcclxuICAgICAgICAgICAgTC5pbnNlcnQoTHVhXzEuTHVhLnZhbHVlT2ZCb29sZWFuKHN0YXR1cyA9PSAwKSwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBMLmdldFRvcCgpOyAvLyByZXR1cm4gc3RhdHVzICsgYWxsIHJlc3VsdHNcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgY29yb3V0aW5lLmNyZWF0ZS4gKi9cclxuICAgICAgICBzdGF0aWMgY3JlYXRlKEwpIHtcclxuICAgICAgICAgICAgdmFyIE5MID0gTC5uZXdUaHJlYWQoKTtcclxuICAgICAgICAgICAgdmFyIGZhc28gPSBMLnZhbHVlKDEpO1xyXG4gICAgICAgICAgICBMLmFyZ0NoZWNrKEx1YV8xLkx1YS5pc0Z1bmN0aW9uKGZhc28pICYmICFMdWFfMS5MdWEuaXNKYXZhRnVuY3Rpb24oZmFzbyksIDEsIFwiTHVhIGZ1bmN0aW9uIGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICBMLnNldFRvcCgxKTsgLy8gZnVuY3Rpb24gaXMgYXQgdG9wXHJcbiAgICAgICAgICAgIEwueG1vdmUoTkwsIDEpOyAvLyBtb3ZlIGZ1bmN0aW9uIGZyb20gTCB0byBOTFxyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3QoTkwpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgY29yb3V0aW5lLnJlc3VtZS4gKi9cclxuICAgICAgICBzdGF0aWMgcmVzdW1lKEwpIHtcclxuICAgICAgICAgICAgdmFyIGNvID0gTC50b1RocmVhZChMLnZhbHVlKDEpKTtcclxuICAgICAgICAgICAgTC5hcmdDaGVjayhjbyAhPSBudWxsLCAxLCBcImNvcm91dGluZSBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBCYXNlTGliLmF1eHJlc3VtZShMLCBjbywgTC5nZXRUb3AoKSAtIDEpO1xyXG4gICAgICAgICAgICBpZiAociA8IDApIHtcclxuICAgICAgICAgICAgICAgIEwuaW5zZXJ0KEx1YV8xLkx1YS52YWx1ZU9mQm9vbGVhbihmYWxzZSksIC0xKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyOyAvLyByZXR1cm4gZmFsc2UgKyBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTC5pbnNlcnQoTHVhXzEuTHVhLnZhbHVlT2ZCb29sZWFuKHRydWUpLCBMLmdldFRvcCgpIC0gKHIgLSAxKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByICsgMTsgLy8gcmV0dXJuIHRydWUgKyAncmVzdW1lJyByZXR1cm5zXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIGNvcm91dGluZS5ydW5uaW5nLiAqL1xyXG4gICAgICAgIHN0YXRpYyBydW5uaW5nKEwpIHtcclxuICAgICAgICAgICAgaWYgKEwuaXNNYWluKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBtYWluIHRocmVhZCBpcyBub3QgYSBjb3JvdXRpbmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3QoTCk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBjb3JvdXRpbmUuc3RhdHVzLiAqL1xyXG4gICAgICAgIHN0YXRpYyBzdGF0dXMoTCkge1xyXG4gICAgICAgICAgICB2YXIgY28gPSBMLnRvVGhyZWFkKEwudmFsdWUoMSkpO1xyXG4gICAgICAgICAgICBMLmFyZ0NoZWNrKGNvICE9IG51bGwsIDEsIFwiY29yb3V0aW5lIGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICBpZiAoTCA9PSBjbykge1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoTGl0ZXJhbChcInJ1bm5pbmdcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvLnN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLllJRUxEOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMLnB1c2hMaXRlcmFsKFwic3VzcGVuZGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhciA9IGNvLmdldFN0YWNrKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyICE9IG51bGwpIC8vIGRvZXMgaXQgaGF2ZSBmcmFtZXM/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwucHVzaExpdGVyYWwoXCJub3JtYWxcIik7IC8vIGl0IGlzIHJ1bm5pbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvLmdldFRvcCgpID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMLnB1c2hMaXRlcmFsKFwiZGVhZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwucHVzaExpdGVyYWwoXCJzdXNwZW5kZWRcIik7IC8vIGluaXRpYWwgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAvLyBzb21lIGVycm9yIG9jY3VyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgTC5wdXNoTGl0ZXJhbChcImRlYWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIGNvcm91dGluZS53cmFwLiAqL1xyXG4gICAgICAgIHN0YXRpYyB3cmFwKEwpIHtcclxuICAgICAgICAgICAgQmFzZUxpYi5jcmVhdGUoTCk7XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChCYXNlTGliLndyYXBpdChMLnRvVGhyZWFkKEwudmFsdWUoLTEpKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEhlbHBlciBmb3Igd3JhcC4gIFJldHVybnMgYSBMdWFKYXZhQ2FsbGJhY2sgdGhhdCBoYXMgYWNjZXNzIHRvIHRoZVxyXG4gICAgICAgICAqIEx1YSB0aHJlYWQuXHJcbiAgICAgICAgICogQHBhcmFtIEwgdGhlIEx1YSB0aHJlYWQgdG8gYmUgd3JhcHBlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgd3JhcGl0KEwpIHtcclxuICAgICAgICAgICAgdmFyIGxpYiA9IG5ldyBCYXNlTGliKDApO1xyXG4gICAgICAgICAgICBsaWIuaW5pdChMKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxpYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEhlbHBlciBmb3Igd3JhcC4gIFRoaXMgaW1wbGVtZW50cyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgd3JhcC4gKi9cclxuICAgICAgICB3cmFwYXV4KEwpIHtcclxuICAgICAgICAgICAgdmFyIGNvID0gdGhpcy50aHJlYWQ7XHJcbiAgICAgICAgICAgIHZhciByID0gQmFzZUxpYi5hdXhyZXN1bWUoTCwgY28sIEwuZ2V0VG9wKCkpO1xyXG4gICAgICAgICAgICBpZiAociA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuaXNTdHJpbmcoTC52YWx1ZSgtMSkpKSAvLyBlcnJvciBvYmplY3QgaXMgYSBzdHJpbmc/XHJcbiAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gTC53aGVyZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBMLmluc2VydCh3LCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5jb25jYXQoMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBMLmVycm9yKEwudmFsdWUoLTEpKTsgLy8gcHJvcGFnYXRlIGVycm9yXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBhdXhyZXN1bWUoTCwgY28sIG5hcmcpIHtcclxuICAgICAgICAgICAgLy8gaWYgKCFjby5jaGVja1N0YWNrLi4uXHJcbiAgICAgICAgICAgIGlmIChjby5zdGF0dXMgPT0gMCAmJiBjby5nZXRUb3AoKSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBMLnB1c2hMaXRlcmFsKFwiY2Fubm90IHJlc3VtZSBkZWFkIGNvcm91dGluZVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTsgLy8gZXJyb3IgZmxhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLnhtb3ZlKGNvLCBuYXJnKTtcclxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGNvLnJlc3VtZShuYXJnKTtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSAwIHx8IHN0YXR1cyA9PSBMdWFfMS5MdWEuWUlFTEQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBucmVzID0gY28uZ2V0VG9wKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoIUwuY2hlY2tTdGFjay4uLlxyXG4gICAgICAgICAgICAgICAgY28ueG1vdmUoTCwgbnJlcyk7IC8vIG1vdmUgeWllbGRlZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiBucmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvLnhtb3ZlKEwsIDEpOyAvLyBtb3ZlIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgICAgcmV0dXJuIC0xOyAvLyBlcnJvciBmbGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBjb3JvdXRpbmUueWllbGQuICovXHJcbiAgICAgICAgc3RhdGljIHlpZWxkKEwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEwueWllbGQoTC5nZXRUb3AoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5CYXNlTGliID0gQmFzZUxpYjtcclxuICAgIC8vIDp0b2RvOiBjb25zaWRlciBtYWtpbmcgdGhlIGVudW1zIGNvbnRpZ3VvdXMgc28gdGhhdCB0aGUgY29tcGlsZXJcclxuICAgIC8vIHVzZXMgdGhlIGNvbXBhY3QgYW5kIGZhc3RlciBmb3JtIG9mIHN3aXRjaC5cclxuICAgIC8vIEVhY2ggZnVuY3Rpb24gaW4gdGhlIGJhc2UgbGlicmFyeSBjb3JyZXNwb25kcyB0byBhbiBpbnN0YW5jZSBvZlxyXG4gICAgLy8gdGhpcyBjbGFzcyB3aGljaCBpcyBhc3NvY2lhdGVkICh0aGUgJ3doaWNoJyBtZW1iZXIpIHdpdGggYW4gaW50ZWdlclxyXG4gICAgLy8gd2hpY2ggaXMgdW5pcXVlIHdpdGhpbiB0aGlzIGNsYXNzLiAgVGhleSBhcmUgdGFrZW4gZnJvbSB0aGUgZm9sbG93aW5nXHJcbiAgICAvLyBzZXQuXHJcbiAgICBCYXNlTGliLkFTU0VSVCA9IDE7XHJcbiAgICBCYXNlTGliLkNPTExFQ1RHQVJCQUdFID0gMjtcclxuICAgIEJhc2VMaWIuRE9GSUxFID0gMztcclxuICAgIEJhc2VMaWIuRVJST1IgPSA0O1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgY29uc3QgR0NJTkZPOmludCA9IDU7XHJcbiAgICBCYXNlTGliLkdFVEZFTlYgPSA2O1xyXG4gICAgQmFzZUxpYi5HRVRNRVRBVEFCTEUgPSA3O1xyXG4gICAgQmFzZUxpYi5MT0FERklMRSA9IDg7XHJcbiAgICBCYXNlTGliLkxPQUQgPSA5O1xyXG4gICAgQmFzZUxpYi5MT0FEU1RSSU5HID0gMTA7XHJcbiAgICBCYXNlTGliLk5FWFQgPSAxMTtcclxuICAgIEJhc2VMaWIuUENBTEwgPSAxMjtcclxuICAgIEJhc2VMaWIuUFJJTlQgPSAxMztcclxuICAgIEJhc2VMaWIuUkFXRVFVQUwgPSAxNDtcclxuICAgIEJhc2VMaWIuUkFXR0VUID0gMTU7XHJcbiAgICBCYXNlTGliLlJBV1NFVCA9IDE2O1xyXG4gICAgQmFzZUxpYi5TRUxFQ1QgPSAxNztcclxuICAgIEJhc2VMaWIuU0VURkVOViA9IDE4O1xyXG4gICAgQmFzZUxpYi5TRVRNRVRBVEFCTEUgPSAxOTtcclxuICAgIEJhc2VMaWIuVE9OVU1CRVIgPSAyMDtcclxuICAgIEJhc2VMaWIuVE9TVFJJTkcgPSAyMTtcclxuICAgIEJhc2VMaWIuVFlQRSA9IDIyO1xyXG4gICAgQmFzZUxpYi5VTlBBQ0sgPSAyMztcclxuICAgIEJhc2VMaWIuWFBDQUxMID0gMjQ7XHJcbiAgICBCYXNlTGliLklQQUlSUyA9IDI1O1xyXG4gICAgQmFzZUxpYi5QQUlSUyA9IDI2O1xyXG4gICAgQmFzZUxpYi5JUEFJUlNfQVVYID0gMjc7XHJcbiAgICBCYXNlTGliLlBBSVJTX0FVWCA9IDI4O1xyXG4gICAgLy8gVGhlIGNvcm91dGluZSBmdW5jdGlvbnMgKHdoaWNoIHJlc2lkZSBpbiB0aGUgdGFibGUgXCJjb3JvdXRpbmVcIikgYXJlIGFsc29cclxuICAgIC8vIHBhcnQgb2YgdGhlIGJhc2UgbGlicmFyeS5cclxuICAgIEJhc2VMaWIuQ1JFQVRFID0gNTA7XHJcbiAgICBCYXNlTGliLlJFU1VNRSA9IDUxO1xyXG4gICAgQmFzZUxpYi5SVU5OSU5HID0gNTI7XHJcbiAgICBCYXNlTGliLlNUQVRVUyA9IDUzO1xyXG4gICAgQmFzZUxpYi5XUkFQID0gNTQ7XHJcbiAgICBCYXNlTGliLllJRUxEID0gNTU7XHJcbiAgICBCYXNlTGliLldSQVBfQVVYID0gNTY7XHJcbiAgICAvKipcclxuICAgICogTHVhIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGZvciBpcGFpcnMuICBJblxyXG4gICAgKiBQVUMtUmlvIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYW4gdXB2YWx1ZSBvZiBpcGFpcnMuXHJcbiAgICAqL1xyXG4gICAgQmFzZUxpYi5JUEFJUlNfQVVYX0ZVTiA9IG5ldyBCYXNlTGliKEJhc2VMaWIuSVBBSVJTX0FVWCk7XHJcbiAgICAvKipcclxuICAgICogTHVhIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGZvciBwYWlycy4gIEluXHJcbiAgICAqIFBVQy1SaW8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhbiB1cHZhbHVlIG9mIHBhaXJzLlxyXG4gICAgKi9cclxuICAgIEJhc2VMaWIuUEFJUlNfQVVYX0ZVTiA9IG5ldyBCYXNlTGliKEJhc2VMaWIuUEFJUlNfQVVYKTtcclxuICAgIC8qKiBVc2VkIGJ5IHtAbGluayAjY29sbGVjdGdhcmJhZ2V9LiAqL1xyXG4gICAgQmFzZUxpYi5DR09QVFMgPSBbXHJcbiAgICAgICAgXCJzdG9wXCIsIFwicmVzdGFydFwiLCBcImNvbGxlY3RcIixcclxuICAgICAgICBcImNvdW50XCIsIFwic3RlcFwiLCBcInNldHBhdXNlXCIsIFwic2V0c3RlcG11bFwiXHJcbiAgICBdO1xyXG4gICAgLyoqIFVzZWQgYnkge0BsaW5rICNjb2xsZWN0Z2FyYmFnZX0uICovXHJcbiAgICBCYXNlTGliLkNHT1BUU05VTSA9IFtcclxuICAgICAgICBMdWFfMS5MdWEuR0NTVE9QLCBMdWFfMS5MdWEuR0NSRVNUQVJULCBMdWFfMS5MdWEuR0NDT0xMRUNULFxyXG4gICAgICAgIEx1YV8xLkx1YS5HQ0NPVU5ULCBMdWFfMS5MdWEuR0NTVEVQLCBMdWFfMS5MdWEuR0NTRVRQQVVTRSwgTHVhXzEuTHVhLkdDU0VUU1RFUE1VTFxyXG4gICAgXTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHtAbGluayBQcmludFN0cmVhbX0gdXNlZCBieSBwcmludC4gIE1ha2VzIGl0IG1vcmUgY29udmVuaWVudCBpZlxyXG4gICAgICogcmVkaXJlY3Rpb24gaXMgZGVzaXJlZC4gIEZvciBleGFtcGxlLCBjbGllbnQgY29kZSBjb3VsZCBpbXBsZW1lbnRcclxuICAgICAqIHRoZWlyIG93biBpbnN0YW5jZSB3aGljaCBzZW50IG91dHB1dCB0byB0aGUgc2NyZWVuIG9mIGEgSk1FIGRldmljZS5cclxuICAgICAqL1xyXG4gICAgQmFzZUxpYi5PVVQgPSBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5vdXQ7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlTGliLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9JT0V4Y2VwdGlvblwiLCBcIi4uL2phdmEvUmVhZGVyXCIsIFwiLi9MdWFcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkJhc2VMaWJSZWFkZXIgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBJT0V4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2phdmEvSU9FeGNlcHRpb25cIik7XHJcbiAgICBjb25zdCBSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL1JlYWRlclwiKTtcclxuICAgIGNvbnN0IEx1YV8xID0gcmVxdWlyZShcIi4vTHVhXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL0Jhc2VMaWJSZWFkZXIuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMge0BsaW5rIGphdmEuaW8uUmVhZGVyfSB0byBjcmVhdGUgYSBSZWFkZXIgZnJvbSBhIEx1YVxyXG4gICAgICogZnVuY3Rpb24uICBTbyB0aGF0IHRoZSA8Y29kZT5sb2FkPC9jb2RlPiBmdW5jdGlvbiBmcm9tIEx1YSdzIGJhc2VcclxuICAgICAqIGxpYnJhcnkgY2FuIGJlIGltcGxlbWVudGVkLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBCYXNlTGliUmVhZGVyIGV4dGVuZHMgUmVhZGVyXzEuUmVhZGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihMLCBmKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3MgPSBcIlwiO1xyXG4gICAgICAgICAgICB0aGlzLl9pID0gMDsgLy8gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuX0wgPSBMO1xyXG4gICAgICAgICAgICB0aGlzLl9mID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2YgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrKGwpIHtcclxuICAgICAgICAgICAgaWYgKGwgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSU9FeGNlcHRpb25fMS5JT0V4Y2VwdGlvbihcIlJlYWRhaGVhZCBtdXN0IGJlIDw9IDFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbWFyayA9IHRoaXMuX2k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtTdXBwb3J0ZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faSA+PSB0aGlzLl9zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fTC5wdXNoT2JqZWN0KHRoaXMuX2YpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fTC5jYWxsKDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5pc05pbCh0aGlzLl9MLnZhbHVlKC0xKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMdWFfMS5MdWEuaXNTdHJpbmcodGhpcy5fTC52YWx1ZSgtMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcyA9IHRoaXMuX0wudG9TdHJpbmdfKHRoaXMuX0wudmFsdWUoLTEpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXJrID09IHRoaXMuX2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFyayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXJrID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2kgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fTC5lcnJvcihcInJlYWRlciBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcy5jaGFyQ29kZUF0KHRoaXMuX2krKyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRNdWx0aUJ5dGVzKGNidWYsIG9mZiwgbGVuKSB7XHJcbiAgICAgICAgICAgIHZhciBqID0gMDsgLy8gbG9vcCBpbmRleCByZXF1aXJlZCBhZnRlciBsb29wXHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW47ICsraikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYnVmW29mZiArIGpdID0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzZXQoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXJrIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElPRXhjZXB0aW9uXzEuSU9FeGNlcHRpb24oXCJyZXNldCgpIG5vdCBzdXBwb3J0ZWQgbm93XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2kgPSB0aGlzLl9tYXJrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuQmFzZUxpYlJlYWRlciA9IEJhc2VMaWJSZWFkZXI7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlTGliUmVhZGVyLmpzLm1hcCIsIi8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9CbG9ja0NudC5qYXZhIzEgJFxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuQmxvY2tDbnQgPSB2b2lkIDA7XHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKlxyXG4gICAgKiogbm9kZXMgZm9yIGJsb2NrIGxpc3QgKGxpc3Qgb2YgYWN0aXZlIGJsb2NrcylcclxuICAgICovXHJcbiAgICBjbGFzcyBCbG9ja0NudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsOyAvKiBjaGFpbiAqL1xyXG4gICAgICAgICAgICB0aGlzLmJyZWFrbGlzdCA9IDA7IC8qIGxpc3Qgb2YganVtcHMgb3V0IG9mIHRoaXMgbG9vcCAqL1xyXG4gICAgICAgICAgICB0aGlzLm5hY3R2YXIgPSAwOyAvKiAjIGFjdGl2ZSBsb2NhbHMgb3V0c2lkZSB0aGUgYnJlYWthYmxlIHN0cnVjdHVyZSAqL1xyXG4gICAgICAgICAgICB0aGlzLnVwdmFsID0gZmFsc2U7IC8qIHRydWUgaWYgc29tZSB2YXJpYWJsZSBpbiB0aGUgYmxvY2sgaXMgYW4gdXB2YWx1ZSAqL1xyXG4gICAgICAgICAgICB0aGlzLmlzYnJlYWthYmxlID0gZmFsc2U7IC8qIHRydWUgaWYgYGJsb2NrJyBpcyBhIGxvb3AgKi9cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkJsb2NrQ250ID0gQmxvY2tDbnQ7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9ja0NudC5qcy5tYXAiLCIvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvQ2FsbEluZm8uamF2YSMxICRcclxuICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkNhbGxJbmZvID0gdm9pZCAwO1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgY2xhc3MgQ2FsbEluZm8ge1xyXG4gICAgICAgIC8qKiBPbmx5IHVzZWQgdG8gY3JlYXRlIHRoZSBmaXJzdCBpbnN0YW5jZS4gKi9cclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Z1bmMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG9wID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbnJlc3VsdHMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsY2FsbHMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZnVuYyAgc3RhY2sgaW5kZXggb2YgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0gYmFzZSAgc3RhY2sgYmFzZSBmb3IgdGhpcyBmcmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB0b3AgICB0b3Atb2Ytc3RhY2sgZm9yIHRoaXMgZnJhbWVcclxuICAgICAgICAgKiBAcGFyYW0gbnJlc3VsdHMgIG51bWJlciBvZiByZXN1bHRzIGV4cGVjdGVkIGJ5IGNhbGxlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQoZnVuYywgYmFzZSwgdG9wLCBucmVzdWx0cykge1xyXG4gICAgICAgICAgICB0aGlzLl9mdW5jID0gZnVuYztcclxuICAgICAgICAgICAgdGhpcy5fYmFzZSA9IGJhc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcCA9IHRvcDtcclxuICAgICAgICAgICAgdGhpcy5fbnJlc3VsdHMgPSBucmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFNldHRlciBmb3Igc2F2ZWRwYy4gKi9cclxuICAgICAgICBzZXQgc2F2ZWRwYyhwYykge1xyXG4gICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gcGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBHZXR0ZXIgZm9yIHNhdmVkcGMuICovXHJcbiAgICAgICAgZ2V0IHNhdmVkcGMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZHBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZnVuY3Rpb24gb2JqZWN0IGZvciB0aGlzIHJlY29yZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgZnVuYygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bmM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBzdGFjayBpbmRleCB3aGVyZSByZXN1bHRzIHNob3VsZCBlbmQgdXAuICBUaGlzIGlzIGFuIGFic29sdXRlXHJcbiAgICAgICAgICogc3RhY2sgaW5kZXgsIG5vdCByZWxhdGl2ZSB0byBMLmJhc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzKCkge1xyXG4gICAgICAgICAgICAvLyBTYW1lIGxvY2F0aW9uIGFzIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnVuYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHN0YWNrIGJhc2UgZm9yIHRoaXMgcmVjb3JkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBiYXNlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRvcC1vZi1zdGFjayBmb3IgdGhpcyByZWNvcmQuICBUaGlzIGlzIHRoZSBudW1iZXIgb2YgZWxlbWVudHNcclxuICAgICAgICAgKiBpbiB0aGUgc3RhY2sgKG9yIHdpbGwgYmUgd2hlbiB0aGUgZnVuY3Rpb24gaXMgcmVzdW1lZCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IHRvcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0dGVyIGZvciB0b3AuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0IHRvcCh0b3ApIHtcclxuICAgICAgICAgICAgdGhpcy5fdG9wID0gdG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgbnVtYmVyIG9mIHJlc3VsdHMgZXhwZWN0ZWQgYnkgdGhlIGNhbGxlciBvZiB0aGlzIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIFVzZWQgdG8gYWRqdXN0IHRoZSByZXR1cm5lZCByZXN1bHRzIHRvIHRoZSBjb3JyZWN0IG51bWJlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgbnJlc3VsdHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ucmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IG51bWJlciBvZiB0YWlsY2FsbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgdGFpbGNhbGxzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFpbGNhbGxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGR1cmluZyB0YWlsY2FsbCB0byBzZXQgdGhlIGJhc2UgYW5kIHRvcCBtZW1iZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRhaWxjYWxsKGJhc2VBcmcsIHRvcEFyZykge1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlID0gYmFzZUFyZztcclxuICAgICAgICAgICAgdGhpcy5fdG9wID0gdG9wQXJnO1xyXG4gICAgICAgICAgICArK3RoaXMuX3RhaWxjYWxscztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkNhbGxJbmZvID0gQ2FsbEluZm87XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWxsSW5mby5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vRXhwZGVzY1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuQ29uc0NvbnRyb2wgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBFeHBkZXNjXzEgPSByZXF1aXJlKFwiLi9FeHBkZXNjXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL1N5bnRheC5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIGNsYXNzIENvbnNDb250cm9sIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcih0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudiA9IG5ldyBFeHBkZXNjXzEuRXhwZGVzYygpOyAvKiBsYXN0IGxpc3QgaXRlbSByZWFkICovXHJcbiAgICAgICAgICAgIHRoaXMubmggPSAwOyAvKiB0b3RhbCBudW1iZXIgb2YgYHJlY29yZCcgZWxlbWVudHMgKi9cclxuICAgICAgICAgICAgdGhpcy5uYSA9IDA7IC8qIHRvdGFsIG51bWJlciBvZiBhcnJheSBlbGVtZW50cyAqL1xyXG4gICAgICAgICAgICB0aGlzLnRvc3RvcmUgPSAwOyAvKiBudW1iZXIgb2YgYXJyYXkgZWxlbWVudHMgcGVuZGluZyB0byBiZSBzdG9yZWQgKi9cclxuICAgICAgICAgICAgdGhpcy50ID0gdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkNvbnNDb250cm9sID0gQ29uc0NvbnRyb2w7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25zQ29udHJvbC5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vTHVhXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5EZWJ1ZyA9IHZvaWQgMDtcclxuICAgIGNvbnN0IEx1YV8xID0gcmVxdWlyZShcIi4vTHVhXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL0RlYnVnLmphdmEjMSAkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0cnVjdCBsdWFfRGVidWcuICBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluY29tcGxldGVcclxuICAgICAqIGJlY2F1c2UgaXQgaXMgbm90IGludGVuZGVkIHRvIGZvcm0gcGFydCBvZiB0aGUgcHVibGljIEFQSS4gIEl0IGhhc1xyXG4gICAgICogb25seSBiZWVuIGltcGxlbWVudGVkIHRvIHRoZSBleHRlbnQgbmVjZXNzYXJ5IGZvciBpbnRlcm5hbCB1c2UuXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIERlYnVnIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gaWNpICBpbmRleCBvZiBDYWxsSW5mbyByZWNvcmQgaW4gTC5jaXZcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdHJ1Y3RvcihpY2kpIHtcclxuICAgICAgICAgICAgLy8gcHJpdmF0ZSwgbm8gcHVibGljIGFjY2Vzc29ycyBkZWZpbmVkLlxyXG4gICAgICAgICAgICB0aGlzLl9pY2kgPSAwO1xyXG4gICAgICAgICAgICAvLyBwdWJsaWMgYWNjZXNzb3JzIG1heSBiZSBkZWZpbmVkIGZvciB0aGVzZS5cclxuICAgICAgICAgICAgdGhpcy5fZXZlbnQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl93aGF0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudGxpbmUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lZGVmaW5lZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RsaW5lZGVmaW5lZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0c3JjID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5faWNpID0gaWNpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgaWNpKGljaSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pY2kgPSBpY2k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBpY2ksIGluZGV4IG9mIHRoZSB7QGxpbmsgQ2FsbEluZm99IHJlY29yZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgaWNpKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWNpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXR0ZXIgZm9yIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldCBldmVudChldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB3aGF0IGZpZWxkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldCB3aGF0KHdoYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fd2hhdCA9IHdoYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHNvdXJjZSwgYW5kIHRoZSBzaG9ydHNyYy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQgc291cmNlKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0c3JjID0gTHVhXzEuTHVhLm9DaHVua2lkKHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbGluZS4gIE1heSBiZWNvbWUgcHVibGljLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBjdXJyZW50bGluZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRsaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgY3VycmVudGxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0IGN1cnJlbnRsaW5lKGN1cnJlbnRsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRsaW5lID0gY3VycmVudGxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBsaW5lZGVmaW5lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgbGluZWRlZmluZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IGxpbmVkZWZpbmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldCBsaW5lZGVmaW5lZChsaW5lZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lZGVmaW5lZCA9IGxpbmVkZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgbGFzdGxpbmVkZWZpbmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldCBsYXN0bGluZWRlZmluZWQobGFzdGxpbmVkZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RsaW5lZGVmaW5lZCA9IGxhc3RsaW5lZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgXCJwcmludGFibGVcIiB2ZXJzaW9uIG9mIHNvdXJjZSwgZm9yIGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIE1heSBiZWNvbWUgcHVibGljLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBzaG9ydHNyYygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3J0c3JjO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuRGVidWcgPSBEZWJ1ZztcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlYnVnLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9CeXRlQXJyYXlcIiwgXCIuL0xvYWRlclwiLCBcIi4vTHVhXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5EdW1wU3RhdGUgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBCeXRlQXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0J5dGVBcnJheVwiKTtcclxuICAgIGNvbnN0IExvYWRlcl8xID0gcmVxdWlyZShcIi4vTG9hZGVyXCIpO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvQmxvY2tDbnQuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICBjbGFzcyBEdW1wU3RhdGUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHdyaXRlciwgc3RyaXApIHtcclxuICAgICAgICAgICAgdGhpcy5fd3JpdGVyID0gd3JpdGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJpcCA9IHN0cmlwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vIGR1bXBlciAvLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgICAgIER1bXBIZWFkZXIoKSB7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAqIEluIG9yZGVyIHRvIG1ha2UgdGhlIGNvZGUgbW9yZSBjb21wYWN0IHRoZSBkdW1wZXIgcmUtdXNlcyB0aGVcclxuICAgICAgICAgICAgICAgICogaGVhZGVyIGRlZmluZWQgaW4gTG9hZGVyLmphdmEuICBJdCBoYXMgdG8gZml4IHRoZSBlbmRpYW5uZXNzIGJ5dGVcclxuICAgICAgICAgICAgICAgICogZmlyc3QuXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBMb2FkZXJfMS5Mb2FkZXIuSEVBREVSWzZdID0gMDtcclxuICAgICAgICAgICAgLy9UT0RPOkphdmEgdG8gQVMzXHJcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEJ5dGVBcnJheV8xLkJ5dGVBcnJheSgpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gTG9hZGVyXzEuTG9hZGVyLkhFQURFUi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGIud3JpdGVCeXRlKExvYWRlcl8xLkxvYWRlci5IRUFERVJbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZShiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRHVtcEludChpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZUludChpKTsgLy8gYmlnLWVuZGlhblxyXG4gICAgICAgIH1cclxuICAgICAgICBEdW1wTnVtYmVyKGQpIHtcclxuICAgICAgICAgICAgdGhpcy5fd3JpdGVyLndyaXRlRG91YmxlKGQpOyAvLyBiaWctZW5kaWFuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIER1bXBGdW5jdGlvbihmLCBwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuRHVtcFN0cmluZygoZi5zb3VyY2UgPT0gcCB8fCB0aGlzLl9zdHJpcCkgPyBudWxsIDogZi5zb3VyY2UpO1xyXG4gICAgICAgICAgICB0aGlzLkR1bXBJbnQoZi5saW5lZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHRoaXMuRHVtcEludChmLmxhc3RsaW5lZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZUJ5dGUoZi5udXBzKTtcclxuICAgICAgICAgICAgdGhpcy5fd3JpdGVyLndyaXRlQnl0ZShmLm51bXBhcmFtcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZUJvb2xlYW4oZi5pc1ZhcmFyZyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZUJ5dGUoZi5tYXhzdGFja3NpemUpO1xyXG4gICAgICAgICAgICB0aGlzLkR1bXBDb2RlKGYpO1xyXG4gICAgICAgICAgICB0aGlzLkR1bXBDb25zdGFudHMoZik7XHJcbiAgICAgICAgICAgIHRoaXMuRHVtcERlYnVnKGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEdW1wQ29kZShmKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gZi5zaXplY29kZTtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSBmLmNvZGU7IC8vaW50IFtdIFxyXG4gICAgICAgICAgICB0aGlzLkR1bXBJbnQobik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5EdW1wSW50KGNvZGVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEdW1wQ29uc3RhbnRzKGYpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBmLnNpemVrO1xyXG4gICAgICAgICAgICB2YXIgayA9IGYuazsgLy9TbG90W11cclxuICAgICAgICAgICAgdGhpcy5EdW1wSW50KG4pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG8gPSBrW2ldLnI7XHJcbiAgICAgICAgICAgICAgICBpZiAobyA9PSBMdWFfMS5MdWEuTklMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVyLndyaXRlQnl0ZShMdWFfMS5MdWEuVE5JTCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG8pID09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVyLndyaXRlQnl0ZShMdWFfMS5MdWEuVEJPT0xFQU4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZUJvb2xlYW4obyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvID09IEx1YV8xLkx1YS5OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cml0ZXIud3JpdGVCeXRlKEx1YV8xLkx1YS5UTlVNQkVSKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLkR1bXBOdW1iZXIoa1tpXS5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAobykgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZUJ5dGUoTHVhXzEuTHVhLlRTVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRHVtcFN0cmluZyhvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIyBhc3NlcnQgZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZi5zaXplcDtcclxuICAgICAgICAgICAgdGhpcy5EdW1wSW50KG4pO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ViZnVuYyA9IGYucFtpXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuRHVtcEZ1bmN0aW9uKHN1YmZ1bmMsIGYuc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBEdW1wU3RyaW5nKHMpIHtcclxuICAgICAgICAgICAgaWYgKHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5EdW1wSW50KDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAqIFN0cmluZ3MgYXJlIGR1bXBlZCBieSBjb252ZXJ0aW5nIHRvIFVURi04IGVuY29kaW5nLiAgVGhlIE1JRFBcclxuICAgICAgICAgICAgICAgICAgICAqIDIuMCBzcGVjIGd1YXJhbnRlZXMgdGhhdCB0aGlzIGVuY29kaW5nIHdpbGwgYmUgc3VwcG9ydGVkIChzZWVcclxuICAgICAgICAgICAgICAgICAgICAqIHBhZ2UgOSBvZiBtaWRwLTJfMC1mci1zcGVjLnBkZikuICBOb25ldGhlbGVzcywgYW55XHJcbiAgICAgICAgICAgICAgICAgICAgKiBwb3NzaWJsZSBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uIGlzIGxlZnQgdG8gYmUgdGhyb3duXHJcbiAgICAgICAgICAgICAgICAgICAgKiAoaXQncyBhIHN1YmNsYXNzIG9mIElPRXhjZXB0aW9uIHdoaWNoIGlzIGRlY2xhcmVkIHRvIGJlIHRocm93bikuXHJcbiAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8vVE9ETzogSmF2YSB0byBBUzNcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IG5ldyBCeXRlQXJyYXlfMS5CeXRlQXJyYXkoKTsgLy8gcy5nZXRCeXRlcyhcIlVURi04XCIpOyAvL2J5dGUgW11cclxuICAgICAgICAgICAgICAgIGNvbnRlbnRzLndyaXRlVVRGQnl0ZXMocyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGNvbnRlbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuRHVtcEludChzaXplICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZXIud3JpdGUoY29udGVudHMsIDAsIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVyLndyaXRlQnl0ZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBEdW1wRGVidWcoZikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RyaXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuRHVtcEludCgwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuRHVtcEludCgwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuRHVtcEludCgwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbiA9IGYuc2l6ZWxpbmVpbmZvO1xyXG4gICAgICAgICAgICB0aGlzLkR1bXBJbnQobik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5EdW1wSW50KGYubGluZWluZm9baV0pO1xyXG4gICAgICAgICAgICBuID0gZi5zaXplbG9jdmFycztcclxuICAgICAgICAgICAgdGhpcy5EdW1wSW50KG4pO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jdmFyID0gZi5sb2N2YXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5EdW1wU3RyaW5nKGxvY3Zhci52YXJuYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuRHVtcEludChsb2N2YXIuc3RhcnRwYyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkR1bXBJbnQobG9jdmFyLmVuZHBjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZi5zaXpldXB2YWx1ZXM7XHJcbiAgICAgICAgICAgIHRoaXMuRHVtcEludChuKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMuRHVtcFN0cmluZyhmLnVwdmFsdWVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgd3JpdGVyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuRHVtcFN0YXRlID0gRHVtcFN0YXRlO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHVtcFN0YXRlLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9JbnB1dFN0cmVhbVwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuRHVtcGVkSW5wdXQgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBJbnB1dFN0cmVhbV8xID0gcmVxdWlyZShcIi4uL2phdmEvSW5wdXRTdHJlYW1cIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvRHVtcGVkSW5wdXQuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIG9idGFpbmVkIHVzaW5nIHN0cmluZy5kdW1wIGludG8gYW5cclxuICAgICAqIHtAbGluayBqYXZhLmlvLklucHV0U3RyZWFtfSBzbyB0aGF0IGl0IGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rXHJcbiAgICAgKiBMdWEjbG9hZChqYXZhLmlvLklucHV0U3RyZWFtLCBqYXZhLmxhbmcuU3RyaW5nKX0uXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIER1bXBlZElucHV0IGV4dGVuZHMgSW5wdXRTdHJlYW1fMS5JbnB1dFN0cmVhbSB7XHJcbiAgICAgICAgY29uc3RydWN0b3Iocykge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9pID0gMDsgLy8gPSAwXHJcbiAgICAgICAgICAgIHRoaXMuX21hcmsgPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5fcyA9IHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF2YWlsYWJsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3MubGVuZ3RoIC0gdGhpcy5faTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3MgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9pID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmsocmVhZGxpbWl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmsgPSB0aGlzLl9pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrU3VwcG9ydGVkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2kgPj0gdGhpcy5fcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX3MuY2hhckNvZGVBdCh0aGlzLl9pKTtcclxuICAgICAgICAgICAgKyt0aGlzLl9pO1xyXG4gICAgICAgICAgICByZXR1cm4gYyAmIDB4ZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0KCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pID0gdGhpcy5fbWFyaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2tpcChuKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHVtcGVkSW5wdXQuc2tpcCgpIG5vdCBpbXBsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuRHVtcGVkSW5wdXQgPSBEdW1wZWRJbnB1dDtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUR1bXBlZElucHV0LmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9MdWFcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkVudW0gPSB2b2lkIDA7XHJcbiAgICBjb25zdCBMdWFfMSA9IHJlcXVpcmUoXCIuL0x1YVwiKTtcclxuICAgIC8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9TeW50YXguamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICBjbGFzcyBFbnVtIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2kgPSAwOyAvLyA9IDBcclxuICAgICAgICAgICAgdGhpcy5fdCA9IHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2UgPSBlO1xyXG4gICAgICAgICAgICB0aGlzLmluY2koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBJbmNyZW1lbnRzIHtAbGluayAjaX0gdW50aWwgaXQgZWl0aGVyIGV4Y2VlZHNcclxuICAgICAgICAqIDxjb2RlPnQuc2l6ZUFycmF5PC9jb2RlPiBvciBpbmRleGVzIGEgbm9uLW5pbCBlbGVtZW50LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgaW5jaSgpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2kgPCB0aGlzLl90LnNpemVBcnJheSAmJiB0aGlzLl90LmFycmF5W3RoaXMuX2ldID09IEx1YV8xLkx1YS5OSUwpIHtcclxuICAgICAgICAgICAgICAgICsrdGhpcy5faTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNNb3JlRWxlbWVudHMoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pIDwgdGhpcy5fdC5zaXplQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lLmhhc01vcmVFbGVtZW50cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXh0RWxlbWVudCgpIHtcclxuICAgICAgICAgICAgdmFyIHI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pIDwgdGhpcy5fdC5zaXplQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICsrdGhpcy5faTsgLy8gYXJyYXkgaW5kZXggaSBjb3JyZXNwb25kcyB0byBrZXkgaSsxXHJcbiAgICAgICAgICAgICAgICByID0gbmV3IE51bWJlcih0aGlzLl9pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5jaSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgciA9IHRoaXMuX2UubmV4dEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkVudW0gPSBFbnVtO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW51bS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vRnVuY1N0YXRlXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5FeHBkZXNjID0gdm9pZCAwO1xyXG4gICAgY29uc3QgRnVuY1N0YXRlXzEgPSByZXF1aXJlKFwiLi9GdW5jU3RhdGVcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvRXhwZGVzYy5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIC8qKiBFcXVpdmFsZW50IHRvIHN0cnVjdCBleHBkZXNjLiAqL1xyXG4gICAgY2xhc3MgRXhwZGVzYyBleHRlbmRzIE9iamVjdCB7XHJcbiAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9rID0gMDsgLy8gb25lIG9mIFYqIGVudW1zIGFib3ZlXHJcbiAgICAgICAgICAgIHRoaXMuX2luZm8gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hdXggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9udmFsID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2YgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3B1YmxpYyBmdW5jdGlvbiBFeHBkZXNjKGs6aW50LCBpOmludCk6dm9pZFxyXG4gICAgICAgIC8ve1xyXG4gICAgICAgIC8vaW5pdChrLCBpKTtcclxuICAgICAgICAvL31cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBpbml0X2V4cCBmcm9tIGxwYXJzZXIuYyAqL1xyXG4gICAgICAgIGluaXQoa2luZCwgaSkge1xyXG4gICAgICAgICAgICB0aGlzLl90ID0gRnVuY1N0YXRlXzEuRnVuY1N0YXRlLk5PX0pVTVA7XHJcbiAgICAgICAgICAgIHRoaXMuX2YgPSBGdW5jU3RhdGVfMS5GdW5jU3RhdGUuTk9fSlVNUDtcclxuICAgICAgICAgICAgdGhpcy5fayA9IGtpbmQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZm8gPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3B5KGUpIHtcclxuICAgICAgICAgICAgLy8gTXVzdCBpbml0aWFsaXNlIGFsbCBtZW1iZXJzIG9mIHRoaXMuXHJcbiAgICAgICAgICAgIHRoaXMuX2sgPSBlLl9rO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmZvID0gZS5faW5mbztcclxuICAgICAgICAgICAgdGhpcy5fYXV4ID0gZS5fYXV4O1xyXG4gICAgICAgICAgICB0aGlzLl9udmFsID0gZS5fbnZhbDtcclxuICAgICAgICAgICAgdGhpcy5fdCA9IGUuX3Q7XHJcbiAgICAgICAgICAgIHRoaXMuX2YgPSBlLl9mO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQga2luZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldCBraW5kKGtpbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5fayA9IGtpbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBrKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGsoa2luZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9rID0ga2luZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGluZm8oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmZvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgaW5mbyhpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZm8gPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgYXV4KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgYXV4KGF1eCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hdXggPSBhdXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBudmFsKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IG52YWwoZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9udmFsID0gZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gaGFzbXVsdHJldCBmcm9tIGxwYXJzZXIuYyAqL1xyXG4gICAgICAgIGhhc211bHRyZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rID09IEV4cGRlc2MuVkNBTEwgfHwgdGhpcy5fayA9PSBFeHBkZXNjLlZWQVJBUkc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGhhc2p1bXBzIGZyb20gbGNvZGUuYy4gKi9cclxuICAgICAgICBoYXNqdW1wcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3QgIT0gdGhpcy5fZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9ucmVsb2MoaSkge1xyXG4gICAgICAgICAgICB0aGlzLl9rID0gRXhwZGVzYy5WTk9OUkVMT0M7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZm8gPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWxvYyhpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2sgPSBFeHBkZXNjLlZSRUxPQ0FCTEU7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZm8gPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cHZhbChpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2sgPSBFeHBkZXNjLlZVUFZBTDtcclxuICAgICAgICAgICAgdGhpcy5faW5mbyA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IGYoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCBmKGYpIHtcclxuICAgICAgICAgICAgdGhpcy5fZiA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IHQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCB0KHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdCA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5FeHBkZXNjID0gRXhwZGVzYztcclxuICAgIEV4cGRlc2MuVlZPSUQgPSAwOyAvLyBubyB2YWx1ZVxyXG4gICAgRXhwZGVzYy5WTklMID0gMTtcclxuICAgIEV4cGRlc2MuVlRSVUUgPSAyO1xyXG4gICAgRXhwZGVzYy5WRkFMU0UgPSAzO1xyXG4gICAgRXhwZGVzYy5WSyA9IDQ7IC8vIGluZm8gPSBpbmRleCBpbnRvICdrJ1xyXG4gICAgRXhwZGVzYy5WS05VTSA9IDU7IC8vIG52YWwgPSBudW1lcmljYWwgdmFsdWVcclxuICAgIEV4cGRlc2MuVkxPQ0FMID0gNjsgLy8gaW5mbyA9IGxvY2FsIHJlZ2lzdGVyXHJcbiAgICBFeHBkZXNjLlZVUFZBTCA9IDc7IC8vIGluZm8gPSBpbmRleCBpbnRvICd1cHZhbHVlcydcclxuICAgIEV4cGRlc2MuVkdMT0JBTCA9IDg7IC8vIGluZm8gPSBpbmRleCBvZiB0YWJsZTtcclxuICAgIC8vIGF1eCA9IGluZGV4IG9mIGdsb2JhbCBuYW1lIGluICdrJ1xyXG4gICAgRXhwZGVzYy5WSU5ERVhFRCA9IDk7IC8vIGluZm8gPSB0YWJsZSByZWdpc3RlclxyXG4gICAgLy8gYXV4ID0gaW5kZXggcmVnaXN0ZXIgKG9yICdrJylcclxuICAgIEV4cGRlc2MuVkpNUCA9IDEwOyAvLyBpbmZvID0gaW5zdHJ1Y3Rpb24gcGNcclxuICAgIEV4cGRlc2MuVlJFTE9DQUJMRSA9IDExOyAvLyBpbmZvID0gaW5zdHJ1Y3Rpb24gcGNcclxuICAgIEV4cGRlc2MuVk5PTlJFTE9DID0gMTI7IC8vIGluZm8gPSByZXN1bHQgcmVnaXN0ZXJcclxuICAgIEV4cGRlc2MuVkNBTEwgPSAxMzsgLy8gaW5mbyA9IGluc3RydWN0aW9uIHBjXHJcbiAgICBFeHBkZXNjLlZWQVJBUkcgPSAxNDsgLy8gaW5mbyA9IGluc3RydWN0aW9uIHBjXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHBkZXNjLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9TdHJpbmdCdWZmZXJcIiwgXCIuLi9qYXZhL0NoYXJhY3RlclwiLCBcIi4uL2phdmEvTnVtYmVyRm9ybWF0RXhjZXB0aW9uXCIsIFwiLi9MdWFcIiwgXCIuL1N5bnRheFwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuRm9ybWF0SXRlbSA9IHZvaWQgMDtcclxuICAgIGNvbnN0IFN0cmluZ0J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL2phdmEvU3RyaW5nQnVmZmVyXCIpO1xyXG4gICAgY29uc3QgQ2hhcmFjdGVyXzEgPSByZXF1aXJlKFwiLi4vamF2YS9DaGFyYWN0ZXJcIik7XHJcbiAgICBjb25zdCBOdW1iZXJGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL051bWJlckZvcm1hdEV4Y2VwdGlvblwiKTtcclxuICAgIGNvbnN0IEx1YV8xID0gcmVxdWlyZShcIi4vTHVhXCIpO1xyXG4gICAgY29uc3QgU3ludGF4XzEgPSByZXF1aXJlKFwiLi9TeW50YXhcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvU3RyaW5nTGliLmphdmEjMSAkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgY2xhc3MgRm9ybWF0SXRlbSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2UgYSBmb3JtYXQgaXRlbSAoc3RhcnRpbmcgZnJvbSBhZnRlciB0aGUgPGNvZGU+TF9FU0M8L2NvZGU+KS5cclxuICAgICAgICAgKiBJZiB5b3UgcHJvbWlzZSB0aGF0IHRoZXJlIHdvbid0IGJlIGFueSBmb3JtYXQgZXJyb3JzLCB0aGVuXHJcbiAgICAgICAgICogPHZhcj5MPC92YXI+IGNhbiBiZSA8Y29kZT5udWxsPC9jb2RlPi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdHJ1Y3RvcihMLCBzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBmYWxzZTsgLy8gJy0nIGZsYWdcclxuICAgICAgICAgICAgdGhpcy5fc2lnbiA9IGZhbHNlOyAvLyAnKycgZmxhZ1xyXG4gICAgICAgICAgICB0aGlzLl9zcGFjZSA9IGZhbHNlOyAvLyAnICcgZmxhZ1xyXG4gICAgICAgICAgICB0aGlzLl9hbHQgPSBmYWxzZTsgLy8gJyMnIGZsYWdcclxuICAgICAgICAgICAgdGhpcy5femVybyA9IGZhbHNlOyAvLyAnMCcgZmxhZ1xyXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IDA7IC8vIG1pbmltdW0gZmllbGQgd2lkdGhcclxuICAgICAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gLTE7IC8vIHByZWNpc2lvbiwgLTEgd2hlbiBubyBwcmVjaXNpb24gc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gMDsgLy8gdGhlIHR5cGUgb2YgdGhlIGNvbnZlcnNpb25cclxuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDsgLy8gbGVuZ3RoIG9mIHRoZSBmb3JtYXQgaXRlbSBpbiB0aGUgZm9ybWF0IHN0cmluZy5cclxuICAgICAgICAgICAgdGhpcy5fTCA9IEw7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgdmFyIGwgPSBzLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gcGFyc2UgZmxhZ3NcclxuICAgICAgICAgICAgZmxhZzogd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGwpXHJcbiAgICAgICAgICAgICAgICAgICAgTC5lcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzLmNoYXJBdChpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZ24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICcgJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICcjJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnMCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBmbGFnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICB9IC8qIGZsYWcgKi9cclxuICAgICAgICAgICAgLy8gcGFyc2Ugd2lkdGhcclxuICAgICAgICAgICAgdmFyIHdpZHRocyA9IGk7IC8vIGluZGV4IG9mIHN0YXJ0IG9mIHdpZHRoIHNwZWNpZmllclxyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9MLmVycm9yKFwiaW52YWxpZCBmb3JtYXRcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoU3ludGF4XzEuU3ludGF4LmlzZGlnaXQocy5jaGFyQ29kZUF0KGkpKSkgLy9UT0RPOlxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2lkdGhzIDwgaSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCA9IHBhcnNlSW50KHMuc3Vic3RyaW5nKHdpZHRocywgaSkpOyAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlXy5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHBhcnNlIHByZWNpc2lvblxyXG4gICAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2lzaW9ucyA9IGk7IC8vIGluZGV4IG9mIHN0YXJ0IG9mIHByZWNpc2lvbiBzcGVjaWZpZXJcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgTC5lcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTeW50YXhfMS5TeW50YXguaXNkaWdpdChzLmNoYXJDb2RlQXQoaSkpKSAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbnMgPCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gcGFyc2VJbnQocy5zdWJzdHJpbmcocHJlY2lzaW9ucywgaSkpOyAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8gaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb25fMS5OdW1iZXJGb3JtYXRFeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVfLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHMuY2hhckF0KGkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdvJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdYJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdxJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX0wuZXJyb3IoXCJpbnZhbGlkIG9wdGlvbiB0byAnZm9ybWF0J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGxlbmd0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGxlbmd0aChsZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgdHlwZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldCB0eXBlKHR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvcm1hdCB0aGUgY29udmVydGVkIHN0cmluZyBhY2NvcmRpbmcgdG8gd2lkdGgsIGFuZCBsZWZ0LlxyXG4gICAgICAgICAqIHplcm8gcGFkZGluZyBpcyBoYW5kbGVkIGluIGVpdGhlciB7QGxpbmsgRm9ybWF0SXRlbSNmb3JtYXRJbnRlZ2VyfVxyXG4gICAgICAgICAqIG9yIHtAbGluayBGb3JtYXRJdGVtI2Zvcm1hdEZsb2F0fVxyXG4gICAgICAgICAqIChhbmQgd2lkdGggaXMgZml4ZWQgdG8gMCBpbiBzdWNoIGNhc2VzKS4gIFRoZXJlZm9yZSB3ZSBjYW4gaWdub3JlXHJcbiAgICAgICAgICogemVyby5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3JtYXQoYiwgcykge1xyXG4gICAgICAgICAgICB2YXIgbCA9IHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAobCA+PSB0aGlzLl93aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcocyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhZCA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgd2hpbGUgKGwgPCB0aGlzLl93aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgcGFkLmFwcGVuZCgnICcuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICArK2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlZnQpIHtcclxuICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKHMpO1xyXG4gICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmdCdWZmZXIocGFkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nQnVmZmVyKHBhZCk7XHJcbiAgICAgICAgICAgICAgICBiLmFwcGVuZFN0cmluZyhzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbGwgdGhlIGZvcm1hdCogbWV0aG9kcyB0YWtlIGEgU3RyaW5nQnVmZmVyIGFuZCBhcHBlbmQgdGhlXHJcbiAgICAgICAgLy8gZm9ybWF0dGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSB0byBpdC5cclxuICAgICAgICAvLyBTYWRseSBhZnRlciBhIGZvcm1hdCogbWV0aG9kIGhhcyBiZWVuIGludm9rZWQgdGhlIG9iamVjdCBpcyBsZWZ0IGluXHJcbiAgICAgICAgLy8gYW4gdW51c2FibGUgc3RhdGUgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBhZ2Fpbi5cclxuICAgICAgICBmb3JtYXRDaGFyKGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpOyAvL1RPRE86XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KGIsIHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRJbnRlZ2VyKGIsIGkpIHtcclxuICAgICAgICAgICAgLy8gOnRvZG86IGltcHJvdmUgaW5lZmZpY2llbnQgdXNlIG9mIGltcGxpY2l0IFN0cmluZ0J1ZmZlclxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGVmdClcclxuICAgICAgICAgICAgICAgIHRoaXMuX3plcm8gPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZWNpc2lvbiA+PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5femVybyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgcmFkaXggPSAxMDtcclxuICAgICAgICAgICAgc3dpdGNoIChTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ28nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl4ID0gODtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuICAgICAgICAgICAgICAgICAgICByYWRpeCA9IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdYJzpcclxuICAgICAgICAgICAgICAgICAgICByYWRpeCA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9MLmVycm9yKFwiaW52YWxpZCBmb3JtYXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHMgPSBpLnRvU3RyaW5nKHJhZGl4KTsgLy9Mb25nLnRvU3RyaW5nKGksIHJhZGl4KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT0gJ1gnLmNoYXJDb2RlQXQoMCkpXHJcbiAgICAgICAgICAgICAgICBzID0gcy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlY2lzaW9uID09IDAgJiYgcyA9PSBcIjBcIilcclxuICAgICAgICAgICAgICAgIHMgPSBcIlwiO1xyXG4gICAgICAgICAgICAvLyBmb3JtIGEgcHJlZml4IGJ5IHN0cmlwcHBpbmcgcG9zc2libGUgbGVhZGluZyAnLScsXHJcbiAgICAgICAgICAgIC8vIHBhZCB0byBwcmVjaXNpb24sXHJcbiAgICAgICAgICAgIC8vIGFkZCBwcmVmaXgsXHJcbiAgICAgICAgICAgIC8vIHBhZCB0byB3aWR0aC5cclxuICAgICAgICAgICAgLy8gZXh0cmEgd2FydDogcGFkZGluZyB3aXRoICcwJyBpcyBpbXBsZW1lbnRlZCB1c2luZyBwcmVjaXNpb25cclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIG1ha2VzIGhhbmRsaW5nIHRoZSBwcmVmaXggZWFzaWVyLlxyXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gXCJcIjtcclxuICAgICAgICAgICAgaWYgKHMuc3Vic3RyKDAsIDEpID09IFwiLVwiKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWx0ICYmIHJhZGl4ID09IDE2KVxyXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCIweFwiO1xyXG4gICAgICAgICAgICBpZiAocHJlZml4ID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaWduKVxyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiK1wiO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3BhY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCIgXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FsdCAmJiByYWRpeCA9PSA4ICYmIHMuc3Vic3RyKDAsIDEpICE9IFwiMFwiKVxyXG4gICAgICAgICAgICAgICAgcyA9IFwiMFwiICsgcztcclxuICAgICAgICAgICAgdmFyIGwgPSBzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3plcm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHRoaXMuX3dpZHRoIC0gcHJlZml4Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobCA8IHRoaXMuX3ByZWNpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgU3RyaW5nQnVmZmVyXzEuU3RyaW5nQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobCA8IHRoaXMuX3ByZWNpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuYXBwZW5kKCcwJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgICAgICAgICArK2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwLmFwcGVuZFN0cmluZyhzKTtcclxuICAgICAgICAgICAgICAgIHMgPSBwLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcyA9IHByZWZpeCArIHM7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KGIsIHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRGbG9hdChiLCBkKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl90eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdEZsb2F0RyhiLCBkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdEZsb2F0RihiLCBkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0RmxvYXRFKGIsIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRGbG9hdEUoYiwgZCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuZm9ybWF0RmxvYXRSYXdFKGQpO1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdChiLCBzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIHN0cmluZyBmb3IgdGhlIG51bWJlciB3aXRob3V0IGFueSBwYWRkaW5nXHJcbiAgICAgICAgICogKHdoaWNoIGNhbiBiZSBhZGRlZCBieSBpbnZva2luZyB7QGxpbmsgRm9ybWF0SXRlbSNmb3JtYXR9IGxhdGVyKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3JtYXRGbG9hdFJhd0UoZCkge1xyXG4gICAgICAgICAgICB2YXIgbSA9IE1hdGguYWJzKGQpO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgaWYgKG0gPj0gMWUtMyAmJiBtIDwgMWU3KSB7XHJcbiAgICAgICAgICAgICAgICBkICo9IDFlMTA7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL0ZJWE1FOuWmguaenOS9v+eUqHRvUHJlY2lzaW9u5Lya5raI6Zmk5o6J5Lit6Ze055qEZeaMh+aVsOespuWPt1xyXG4gICAgICAgICAgICB2YXIgcyA9IGQudG9QcmVjaXNpb24odGhpcy5fcHJlY2lzaW9uKTsgLy9TdHJpbmcoZCk7IC8vRklYTUU65pW05pWw6L2s5rWu54K56Zeu6aKYXHJcbiAgICAgICAgICAgIHZhciB0ID0gbmV3IFN0cmluZ0J1ZmZlcl8xLlN0cmluZ0J1ZmZlcihzKTtcclxuICAgICAgICAgICAgdmFyIGU7IC8vIEV4cG9uZW50IHZhbHVlXHJcbiAgICAgICAgICAgIGlmIChkID09IDApIHtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVpID0gcy5pbmRleE9mKCdFJyk7XHJcbiAgICAgICAgICAgICAgICBlID0gcGFyc2VJbnQocy5zdWJzdHJpbmcoZWkgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB0Ll9kZWxldGUoZWksIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJlY2lzaW9uVHJpbSh0KTtcclxuICAgICAgICAgICAgZSAtPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChDaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMb3dlckNhc2UodGhpcy50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdC5hcHBlbmQoRm9ybWF0SXRlbS5FX0xPV0VSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHQuYXBwZW5kKEZvcm1hdEl0ZW0uRV9VUFBFUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGUgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdC5hcHBlbmQoJysnLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQuYXBwZW5kU3RyaW5nKFN0cmluZyhlKSk7IC8vVE9ETzpcclxuICAgICAgICAgICAgdGhpcy56ZXJvUGFkKHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRGbG9hdEYoYiwgZCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuZm9ybWF0RmxvYXRSYXdGKGQpO1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdChiLCBzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIHN0cmluZyBmb3IgdGhlIG51bWJlciB3aXRob3V0IGFueSBwYWRkaW5nXHJcbiAgICAgICAgICogKHdoaWNoIGNhbiBiZSBhZGRlZCBieSBpbnZva2luZyB7QGxpbmsgRm9ybWF0SXRlbSNmb3JtYXR9IGxhdGVyKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3JtYXRGbG9hdFJhd0YoZCkge1xyXG4gICAgICAgICAgICAvL3RvUHJlY2lzaW9uXHJcbiAgICAgICAgICAgIHZhciBzID0gZC50b1ByZWNpc2lvbih0aGlzLl9wcmVjaXNpb24pOyAvL1N0cmluZyhkKTsgLy9GSVhNRTrmlbTmlbDovazlrZfnrKbkuLLkvJrkuKLlpLHlsI/mlbDngrnlkI4x5L2N57K+5bqmXHJcbiAgICAgICAgICAgIGlmIChkICUgMSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IGQudG9GaXhlZCgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdCA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIocyk7XHJcbiAgICAgICAgICAgIHZhciBkaSA9IHMuaW5kZXhPZignLicpO1xyXG4gICAgICAgICAgICB2YXIgZWkgPSBzLmluZGV4T2YoJ0UnKTtcclxuICAgICAgICAgICAgaWYgKGVpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHQuX2RlbGV0ZShlaSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpOyAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHBhcnNlSW50KHMuc3Vic3RyaW5nKGVpICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHogPSBuZXcgU3RyaW5nQnVmZmVyXzEuU3RyaW5nQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguYWJzKGUpOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB6LmFwcGVuZCgnMCcuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0LmRlbGV0ZUNoYXJBdChkaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5hcHBlbmRTdHJpbmdCdWZmZXIoeik7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5pbnNlcnQoZGkgKyBlLCAnLicuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0LmRlbGV0ZUNoYXJBdChkaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0ID0gdC5jaGFyQXQoMCkgPT0gJy0nLmNoYXJDb2RlQXQoMCkgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB0Lmluc2VydFN0cmluZ0J1ZmZlcihhdCwgeik7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5pbnNlcnQoZGksICcuJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvblRyaW0odCk7XHJcbiAgICAgICAgICAgIHRoaXMuemVyb1BhZCh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHQudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0RmxvYXRHKGIsIGQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZWNpc2lvbiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmVjaXNpb24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSA2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzO1xyXG4gICAgICAgICAgICAvLyBEZWNpZGUgd2hldGhlciB0byB1c2UgJWUgb3IgJWYgc3R5bGUuXHJcbiAgICAgICAgICAgIHZhciBtID0gTWF0aC5hYnMoZCk7XHJcbiAgICAgICAgICAgIGlmIChtID09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBDb3VsZCB0ZXN0IGZvciAtMCBhbmQgdXNlIFwiLTBcIiBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgICAgICAgICAgcyA9IFwiMFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG0gPCAxZS00IHx8IG0gPj0gTHVhXzEuTHVhLmlOdW1wb3coMTAsIHRoaXMuX3ByZWNpc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIC8vICVlIHN0eWxlXHJcbiAgICAgICAgICAgICAgICAtLXRoaXMuX3ByZWNpc2lvbjtcclxuICAgICAgICAgICAgICAgIHMgPSB0aGlzLmZvcm1hdEZsb2F0UmF3RShkKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaSA9IHMuaW5kZXhPZignLicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHRyYWlsaW5nIHplcm9lcyBmcm9tIGZyYWN0aW9uYWwgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlaSA9IHMuaW5kZXhPZignRScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlaSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWkgPSBzLmluZGV4T2YoJ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlaSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSAhPSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5fZGVsZXRlKGksIGVpKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyAlZiBzdHlsZVxyXG4gICAgICAgICAgICAgICAgLy8gRm9yICVnIHByZWNpc2lvbiBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMsXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgJWYgcHJlY2lzaW9uIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGZyYWN0aW9uYWwgZGlnaXRzLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBwcm9ibGVtIGJlY2F1c2UgaXQncyBub3Qgb2J2aW91cyBob3cgbWFueSBmcmFjdGlvbmFsXHJcbiAgICAgICAgICAgICAgICAvLyBkaWdpdHMgdG8gZm9ybWF0LCBpdCBjb3VsZCBiZSBtb3JlIHRoYW4gcHJlY2lzaW9uXHJcbiAgICAgICAgICAgICAgICAvLyAod2hlbiAuMDAwMSA8PSBtIDwgMSkgb3IgaXQgY291bGQgYmUgbGVzcyB0aGFuIHByZWNpc2lvblxyXG4gICAgICAgICAgICAgICAgLy8gKHdoZW4gbSA+PSAxKS5cclxuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgdHJ5aW5nIHRvIHdvcmsgb3V0IHRoZSBjb3JyZWN0IHByZWNpc2lvbiB0byB1c2UgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyAlZiBmb3JtYXR0aW5nIHdlIHVzZSBhIHdvcnNlIGNhc2UgdG8gZ2V0IGF0IGxlYXN0IGFsbCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIG5lY2Vzc2FyeSBkaWdpdHMsIHRoZW4gd2UgdHJpbSB1c2luZyBzdHJpbmcgZWRpdGluZy4gIFRoZSB3b3JzdFxyXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBpcyB0aGF0IDMgemVyb2VzIGNvbWUgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQgYmVmb3JlIHRoZXJlXHJcbiAgICAgICAgICAgICAgICAvLyBhcmUgYW55IHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZCA9IHRoaXMuX3ByZWNpc2lvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWNpc2lvbiArPSAzO1xyXG4gICAgICAgICAgICAgICAgcyA9IHRoaXMuZm9ybWF0RmxvYXRSYXdGKGQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZzZCA9IDA7IC8vIEZpcnN0IFNpZ25pZmljYW50IERpZ2l0XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocy5jaGFyQXQoZnNkKSA9PSAnMCcgfHwgcy5jaGFyQXQoZnNkKSA9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICArK2ZzZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBhbGwgdGhlIGRpZ2l0cyB0byB0aGUgbGVmdCBvZiB0aGUgZGVjaW1hbCBwb2ludCBpblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZvcm1hdHRlZCBudW1iZXIgYXJlIHJlcXVpcmVkIGRpZ2l0cyAoZWl0aGVyIHNpZ25pZmljYW50XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG0gPj0gMSBvciAwIHdoZW4gbSA8IDEpLiAgV2Uga25vdyB0aGlzIGJlY2F1c2Ugb3RoZXJ3aXNlIFxyXG4gICAgICAgICAgICAgICAgLy8gbSA+PSAoMTAqKnByZWNpc2lvbikgYW5kIHNvIGZvcm1hdHRpbmcgZmFsbHMgdW5kZXIgdGhlICVlIGNhc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGF0IG1lYW5zIHRoYXQgd2UgY2FuIGFsd2F5cyB0cmltIHRoZSBzdHJpbmcgYXQgZnNkK3JlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAvLyAodGhpcyB3aWxsIHJlbW92ZSB0aGUgZGVjaW1hbCBwb2ludCB3aGVuIG0gPj1cclxuICAgICAgICAgICAgICAgIC8vICgxMCoqKHByZWNpc2lvbi0xKSkuXHJcbiAgICAgICAgICAgICAgICB2YXIgYTIgPSBuZXcgU3RyaW5nQnVmZmVyXzEuU3RyaW5nQnVmZmVyKHMpO1xyXG4gICAgICAgICAgICAgICAgYTIuX2RlbGV0ZShmc2QgKyByZXF1aXJlZCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpOyAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICBpZiAocy5pbmRleE9mKCcuJykgPCBhMi5sZW5ndGgoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gdHJhaWxpbmcgemVyb2VzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkyID0gYTIubGVuZ3RoKCkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhMi5jaGFyQXQoaTIpID09ICcwJy5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEyLmRlbGV0ZUNoYXJBdChpMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhMi5jaGFyQXQoaTIpID09ICcuJy5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEyLmRlbGV0ZUNoYXJBdChpMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcyA9IGEyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mb3JtYXQoYiwgcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdFN0cmluZyhiLCBzKSB7XHJcbiAgICAgICAgICAgIHZhciBwID0gcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZWNpc2lvbiA+PSAwICYmIHRoaXMuX3ByZWNpc2lvbiA8IHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcy5zdWJzdHJpbmcoMCwgdGhpcy5fcHJlY2lzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdChiLCBwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJlY2lzaW9uVHJpbSh0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmVjaXNpb24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSA2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzID0gdC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB2YXIgZGkgPSBzLmluZGV4T2YoJy4nKTtcclxuICAgICAgICAgICAgdmFyIGwgPSB0Lmxlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAoMCA9PSB0aGlzLl9wcmVjaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIHQuX2RlbGV0ZShkaSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpOyAvL1RPRE86XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobCA+IGRpICsgdGhpcy5fcHJlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0Ll9kZWxldGUoZGkgKyB0aGlzLl9wcmVjaXNpb24gKyAxLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7IC8vVE9ETzpcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBsIDw9IGRpICsgdGhpcy5fcHJlY2lzaW9uOyArK2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB0LmFwcGVuZCgnMCcuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgemVyb1BhZCh0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl96ZXJvICYmIHQubGVuZ3RoKCkgPCB0aGlzLl93aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0ID0gdC5jaGFyQXQoMCkgPT0gJy0nLmNoYXJDb2RlQXQoMCkgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0Lmxlbmd0aCgpIDwgdGhpcy5fd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0Lmluc2VydChhdCwgJzAnLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5Gb3JtYXRJdGVtID0gRm9ybWF0SXRlbTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhcmFjdGVyIHVzZWQgaW4gZm9ybWF0dGVkIG91dHB1dCB3aGVuICVlIG9yICVnIGZvcm1hdCBpcyB1c2VkLlxyXG4gICAgICovXHJcbiAgICBGb3JtYXRJdGVtLkVfTE9XRVIgPSAnRScuY2hhckNvZGVBdCgwKTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhcmFjdGVyIHVzZWQgaW4gZm9ybWF0dGVkIG91dHB1dCB3aGVuICVFIG9yICVHIGZvcm1hdCBpcyB1c2VkLlxyXG4gICAgICovXHJcbiAgICBGb3JtYXRJdGVtLkVfVVBQRVIgPSAnRScuY2hhckNvZGVBdCgwKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZvcm1hdEl0ZW0uanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCIuLi9qYXZhL0lucHV0U3RyZWFtXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5Gcm9tUmVhZGVyID0gdm9pZCAwO1xyXG4gICAgY29uc3QgSW5wdXRTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0lucHV0U3RyZWFtXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL0Zyb21SZWFkZXIuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEge0BsaW5rIFJlYWRlcn0gYW5kIGNvbnZlcnRzIHRvIGFuIHtAbGluayBJbnB1dFN0cmVhbX0gYnlcclxuICAgICAqIHJldmVyc2luZyB0aGUgdHJhbnNmb3JtYXRpb24gcGVyZm9ybWVkIGJ5IDxjb2RlPnN0cmluZy5kdW1wPC9jb2RlPi5cclxuICAgICAqIFNpbWlsYXIgdG8ge0BsaW5rIER1bXBlZElucHV0fSB3aGljaCBkb2VzIHRoZSBzYW1lIGpvYiBmb3Ige0BsaW5rXHJcbiAgICAgKiBTdHJpbmd9LiAgVGhpcyBjbGFzcyBpcyB1c2VkIGJ5IHtAbGluayBCYXNlTGlifSdzIGxvYWQgaW4gb3JkZXIgdG9cclxuICAgICAqIGxvYWQgYmluYXJ5IGNodW5rcy5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgRnJvbVJlYWRlciBleHRlbmRzIElucHV0U3RyZWFtXzEuSW5wdXRTdHJlYW0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHJlYWRlcikge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmsocmVhZGFoZWFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWRlci5tYXJrKHJlYWRhaGVhZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0KCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkZXIucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZCgpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9yZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGMgJiAweGZmO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuRnJvbVJlYWRlciA9IEZyb21SZWFkZXI7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gcm9tUmVhZGVyLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9IYXNodGFibGVcIiwgXCIuLi9qYXZhL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiLCBcIi4vRXhwZGVzY1wiLCBcIi4vTHVhXCIsIFwiLi9Qcm90b1wiLCBcIi4vU3ludGF4XCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5GdW5jU3RhdGUgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBIYXNodGFibGVfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0hhc2h0YWJsZVwiKTtcclxuICAgIGNvbnN0IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2phdmEvSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgRXhwZGVzY18xID0gcmVxdWlyZShcIi4vRXhwZGVzY1wiKTtcclxuICAgIGNvbnN0IEx1YV8xID0gcmVxdWlyZShcIi4vTHVhXCIpO1xyXG4gICAgY29uc3QgUHJvdG9fMSA9IHJlcXVpcmUoXCIuL1Byb3RvXCIpO1xyXG4gICAgY29uc3QgU3ludGF4XzEgPSByZXF1aXJlKFwiLi9TeW50YXhcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvRnVuY1N0YXRlLmphdmEjMSAkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIG1vZGVsIGEgZnVuY3Rpb24gZHVyaW5nIGNvbXBpbGF0aW9uLiAgQ29kZSBnZW5lcmF0aW9uIHVzZXNcclxuICAgICAqIHRoaXMgc3RydWN0dXJlIGV4dGVuc2l2ZWx5LiAgTW9zdCBvZiB0aGUgUFVDLVJpbyBmdW5jdGlvbnMgZnJvbVxyXG4gICAgICogbGNvZGUuYyBoYXZlIG1vdmVkIGludG8gdGhpcyBjbGFzcywgYWxvbmd3aXRoIGEgZmV3IGZ1bmN0aW9ucyBmcm9tXHJcbiAgICAgKiBscGFyc2VyLmNcclxuICAgICAqL1xyXG4gICAgY2xhc3MgRnVuY1N0YXRlIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3Rvci4gIE11Y2ggb2YgdGhpcyBpcyB0YWtlbiBmcm9tIDxjb2RlPm9wZW5fZnVuYzwvY29kZT4gaW5cclxuICAgICAgICAgKiA8Y29kZT5scGFyc2VyLmM8L2NvZGU+LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGxzKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAqIFRhYmxlIHRvIGZpbmQgKGFuZCByZXVzZSkgZWxlbWVudHMgaW4gPHZhcj5mLms8L3Zhcj4uICBNYXBzIGZyb21cclxuICAgICAgICAgICAgKiBPYmplY3QgKGEgY29uc3RhbnQgTHVhIHZhbHVlKSB0byBhbiBpbmRleCBpbnRvIDx2YXI+Zi5rPC92YXI+LlxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9oID0gbmV3IEhhc2h0YWJsZV8xLkhhc2h0YWJsZSgpO1xyXG4gICAgICAgICAgICAvKiogRW5jbG9zaW5nIGZ1bmN0aW9uLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqIGNoYWluIG9mIGN1cnJlbnQgYmxvY2tzICovXHJcbiAgICAgICAgICAgIHRoaXMuX2JsID0gbnVsbDsgLy8gPSBudWxsO1xyXG4gICAgICAgICAgICAvKiogbmV4dCBwb3NpdGlvbiB0byBjb2RlLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9wYyA9IDA7IC8vID0gMDtcclxuICAgICAgICAgICAgLyoqIHBjIG9mIGxhc3QganVtcCB0YXJnZXQuICovXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3R0YXJnZXQgPSAtMTtcclxuICAgICAgICAgICAgLyoqIExpc3Qgb2YgcGVuZGluZyBqdW1wcyB0byA8dmFyPnBjPC92YXI+LiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9qcGMgPSBGdW5jU3RhdGUuTk9fSlVNUDtcclxuICAgICAgICAgICAgLyoqIEZpcnN0IGZyZWUgcmVnaXN0ZXIuICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVyZWcgPSAwOyAvLyA9IDA7XHJcbiAgICAgICAgICAgIC8qKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gPHZhcj5rPC92YXI+LiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9uayA9IDA7IC8vID0gMDtcclxuICAgICAgICAgICAgLyoqIG51bWJlciBvZiBlbGVtZW50cyBpbiA8dmFyPnA8L3Zhcj4uICovXHJcbiAgICAgICAgICAgIHRoaXMuX25wID0gMDsgLy8gPSAwO1xyXG4gICAgICAgICAgICAvKiogbnVtYmVyIG9mIGVsZW1lbnRzIGluIDx2YXI+bG9jdmFyczwvdmFyPi4gKi9cclxuICAgICAgICAgICAgdGhpcy5fbmxvY3ZhcnMgPSAwOyAvLyA9IDA7XHJcbiAgICAgICAgICAgIC8qKiBudW1iZXIgb2YgYWN0aXZlIGxvY2FsIHZhcmlhYmxlcy4gKi9cclxuICAgICAgICAgICAgdGhpcy5fbmFjdHZhciA9IDA7IC8vID0gMDtcclxuICAgICAgICAgICAgLyoqIHVwdmFsdWVzIGFzIDgtYml0IGsgYW5kIDgtYml0IGluZm8gKi9cclxuICAgICAgICAgICAgdGhpcy5fdXB2YWx1ZXMgPSBuZXcgQXJyYXkoTHVhXzEuTHVhLk1BWFVQVkFMVUVTKTsgLy9pbnQgW10gXHJcbiAgICAgICAgICAgIC8qKiBkZWNsYXJlZC12YXJpYWJsZSBzdGFjay4gKi9cclxuICAgICAgICAgICAgdGhpcy5fYWN0dmFyID0gbmV3IEFycmF5KEx1YV8xLkx1YS5NQVhWQVJTKTsgLy9zaG9ydFtdIFxyXG4gICAgICAgICAgICB0aGlzLl9mID0gbmV3IFByb3RvXzEuUHJvdG8oKTtcclxuICAgICAgICAgICAgdGhpcy5fZi5pbml0Mihscy5zb3VyY2UsIDIpOyAvLyBkZWZhdWx0IHZhbHVlIGZvciBtYXhzdGFja3NpemU9MlxyXG4gICAgICAgICAgICB0aGlzLl9MID0gbHMuTDtcclxuICAgICAgICAgICAgdGhpcy5fbHMgPSBscztcclxuICAgICAgICAgICAgLy8gICAgcHJldiA9IGxzLmxpbmtmcyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gPGNvZGU+Y2xvc2VfZnVuYzwvY29kZT4gZnJvbSA8Y29kZT5scGFyc2VyLmM8L2NvZGU+LiAqL1xyXG4gICAgICAgIGNsb3NlKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mLmNsb3NlQ29kZSh0aGlzLl9wYyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2YuY2xvc2VMaW5laW5mbyh0aGlzLl9wYyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2YuY2xvc2VLKHRoaXMuX25rKTtcclxuICAgICAgICAgICAgdGhpcy5fZi5jbG9zZVAodGhpcy5fbnApO1xyXG4gICAgICAgICAgICB0aGlzLl9mLmNsb3NlTG9jdmFycyh0aGlzLl9ubG9jdmFycyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2YuY2xvc2VVcHZhbHVlcygpO1xyXG4gICAgICAgICAgICB2YXIgY2hlY2tzID0gdGhpcy5fTC5nQ2hlY2tjb2RlKHRoaXMuX2YpO1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IGNoZWNrc1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IGJsID09IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gZ2V0bG9jdmFyIGZyb20gbHBhcnNlci5jLlxyXG4gICAgICAgICogQWNjZXNzZXMgPGNvZGU+TG9jVmFyPC9jb2RlPnMgb2YgdGhlIHtAbGluayBQcm90b30uXHJcbiAgICAgICAgKi9cclxuICAgICAgICBnZXRsb2N2YXIoaWR4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mLmxvY3ZhcnNbdGhpcy5fYWN0dmFyW2lkeF1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGdW5jdGlvbnMgZnJvbSBsY29kZS5jXHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19jaGVja3N0YWNrLiAqL1xyXG4gICAgICAgIGtDaGVja3N0YWNrKG4pIHtcclxuICAgICAgICAgICAgdmFyIG5ld3N0YWNrID0gdGhpcy5fZnJlZXJlZyArIG47XHJcbiAgICAgICAgICAgIGlmIChuZXdzdGFjayA+IHRoaXMuX2YubWF4c3RhY2tzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3c3RhY2sgPj0gTHVhXzEuTHVhLk1BWFNUQUNLKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbHMueFN5bnRheGVycm9yKFwiZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0b28gY29tcGxleFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2YubWF4c3RhY2tzaXplID0gbmV3c3RhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19jb2RlLiAqL1xyXG4gICAgICAgIGtDb2RlKGksIGxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjaGFyZ2VqcGMoKTtcclxuICAgICAgICAgICAgLy8gUHV0IG5ldyBpbnN0cnVjdGlvbiBpbiBjb2RlIGFycmF5LlxyXG4gICAgICAgICAgICB0aGlzLl9mLmNvZGVBcHBlbmQodGhpcy5fTCwgdGhpcy5fcGMsIGksIGxpbmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGMrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19jb2RlQUJDLiAqL1xyXG4gICAgICAgIGtDb2RlQUJDKG8sIGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgLy8gYXNzZXJ0IGdldE9wTW9kZShvKSA9PSBpQUJDO1xyXG4gICAgICAgICAgICAvLyBhc3NlcnQgZ2V0Qk1vZGUobykgIT0gT1BfQVJHX04gfHwgYiA9PSAwO1xyXG4gICAgICAgICAgICAvLyBhc3NlcnQgZ2V0Q01vZGUobykgIT0gT1BfQVJHX04gfHwgYyA9PSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rQ29kZShMdWFfMS5MdWEuQ1JFQVRFX0FCQyhvLCBhLCBiLCBjKSwgdGhpcy5fbHMubGFzdGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBsdWFLX2NvZGVBQnguICovXHJcbiAgICAgICAga0NvZGVBQngobywgYSwgYmMpIHtcclxuICAgICAgICAgICAgLy8gYXNzZXJ0IGdldE9wTW9kZShvKSA9PSBpQUJ4IHx8IGdldE9wTW9kZShvKSA9PSBpQXNCeCk7XHJcbiAgICAgICAgICAgIC8vIGFzc2VydCBnZXRDTW9kZShvKSA9PSBPUF9BUkdfTik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtDb2RlKEx1YV8xLkx1YS5DUkVBVEVfQUJ4KG8sIGEsIGJjKSwgdGhpcy5fbHMubGFzdGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBsdWFLX2NvZGVBc0J4LiAqL1xyXG4gICAgICAgIGtDb2RlQXNCeChvLCBhLCBiYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rQ29kZUFCeChvLCBhLCBiYyArIEx1YV8xLkx1YS5NQVhBUkdfc0J4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19kaXNjaGFyZ2V2YXJzLiAqL1xyXG4gICAgICAgIGtEaXNjaGFyZ2V2YXJzKGUpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChlLmtpbmQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVkxPQ0FMOlxyXG4gICAgICAgICAgICAgICAgICAgIGUua2luZCA9IEV4cGRlc2NfMS5FeHBkZXNjLlZOT05SRUxPQztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVlVQVkFMOlxyXG4gICAgICAgICAgICAgICAgICAgIGUucmVsb2ModGhpcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfR0VUVVBWQUwsIDAsIGUuaW5mbywgMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WR0xPQkFMOlxyXG4gICAgICAgICAgICAgICAgICAgIGUucmVsb2ModGhpcy5rQ29kZUFCeChMdWFfMS5MdWEuT1BfR0VUR0xPQkFMLCAwLCBlLmluZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVklOREVYRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2ZyZWVyZWcoZS5hdXgpOyAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2ZyZWVyZWcoZS5pbmZvKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICAgICAgICAgIGUucmVsb2ModGhpcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfR0VUVEFCTEUsIDAsIGUuaW5mbywgZS5hdXgpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVlZBUkFSRzpcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVkNBTEw6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rU2V0b25lcmV0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gdGhlcmUgaXMgb25lIHZhbHVlIGF2YWlsYWJsZSAoc29tZXdoZXJlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGx1YUtfZXhwMmFueXJlZy4gKi9cclxuICAgICAgICBrRXhwMmFueXJlZyhlKSB7XHJcbiAgICAgICAgICAgIHRoaXMua0Rpc2NoYXJnZXZhcnMoZSk7XHJcbiAgICAgICAgICAgIGlmIChlLmsgPT0gRXhwZGVzY18xLkV4cGRlc2MuVk5PTlJFTE9DKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWUuaGFzanVtcHMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmZvID49IHRoaXMuX25hY3R2YXIpIC8vIHJlZyBpcyBub3QgYSBsb2NhbD9cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHAycmVnKGUsIGUuaW5mbyk7IC8vIHB1dCB2YWx1ZSBvbiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5rRXhwMm5leHRyZWcoZSk7IC8vIGRlZmF1bHRcclxuICAgICAgICAgICAgcmV0dXJuIGUuaW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19leHAybmV4dHJlZy4gKi9cclxuICAgICAgICBrRXhwMm5leHRyZWcoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmtEaXNjaGFyZ2V2YXJzKGUpO1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVleHAoZSk7XHJcbiAgICAgICAgICAgIHRoaXMua1Jlc2VydmVyZWdzKDEpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cDJyZWcoZSwgdGhpcy5fZnJlZXJlZyAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBsdWFLX2ZpeGxpbmUuICovXHJcbiAgICAgICAga0ZpeGxpbmUobGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mLnNldExpbmVpbmZvKHRoaXMuX3BjIC0gMSwgbGluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGx1YUtfaW5maXguICovXHJcbiAgICAgICAga0luZml4KG9wLCB2KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4XzEuU3ludGF4Lk9QUl9BTkQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rR29pZnRydWUodik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfT1I6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rR29pZmZhbHNlKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXhfMS5TeW50YXguT1BSX0NPTkNBVDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtFeHAybmV4dHJlZyh2KTsgLyogb3BlcmFuZCBtdXN0IGJlIG9uIHRoZSBgc3RhY2snICovXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc251bWVyYWwodikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua0V4cDJSSyh2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpc251bWVyYWwoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZS5rID09IEV4cGRlc2NfMS5FeHBkZXNjLlZLTlVNICYmXHJcbiAgICAgICAgICAgICAgICBlLnQgPT0gRnVuY1N0YXRlLk5PX0pVTVAgJiZcclxuICAgICAgICAgICAgICAgIGUuZiA9PSBGdW5jU3RhdGUuTk9fSlVNUDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19uaWwuICovXHJcbiAgICAgICAga05pbChmcm9tLCBuKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2aW91cztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3BjID4gdGhpcy5fbGFzdHRhcmdldCkgLyogbm8ganVtcHMgdG8gY3VycmVudCBwb3NpdGlvbj8gKi8ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BjID09IDApIC8qIGZ1bmN0aW9uIHN0YXJ0PyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLyogcG9zaXRpb25zIGFyZSBhbHJlYWR5IGNsZWFuICovXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMuX3BjIC0gMTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnN0ciA9IHRoaXMuX2YuY29kZVtwcmV2aW91c107XHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhXzEuTHVhLk9QQ09ERShpbnN0cikgPT0gTHVhXzEuTHVhLk9QX0xPQUROSUwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGZyb20gPSBMdWFfMS5MdWEuQVJHQShpbnN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB0byA9IEx1YV8xLkx1YS5BUkdCKGluc3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGZyb20gPD0gZnJvbSAmJiBmcm9tIDw9IHB0byArIDEpIC8qIGNhbiBjb25uZWN0IGJvdGg/ICovIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBuIC0gMSA+IHB0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2YuY29kZVtwcmV2aW91c10gPSBMdWFfMS5MdWEuU0VUQVJHX0IoaW5zdHIsIGZyb20gKyBuIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfTE9BRE5JTCwgZnJvbSwgZnJvbSArIG4gLSAxLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19udW1iZXJLLiAqL1xyXG4gICAgICAgIGtOdW1iZXJLKHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkayhMdWFfMS5MdWEudmFsdWVPZk51bWJlcihyKSk7IC8vVE9ETzpMLT5MdWFcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19wb3NmaXguICovXHJcbiAgICAgICAga1Bvc2ZpeChvcCwgZTEsIGUyKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4XzEuU3ludGF4Lk9QUl9BTkQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLyogbGlzdCBtdXN0IGJlIGNsb3NlZCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIyBhc3NlcnQgZTEudCA9PSBOT19KVU1QXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rRGlzY2hhcmdldmFycyhlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgZTIuZiA9IHRoaXMua0NvbmNhdChlMi5mLCBlMS5mKTtcclxuICAgICAgICAgICAgICAgICAgICBlMS5jb3B5KGUyKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXhfMS5TeW50YXguT1BSX09SOlxyXG4gICAgICAgICAgICAgICAgICAgIC8qIGxpc3QgbXVzdCBiZSBjbG9zZWQgKi9cclxuICAgICAgICAgICAgICAgICAgICAvLyMgYXNzZXJ0IGUxLmYgPT0gTk9fSlVNUFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua0Rpc2NoYXJnZXZhcnMoZTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUyLnQgPSB0aGlzLmtDb25jYXQoZTIudCwgZTEudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZTEuY29weShlMik7IC8vVE9ETzpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4XzEuU3ludGF4Lk9QUl9DT05DQVQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rRXhwMnZhbChlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUyLmsgPT0gRXhwZGVzY18xLkV4cGRlc2MuVlJFTE9DQUJMRSAmJiBMdWFfMS5MdWEuT1BDT0RFKHRoaXMuZ2V0Y29kZShlMikpID09IEx1YV8xLkx1YS5PUF9DT05DQVQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8jIGFzc2VydCBlMS5pbmZvID09IEx1YS5BUkdCKGdldGNvZGUoZTIpKS0xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZWV4cChlMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Y29kZShlMiwgTHVhXzEuTHVhLlNFVEFSR19CKHRoaXMuZ2V0Y29kZShlMiksIGUxLmluZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZTEuayA9IGUyLms7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUxLmluZm8gPSBlMi5pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rRXhwMm5leHRyZWcoZTIpOyAvKiBvcGVyYW5kIG11c3QgYmUgb24gdGhlICdzdGFjaycgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlYXJpdGgoTHVhXzEuTHVhLk9QX0NPTkNBVCwgZTEsIGUyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfQUREOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWFyaXRoKEx1YV8xLkx1YS5PUF9BREQsIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfU1VCOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWFyaXRoKEx1YV8xLkx1YS5PUF9TVUIsIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfTVVMOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWFyaXRoKEx1YV8xLkx1YS5PUF9NVUwsIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfRElWOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWFyaXRoKEx1YV8xLkx1YS5PUF9ESVYsIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfTU9EOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWFyaXRoKEx1YV8xLkx1YS5PUF9NT0QsIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfUE9XOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWFyaXRoKEx1YV8xLkx1YS5PUF9QT1csIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfRVE6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlY29tcChMdWFfMS5MdWEuT1BfRVEsIHRydWUsIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfTkU6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlY29tcChMdWFfMS5MdWEuT1BfRVEsIGZhbHNlLCBlMSwgZTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXhfMS5TeW50YXguT1BSX0xUOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWNvbXAoTHVhXzEuTHVhLk9QX0xULCB0cnVlLCBlMSwgZTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXhfMS5TeW50YXguT1BSX0xFOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWNvbXAoTHVhXzEuTHVhLk9QX0xFLCB0cnVlLCBlMSwgZTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXhfMS5TeW50YXguT1BSX0dUOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWNvbXAoTHVhXzEuTHVhLk9QX0xULCBmYWxzZSwgZTEsIGUyKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4XzEuU3ludGF4Lk9QUl9HRTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVjb21wKEx1YV8xLkx1YS5PUF9MRSwgZmFsc2UsIGUxLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8jIGFzc2VydCBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGx1YUtfcHJlZml4LiAqL1xyXG4gICAgICAgIGtQcmVmaXgob3AsIGUpIHtcclxuICAgICAgICAgICAgdmFyIGUyID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7IC8vIFRPRE86XHJcbiAgICAgICAgICAgIGUyLmluaXQoRXhwZGVzY18xLkV4cGRlc2MuVktOVU0sIDApO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfTUlOVVM6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2luZCA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WSykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtFeHAyYW55cmVnKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVhcml0aChMdWFfMS5MdWEuT1BfVU5NLCBlLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheF8xLlN5bnRheC5PUFJfTk9UOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZW5vdChlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4XzEuU3ludGF4Lk9QUl9MRU46XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rRXhwMmFueXJlZyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVhcml0aChMdWFfMS5MdWEuT1BfTEVOLCBlLCBlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBsdWFLX3Jlc2VydmVyZWdzLiAqL1xyXG4gICAgICAgIGtSZXNlcnZlcmVncyhuKSB7XHJcbiAgICAgICAgICAgIHRoaXMua0NoZWNrc3RhY2sobik7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVyZWcgKz0gbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19yZXQuICovXHJcbiAgICAgICAga1JldChmaXJzdCwgbnJldCkge1xyXG4gICAgICAgICAgICB0aGlzLmtDb2RlQUJDKEx1YV8xLkx1YS5PUF9SRVRVUk4sIGZpcnN0LCBucmV0ICsgMSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGx1YUtfc2V0bXVsdHJldCAoaW4gbGNvZGUuaCkuICovXHJcbiAgICAgICAga1NldG11bHRyZXQoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmtTZXRyZXR1cm5zKGUsIEx1YV8xLkx1YS5NVUxUUkVUKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhS19zZXRvbmVyZXQuICovXHJcbiAgICAgICAga1NldG9uZXJldChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmtpbmQgPT0gRXhwZGVzY18xLkV4cGRlc2MuVkNBTEwpIC8vIGV4cHJlc3Npb24gaXMgYW4gb3BlbiBmdW5jdGlvbiBjYWxsP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZS5ub25yZWxvYyhMdWFfMS5MdWEuQVJHQSh0aGlzLmdldGNvZGUoZSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlLmtpbmQgPT0gRXhwZGVzY18xLkV4cGRlc2MuVlZBUkFSRykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRhcmdiKGUsIDIpO1xyXG4gICAgICAgICAgICAgICAgZS5raW5kID0gRXhwZGVzY18xLkV4cGRlc2MuVlJFTE9DQUJMRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBsdWFLX3NldHJldHVybnMuICovXHJcbiAgICAgICAga1NldHJldHVybnMoZSwgbnJlc3VsdHMpIHtcclxuICAgICAgICAgICAgaWYgKGUua2luZCA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WQ0FMTCkgLy8gZXhwcmVzc2lvbiBpcyBhbiBvcGVuIGZ1bmN0aW9uIGNhbGw/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldGFyZ2MoZSwgbnJlc3VsdHMgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlLmtpbmQgPT0gRXhwZGVzY18xLkV4cGRlc2MuVlZBUkFSRykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRhcmdiKGUsIG5yZXN1bHRzICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldGFyZ2EoZSwgdGhpcy5fZnJlZXJlZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtSZXNlcnZlcmVncygxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBsdWFLX3N0cmluZ0suICovXHJcbiAgICAgICAga1N0cmluZ0socykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRrKHMgLyouaW50ZXJuKCkqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZGsobykge1xyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IG87XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5faC5fZ2V0KGhhc2gpOyAvL1RPRE86Z2V0XHJcbiAgICAgICAgICAgIGlmICh2ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBhc3NlcnRcclxuICAgICAgICAgICAgICAgIHJldHVybiB2OyAvL1RPRE86XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29uc3RhbnQgbm90IGZvdW5kOyBjcmVhdGUgYSBuZXcgZW50cnlcclxuICAgICAgICAgICAgdGhpcy5fZi5jb25zdGFudEFwcGVuZCh0aGlzLl9uaywgbyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2gucHV0KGhhc2gsIG5ldyBOdW1iZXIodGhpcy5fbmspKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmsrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29kZWFyaXRoKG9wLCBlMSwgZTIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3Rmb2xkaW5nKG9wLCBlMSwgZTIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvMSA9IHRoaXMua0V4cDJSSyhlMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbzIgPSAob3AgIT0gTHVhXzEuTHVhLk9QX1VOTSAmJiBvcCAhPSBMdWFfMS5MdWEuT1BfTEVOKSA/IHRoaXMua0V4cDJSSyhlMikgOiAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlZXhwKGUyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJlZWV4cChlMSk7XHJcbiAgICAgICAgICAgICAgICBlMS5pbmZvID0gdGhpcy5rQ29kZUFCQyhvcCwgMCwgbzEsIG8yKTtcclxuICAgICAgICAgICAgICAgIGUxLmsgPSBFeHBkZXNjXzEuRXhwZGVzYy5WUkVMT0NBQkxFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0Zm9sZGluZyhvcCwgZTEsIGUyKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gMDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzbnVtZXJhbChlMSkgfHwgIXRoaXMuaXNudW1lcmFsKGUyKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHYxID0gZTEubnZhbDtcclxuICAgICAgICAgICAgdmFyIHYyID0gZTIubnZhbDtcclxuICAgICAgICAgICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfQUREOlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSB2MSArIHYyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfU1VCOlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSB2MSAtIHYyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfTVVMOlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSB2MSAqIHYyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfRElWOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2MiA9PSAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLyogZG8gbm90IGF0dGVtcHQgdG8gZGl2aWRlIGJ5IDAgKi9cclxuICAgICAgICAgICAgICAgICAgICByID0gdjEgLyB2MjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX01PRDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodjIgPT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8qIGRvIG5vdCBhdHRlbXB0IHRvIGRpdmlkZSBieSAwICovXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHYxICUgdjI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9QT1c6XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IEx1YV8xLkx1YS5pTnVtcG93KHYxLCB2Mik7IC8vVE9ETzpMLT5MdWFcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX1VOTTpcclxuICAgICAgICAgICAgICAgICAgICByID0gLXYxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfTEVOOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLyogbm8gY29uc3RhbnQgZm9sZGluZyBmb3IgJ2xlbicgKi9cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8jIGFzc2VydCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzTmFOKHIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvKiBkbyBub3QgYXR0ZW1wdCB0byBwcm9kdWNlIE5hTiAqL1xyXG4gICAgICAgICAgICBlMS5udmFsID0gcjtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvZGVub3QoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmtEaXNjaGFyZ2V2YXJzKGUpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGUuaykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WTklMOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WRkFMU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgZS5rID0gRXhwZGVzY18xLkV4cGRlc2MuVlRSVUU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZLOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WS05VTTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVlRSVUU6XHJcbiAgICAgICAgICAgICAgICAgICAgZS5rID0gRXhwZGVzY18xLkV4cGRlc2MuVkZBTFNFO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WSk1QOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52ZXJ0anVtcChlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVlJFTE9DQUJMRTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVk5PTlJFTE9DOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY2hhcmdlMmFueXJlZyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWVleHAoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5pbmZvID0gdGhpcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfTk9ULCAwLCBlLmluZm8sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuayA9IEV4cGRlc2NfMS5FeHBkZXNjLlZSRUxPQ0FCTEU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIyBhc3NlcnQgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiBpbnRlcmNoYW5nZSB0cnVlIGFuZCBmYWxzZSBsaXN0cyAqL1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGUuZjtcclxuICAgICAgICAgICAgICAgIGUuZiA9IGUudDtcclxuICAgICAgICAgICAgICAgIGUudCA9IHRlbXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmV2YWx1ZXMoZS5mKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmV2YWx1ZXMoZS50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZldmFsdWVzKGxpc3QpIHtcclxuICAgICAgICAgICAgZm9yICg7IGxpc3QgIT0gRnVuY1N0YXRlLk5PX0pVTVA7IGxpc3QgPSB0aGlzLmdldGp1bXAobGlzdCkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGNodGVzdHJlZyhsaXN0LCBMdWFfMS5MdWEuTk9fUkVHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzY2hhcmdlanBjKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGNobGlzdGF1eCh0aGlzLl9qcGMsIHRoaXMuX3BjLCBMdWFfMS5MdWEuTk9fUkVHLCB0aGlzLl9wYyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2pwYyA9IEZ1bmNTdGF0ZS5OT19KVU1QO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNjaGFyZ2UycmVnKGUsIHJlZykge1xyXG4gICAgICAgICAgICB0aGlzLmtEaXNjaGFyZ2V2YXJzKGUpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGUuaykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WTklMOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua05pbChyZWcsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WRkFMU0U6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZUUlVFOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua0NvZGVBQkMoTHVhXzEuTHVhLk9QX0xPQURCT09MLCByZWcsIChlLmsgPT0gRXhwZGVzY18xLkV4cGRlc2MuVlRSVUUgPyAxIDogMCksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WSzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtDb2RlQUJ4KEx1YV8xLkx1YS5PUF9MT0FESywgcmVnLCBlLmluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WS05VTTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtDb2RlQUJ4KEx1YV8xLkx1YS5PUF9MT0FESywgcmVnLCB0aGlzLmtOdW1iZXJLKGUubnZhbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WUkVMT0NBQkxFOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0YXJnYShlLCByZWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WTk9OUkVMT0M6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZyAhPSBlLmluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfTU9WRSwgcmVnLCBlLmluZm8sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVlZPSUQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZKTVA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIC8vIyBhc3NlcnQgZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlLm5vbnJlbG9jKHJlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cDJyZWcoZSwgcmVnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY2hhcmdlMnJlZyhlLCByZWcpO1xyXG4gICAgICAgICAgICBpZiAoZS5rID09IEV4cGRlc2NfMS5FeHBkZXNjLlZKTVApIHtcclxuICAgICAgICAgICAgICAgIGUudCA9IHRoaXMua0NvbmNhdChlLnQsIGUuaW5mbyk7IC8qIHB1dCB0aGlzIGp1bXAgaW4gYHQnIGxpc3QgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZS5oYXNqdW1wcygpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcF9mID0gRnVuY1N0YXRlLk5PX0pVTVA7IC8qIHBvc2l0aW9uIG9mIGFuIGV2ZW50dWFsIExPQUQgZmFsc2UgKi9cclxuICAgICAgICAgICAgICAgIHZhciBwX3QgPSBGdW5jU3RhdGUuTk9fSlVNUDsgLyogcG9zaXRpb24gb2YgYW4gZXZlbnR1YWwgTE9BRCB0cnVlICovXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWVkX3ZhbHVlKGUudCkgfHwgdGhpcy5uZWVkX3ZhbHVlKGUuZikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmogPSAoZS5rID09IEV4cGRlc2NfMS5FeHBkZXNjLlZKTVApID8gRnVuY1N0YXRlLk5PX0pVTVAgOiB0aGlzLmtKdW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcF9mID0gdGhpcy5jb2RlX2xhYmVsKHJlZywgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcF90ID0gdGhpcy5jb2RlX2xhYmVsKHJlZywgMSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rUGF0Y2h0b2hlcmUoZmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFscG9zID0gdGhpcy5rR2V0bGFiZWwoKTsgLyogcG9zaXRpb24gYWZ0ZXIgd2hvbGUgZXhwcmVzc2lvbiAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaGxpc3RhdXgoZS5mLCBmaW5hbHBvcywgcmVnLCBwX2YpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaGxpc3RhdXgoZS50LCBmaW5hbHBvcywgcmVnLCBwX3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUuaW5pdChFeHBkZXNjXzEuRXhwZGVzYy5WTk9OUkVMT0MsIHJlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvZGVfbGFiZWwoYSwgYiwganVtcCkge1xyXG4gICAgICAgICAgICB0aGlzLmtHZXRsYWJlbCgpOyAvKiB0aG9zZSBpbnN0cnVjdGlvbnMgbWF5IGJlIGp1bXAgdGFyZ2V0cyAqL1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfTE9BREJPT0wsIGEsIGIsIGp1bXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBjaGVjayB3aGV0aGVyIGxpc3QgaGFzIGFueSBqdW1wIHRoYXQgZG8gbm90IHByb2R1Y2UgYSB2YWx1ZVxyXG4gICAgICAgICAqIChvciBwcm9kdWNlIGFuIGludmVydGVkIHZhbHVlKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5lZWRfdmFsdWUobGlzdCkge1xyXG4gICAgICAgICAgICBmb3IgKDsgbGlzdCAhPSBGdW5jU3RhdGUuTk9fSlVNUDsgbGlzdCA9IHRoaXMuZ2V0anVtcChsaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldGp1bXBjb250cm9sKGxpc3QpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluc3RyID0gdGhpcy5fZi5jb2RlW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5PUENPREUoaW5zdHIpICE9IEx1YV8xLkx1YS5PUF9URVNUU0VUKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLyogbm90IGZvdW5kICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZyZWVleHAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZS5raW5kID09IEV4cGRlc2NfMS5FeHBkZXNjLlZOT05SRUxPQykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2ZyZWVyZWcoZS5pbmZvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgZnJlZXJlZyhmcmVlcmVnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVyZWcgPSBmcmVlcmVnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgZnJlZXJlZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyZWVyZWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fZnJlZXJlZyhyZWcpIHtcclxuICAgICAgICAgICAgaWYgKCFMdWFfMS5MdWEuSVNLKHJlZykgJiYgcmVnID49IHRoaXMuX25hY3R2YXIpIHtcclxuICAgICAgICAgICAgICAgIC0tdGhpcy5fZnJlZXJlZztcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCByZWcgPT0gZnJlZXJlZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRjb2RlKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2YuY29kZVtlLmluZm9dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRjb2RlKGUsIGNvZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZi5jb2RlW2UuaW5mb10gPSBjb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBzZWFyY2h2YXIgZnJvbSBscGFyc2VyLmMgKi9cclxuICAgICAgICBzZWFyY2h2YXIobikge1xyXG4gICAgICAgICAgICAvLyBjYXV0aW9uOiBkZXNjZW5kaW5nIGxvb3AgKGluIGVtdWxhdGlvbiBvZiBQVUMtUmlvKS5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX25hY3R2YXIgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gdGhpcy5nZXRsb2N2YXIoaSkudmFybmFtZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7IC8vIG5vdCBmb3VuZFxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRhcmdhKGUsIGEpIHtcclxuICAgICAgICAgICAgdmFyIGF0ID0gZS5pbmZvO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IHRoaXMuX2YuY29kZTsgLy9pbnRbXSBcclxuICAgICAgICAgICAgY29kZVthdF0gPSBMdWFfMS5MdWEuU0VUQVJHX0EoY29kZVthdF0sIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRhcmdiKGUsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGF0ID0gZS5pbmZvO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IHRoaXMuX2YuY29kZTsgLy9pbnRbXSBcclxuICAgICAgICAgICAgY29kZVthdF0gPSBMdWFfMS5MdWEuU0VUQVJHX0IoY29kZVthdF0sIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRhcmdjKGUsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGF0ID0gZS5pbmZvO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IHRoaXMuX2YuY29kZTsgLy9pbnRbXVxyXG4gICAgICAgICAgICBjb2RlW2F0XSA9IEx1YV8xLkx1YS5TRVRBUkdfQyhjb2RlW2F0XSwgYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIDxjb2RlPmx1YUtfZ2V0bGFiZWw8L2NvZGU+LiAqL1xyXG4gICAgICAgIGtHZXRsYWJlbCgpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdHRhcmdldCA9IHRoaXMuX3BjO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogRXF1aXZhbGVudCB0byA8Y29kZT5sdWFLX2NvbmNhdDwvY29kZT4uXHJcbiAgICAgICAgKiBsMSB3YXMgYW4gaW50Kiwgbm93IHBhc3NpbmcgYmFjayBhcyByZXN1bHQuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBrQ29uY2F0KGwxLCBsMikge1xyXG4gICAgICAgICAgICBpZiAobDIgPT0gRnVuY1N0YXRlLk5PX0pVTVApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbDE7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGwxID09IEZ1bmNTdGF0ZS5OT19KVU1QKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwyO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gbDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgobmV4dCA9IHRoaXMuZ2V0anVtcChsaXN0KSkgIT0gRnVuY1N0YXRlLk5PX0pVTVApIC8qIGZpbmQgbGFzdCBlbGVtZW50ICovXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpeGp1bXAobGlzdCwgbDIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIDxjb2RlPmx1YUtfcGF0Y2hsaXN0PC9jb2RlPi4gKi9cclxuICAgICAgICBrUGF0Y2hsaXN0KGxpc3QsIHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IHRoaXMuX3BjKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rUGF0Y2h0b2hlcmUobGlzdCk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8jIGFzc2VydCB0YXJnZXQgPCBwY1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaGxpc3RhdXgobGlzdCwgdGFyZ2V0LCBMdWFfMS5MdWEuTk9fUkVHLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGNobGlzdGF1eChsaXN0LCB2dGFyZ2V0LCByZWcsIGR0YXJnZXQpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGxpc3QgIT0gRnVuY1N0YXRlLk5PX0pVTVApIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXRqdW1wKGxpc3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0Y2h0ZXN0cmVnKGxpc3QsIHJlZykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhqdW1wKGxpc3QsIHZ0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4anVtcChsaXN0LCBkdGFyZ2V0KTsgLyoganVtcCB0byBkZWZhdWx0IHRhcmdldCAqL1xyXG4gICAgICAgICAgICAgICAgbGlzdCA9IG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0Y2h0ZXN0cmVnKG5vZGUsIHJlZykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0anVtcGNvbnRyb2wobm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gdGhpcy5fZi5jb2RlOyAvL2ludCBbXSBcclxuICAgICAgICAgICAgdmFyIGluc3RyID0gY29kZVtpXTtcclxuICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5PUENPREUoaW5zdHIpICE9IEx1YV8xLkx1YS5PUF9URVNUU0VUKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvKiBjYW5ub3QgcGF0Y2ggb3RoZXIgaW5zdHJ1Y3Rpb25zICovXHJcbiAgICAgICAgICAgIGlmIChyZWcgIT0gTHVhXzEuTHVhLk5PX1JFRyAmJiByZWcgIT0gTHVhXzEuTHVhLkFSR0IoaW5zdHIpKVxyXG4gICAgICAgICAgICAgICAgY29kZVtpXSA9IEx1YV8xLkx1YS5TRVRBUkdfQShpbnN0ciwgcmVnKTtcclxuICAgICAgICAgICAgZWxzZSAvKiBubyByZWdpc3RlciB0byBwdXQgdmFsdWUgb3IgcmVnaXN0ZXIgYWxyZWFkeSBoYXMgdGhlIHZhbHVlICovXHJcbiAgICAgICAgICAgICAgICBjb2RlW2ldID0gTHVhXzEuTHVhLkNSRUFURV9BQkMoTHVhXzEuTHVhLk9QX1RFU1QsIEx1YV8xLkx1YS5BUkdCKGluc3RyKSwgMCwgTHVhXzEuTHVhLkFSR0MoaW5zdHIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldGp1bXBjb250cm9sKGF0KSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gdGhpcy5fZi5jb2RlOyAvL2ludCBbXVxyXG4gICAgICAgICAgICBpZiAoYXQgPj0gMSAmJiB0aGlzLnRlc3RUTW9kZShMdWFfMS5MdWEuT1BDT0RFKGNvZGVbYXQgLSAxXSkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0IC0gMTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgb3Btb2RlKHQsIGEsIGIsIGMsIG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuICgodCA8PCA3KSB8IChhIDw8IDYpIHwgKGIgPDwgNCkgfCAoYyA8PCAyKSB8IG0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRPcE1vZGUobSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRnVuY1N0YXRlLk9QTU9ERVttXSAmIDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlc3RBTW9kZShtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoRnVuY1N0YXRlLk9QTU9ERVttXSAmICgxIDw8IDYpKSAhPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXN0VE1vZGUobSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKEZ1bmNTdGF0ZS5PUE1PREVbbV0gJiAoMSA8PCA3KSkgIT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gPGNvZGU+bHVhS19wYXRjaHRvaGVyZTwvY29kZT4uICovXHJcbiAgICAgICAga1BhdGNodG9oZXJlKGxpc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5rR2V0bGFiZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5fanBjID0gdGhpcy5rQ29uY2F0KHRoaXMuX2pwYywgbGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpeGp1bXAoYXQsIGRlc3QpIHtcclxuICAgICAgICAgICAgdmFyIGptcCA9IHRoaXMuX2YuY29kZVthdF07XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkZXN0IC0gKGF0ICsgMSk7XHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgZGVzdCAhPSBOT19KVU1QXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQpID4gTHVhXzEuTHVhLk1BWEFSR19zQngpXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9scy54U3ludGF4ZXJyb3IoXCJjb250cm9sIHN0cnVjdHVyZSB0b28gbG9uZ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5fZi5jb2RlW2F0XSA9IEx1YV8xLkx1YS5TRVRBUkdfc0J4KGptcCwgb2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0anVtcChhdCkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gTHVhXzEuTHVhLkFSR3NCeCh0aGlzLl9mLmNvZGVbYXRdKTtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBGdW5jU3RhdGUuTk9fSlVNUCkgLyogcG9pbnQgdG8gaXRzZWxmIHJlcHJlc2VudHMgZW5kIG9mIGxpc3QgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jU3RhdGUuTk9fSlVNUDsgLyogZW5kIG9mIGxpc3QgKi9cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhdCArIDEpICsgb2Zmc2V0OyAvKiB0dXJuIG9mZnNldCBpbnRvIGFic29sdXRlIHBvc2l0aW9uICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIDxjb2RlPmx1YUtfanVtcDwvY29kZT4uICovXHJcbiAgICAgICAga0p1bXAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRfanBjID0gdGhpcy5fanBjOyAvKiBzYXZlIGxpc3Qgb2YganVtcHMgdG8gaGVyZSAqL1xyXG4gICAgICAgICAgICB0aGlzLl9qcGMgPSBGdW5jU3RhdGUuTk9fSlVNUDtcclxuICAgICAgICAgICAgdmFyIGogPSB0aGlzLmtDb2RlQXNCeChMdWFfMS5MdWEuT1BfSk1QLCAwLCBGdW5jU3RhdGUuTk9fSlVNUCk7XHJcbiAgICAgICAgICAgIGogPSB0aGlzLmtDb25jYXQoaiwgb2xkX2pwYyk7IC8qIGtlZXAgdGhlbSBvbiBob2xkICovXHJcbiAgICAgICAgICAgIHJldHVybiBqO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byA8Y29kZT5sdWFLX3N0b3JldmFyPC9jb2RlPi4gKi9cclxuICAgICAgICBrU3RvcmV2YXIoX3ZhciwgZXgpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfdmFyLmspIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVkxPQ0FMOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlZXhwKGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHAycmVnKGV4LCBfdmFyLmluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WVVBWQUw6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMua0V4cDJhbnlyZWcoZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtDb2RlQUJDKEx1YV8xLkx1YS5PUF9TRVRVUFZBTCwgZSwgX3Zhci5pbmZvLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WR0xPQkFMOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUyID0gdGhpcy5rRXhwMmFueXJlZyhleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua0NvZGVBQngoTHVhXzEuTHVhLk9QX1NFVEdMT0JBTCwgZTIsIF92YXIuaW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVklOREVYRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZTMgPSB0aGlzLmtFeHAyUksoZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtDb2RlQUJDKEx1YV8xLkx1YS5PUF9TRVRUQUJMRSwgX3Zhci5pbmZvLCBfdmFyLmF1eCwgZTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogaW52YWxpZCB2YXIga2luZCB0byBzdG9yZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyMgYXNzZXJ0IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVleHAoZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byA8Y29kZT5sdWFLX2luZGV4ZWQ8L2NvZGU+LiAqL1xyXG4gICAgICAgIGtJbmRleGVkKHQsIGspIHtcclxuICAgICAgICAgICAgdC5hdXggPSB0aGlzLmtFeHAyUksoayk7XHJcbiAgICAgICAgICAgIHQuayA9IEV4cGRlc2NfMS5FeHBkZXNjLlZJTkRFWEVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byA8Y29kZT5sdWFLX2V4cDJSSzwvY29kZT4uICovXHJcbiAgICAgICAga0V4cDJSSyhlKSB7XHJcbiAgICAgICAgICAgIHRoaXMua0V4cDJ2YWwoZSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZS5rKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZLTlVNOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WVFJVRTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVkZBTFNFOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WTklMOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uayA8PSBMdWFfMS5MdWEuTUFYSU5ERVhSSykgLyogY29uc3RhbnQgZml0IGluIFJLIG9wZXJhbmQ/ICovIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5pbmZvID0gKGUuayA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WTklMKSA/IHRoaXMubmlsSygpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLmsgPT0gRXhwZGVzY18xLkV4cGRlc2MuVktOVU0pID8gdGhpcy5rTnVtYmVySyhlLm52YWwpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvb2xLKGUuayA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WVFJVRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuayA9IEV4cGRlc2NfMS5FeHBkZXNjLlZLO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5pbmZvIHwgTHVhXzEuTHVhLkJJVFJLO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WSzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pbmZvIDw9IEx1YV8xLkx1YS5NQVhJTkRFWFJLKSAvKiBjb25zdGFudCBmaXQgaW4gYXJnQz8gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaW5mbyB8IEx1YV8xLkx1YS5CSVRSSztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiBub3QgYSBjb25zdGFudCBpbiB0aGUgcmlnaHQgcmFuZ2U6IHB1dCBpdCBpbiBhIHJlZ2lzdGVyICovXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtFeHAyYW55cmVnKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byA8Y29kZT5sdWFLX2V4cDJ2YWw8L2NvZGU+LiAqL1xyXG4gICAgICAgIGtFeHAydmFsKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUuaGFzanVtcHMoKSlcclxuICAgICAgICAgICAgICAgIHRoaXMua0V4cDJhbnlyZWcoZSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMua0Rpc2NoYXJnZXZhcnMoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJvb2xLKGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkayhMdWFfMS5MdWEudmFsdWVPZkJvb2xlYW4oYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuaWxLKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRrKEx1YV8xLkx1YS5OSUwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byA8Y29kZT5sdWFLX2dvaWZmYWxzZTwvY29kZT4uICovXHJcbiAgICAgICAga0dvaWZmYWxzZShlKSB7XHJcbiAgICAgICAgICAgIHZhciBsajsgLyogcGMgb2YgbGFzdCBqdW1wICovXHJcbiAgICAgICAgICAgIHRoaXMua0Rpc2NoYXJnZXZhcnMoZSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZS5rKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZOSUw6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZGQUxTRTpcclxuICAgICAgICAgICAgICAgICAgICBsaiA9IEZ1bmNTdGF0ZS5OT19KVU1QOyAvKiBhbHdheXMgZmFsc2U7IGRvIG5vdGhpbmcgKi9cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVlRSVUU6XHJcbiAgICAgICAgICAgICAgICAgICAgbGogPSB0aGlzLmtKdW1wKCk7IC8qIGFsd2F5cyBqdW1wICovXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZKTVA6XHJcbiAgICAgICAgICAgICAgICAgICAgbGogPSBlLmluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGxqID0gdGhpcy5qdW1wb25jb25kKGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUudCA9IHRoaXMua0NvbmNhdChlLnQsIGxqKTsgLyogaW5zZXJ0IGxhc3QganVtcCBpbiBgdCcgbGlzdCAqL1xyXG4gICAgICAgICAgICB0aGlzLmtQYXRjaHRvaGVyZShlLmYpO1xyXG4gICAgICAgICAgICBlLmYgPSBGdW5jU3RhdGUuTk9fSlVNUDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gPGNvZGU+bHVhS19nb2lmdHJ1ZTwvY29kZT4uICovXHJcbiAgICAgICAga0dvaWZ0cnVlKGUpIHtcclxuICAgICAgICAgICAgdmFyIGxqOyAvKiBwYyBvZiBsYXN0IGp1bXAgKi9cclxuICAgICAgICAgICAgdGhpcy5rRGlzY2hhcmdldmFycyhlKTtcclxuICAgICAgICAgICAgc3dpdGNoIChlLmspIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRXhwZGVzY18xLkV4cGRlc2MuVks6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZLTlVNOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WVFJVRTpcclxuICAgICAgICAgICAgICAgICAgICBsaiA9IEZ1bmNTdGF0ZS5OT19KVU1QOyAvKiBhbHdheXMgdHJ1ZTsgZG8gbm90aGluZyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFeHBkZXNjXzEuRXhwZGVzYy5WRkFMU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgbGogPSB0aGlzLmtKdW1wKCk7IC8qIGFsd2F5cyBqdW1wICovXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEV4cGRlc2NfMS5FeHBkZXNjLlZKTVA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZlcnRqdW1wKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxqID0gZS5pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBsaiA9IHRoaXMuanVtcG9uY29uZChlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZS5mID0gdGhpcy5rQ29uY2F0KGUuZiwgbGopOyAvKiBpbnNlcnQgbGFzdCBqdW1wIGluIGBmJyBsaXN0ICovXHJcbiAgICAgICAgICAgIHRoaXMua1BhdGNodG9oZXJlKGUudCk7XHJcbiAgICAgICAgICAgIGUudCA9IEZ1bmNTdGF0ZS5OT19KVU1QO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnZlcnRqdW1wKGUpIHtcclxuICAgICAgICAgICAgdmFyIGF0ID0gdGhpcy5nZXRqdW1wY29udHJvbChlLmluZm8pO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IHRoaXMuX2YuY29kZTsgLy9pbnQgW11cclxuICAgICAgICAgICAgdmFyIGluc3RyID0gY29kZVthdF07XHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgdGVzdFRNb2RlKEx1YS5PUENPREUoaW5zdHIpKSAmJiBMdWEuT1BDT0RFKGluc3RyKSAhPSBMdWEuT1BfVEVTVFNFVCAmJiBMdWEuT1BDT0RFKGluc3RyKSAhPSBMdWEuT1BfVEVTVFxyXG4gICAgICAgICAgICBjb2RlW2F0XSA9IEx1YV8xLkx1YS5TRVRBUkdfQShpbnN0ciwgKEx1YV8xLkx1YS5BUkdBKGluc3RyKSA9PSAwID8gMSA6IDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAganVtcG9uY29uZChlLCBjb25kKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmsgPT0gRXhwZGVzY18xLkV4cGRlc2MuVlJFTE9DQUJMRSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGllID0gdGhpcy5nZXRjb2RlKGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5PUENPREUoaWUpID09IEx1YV8xLkx1YS5PUF9OT1QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYy0tOyAvKiByZW1vdmUgcHJldmlvdXMgT1BfTk9UICovXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGp1bXAoTHVhXzEuTHVhLk9QX1RFU1QsIEx1YV8xLkx1YS5BUkdCKGllKSwgMCwgY29uZCA/IDAgOiAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIGVsc2UgZ28gdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY2hhcmdlMmFueXJlZyhlKTtcclxuICAgICAgICAgICAgdGhpcy5mcmVlZXhwKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kanVtcChMdWFfMS5MdWEuT1BfVEVTVFNFVCwgTHVhXzEuTHVhLk5PX1JFRywgZS5pbmZvLCBjb25kID8gMSA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25kanVtcChvcCwgYSwgYiwgYykge1xyXG4gICAgICAgICAgICB0aGlzLmtDb2RlQUJDKG9wLCBhLCBiLCBjKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua0p1bXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzY2hhcmdlMmFueXJlZyhlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmsgIT0gRXhwZGVzY18xLkV4cGRlc2MuVk5PTlJFTE9DKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtSZXNlcnZlcmVncygxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzY2hhcmdlMnJlZyhlLCB0aGlzLl9mcmVlcmVnIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAga1NlbGYoZSwga2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMua0V4cDJhbnlyZWcoZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZWV4cChlKTtcclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSB0aGlzLl9mcmVlcmVnO1xyXG4gICAgICAgICAgICB0aGlzLmtSZXNlcnZlcmVncygyKTtcclxuICAgICAgICAgICAgdGhpcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfU0VMRiwgZnVuYywgZS5pbmZvLCB0aGlzLmtFeHAyUksoa2V5KSk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZWV4cChrZXkpO1xyXG4gICAgICAgICAgICBlLmluZm8gPSBmdW5jO1xyXG4gICAgICAgICAgICBlLmsgPSBFeHBkZXNjXzEuRXhwZGVzYy5WTk9OUkVMT0M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtTZXRsaXN0KGJhc2UsIG5lbGVtcywgdG9zdG9yZSkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IChuZWxlbXMgLSAxKSAvIEx1YV8xLkx1YS5MRklFTERTX1BFUl9GTFVTSCArIDE7XHJcbiAgICAgICAgICAgIHZhciBiID0gKHRvc3RvcmUgPT0gTHVhXzEuTHVhLk1VTFRSRVQpID8gMCA6IHRvc3RvcmU7XHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgdG9zdG9yZSAhPSAwXHJcbiAgICAgICAgICAgIGlmIChjIDw9IEx1YV8xLkx1YS5NQVhBUkdfQylcclxuICAgICAgICAgICAgICAgIHRoaXMua0NvZGVBQkMoTHVhXzEuTHVhLk9QX1NFVExJU1QsIGJhc2UsIGIsIGMpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua0NvZGVBQkMoTHVhXzEuTHVhLk9QX1NFVExJU1QsIGJhc2UsIGIsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rQ29kZShjLCB0aGlzLl9scy5sYXN0bGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZnJlZXJlZyA9IGJhc2UgKyAxOyAvKiBmcmVlIHJlZ2lzdGVycyB3aXRoIGxpc3QgdmFsdWVzICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvZGVjb21wKG9wLCBjb25kLCBlMSwgZTIpIHtcclxuICAgICAgICAgICAgdmFyIG8xID0gdGhpcy5rRXhwMlJLKGUxKTtcclxuICAgICAgICAgICAgdmFyIG8yID0gdGhpcy5rRXhwMlJLKGUyKTtcclxuICAgICAgICAgICAgdGhpcy5mcmVlZXhwKGUyKTtcclxuICAgICAgICAgICAgdGhpcy5mcmVlZXhwKGUxKTtcclxuICAgICAgICAgICAgaWYgKCghY29uZCkgJiYgb3AgIT0gTHVhXzEuTHVhLk9QX0VRKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBleGNoYW5nZSBhcmdzIHRvIHJlcGxhY2UgYnkgYDwnIG9yIGA8PScgKi9cclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gbzE7XHJcbiAgICAgICAgICAgICAgICBvMSA9IG8yO1xyXG4gICAgICAgICAgICAgICAgbzIgPSB0ZW1wOyAvKiBvMSA8PT0+IG8yICovXHJcbiAgICAgICAgICAgICAgICBjb25kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlMS5pbmZvID0gdGhpcy5jb25kanVtcChvcCwgKGNvbmQgPyAxIDogMCksIG8xLCBvMik7XHJcbiAgICAgICAgICAgIGUxLmsgPSBFeHBkZXNjXzEuRXhwZGVzYy5WSk1QO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrdXB2YWwobGV2ZWwpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJsO1xyXG4gICAgICAgICAgICB3aGlsZSAoYiAhPSBudWxsICYmIGIubmFjdHZhciA+IGxldmVsKVxyXG4gICAgICAgICAgICAgICAgYiA9IGIucHJldmlvdXM7XHJcbiAgICAgICAgICAgIGlmIChiICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBiLnVwdmFsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgZigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgc2V0IGYoZikge1xyXG4gICAgICAgICAgICB0aGlzLl9mID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgcHJldigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgc2V0IHByZXYocHJldikge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2ID0gcHJldjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBzZXQgbHMobHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fbHMgPSBscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBzZXQgTChMKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX0wgPSBMO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBibCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCBibChibCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ibCA9IGJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBwYygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BjO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBucCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCBucChucCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ucCA9IG5wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBubG9jdmFycygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25sb2N2YXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCBubG9jdmFycyhubG9jdmFycykge1xyXG4gICAgICAgICAgICB0aGlzLl9ubG9jdmFycyA9IG5sb2N2YXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBuYWN0dmFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFjdHZhcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBzZXQgbmFjdHZhcihuYWN0dmFyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25hY3R2YXIgPSBuYWN0dmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCB1cHZhbHVlcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBhY3R2YXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3R2YXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5GdW5jU3RhdGUgPSBGdW5jU3RhdGU7XHJcbiAgICAvKiogU2VlIE5PX0pVTVAgaW4gbGNvZGUuaC4gKi9cclxuICAgIEZ1bmNTdGF0ZS5OT19KVU1QID0gLTE7XHJcbiAgICAvKlxyXG4gICAgKiogbWFza3MgZm9yIGluc3RydWN0aW9uIHByb3BlcnRpZXMuIFRoZSBmb3JtYXQgaXM6XHJcbiAgICAqKiBiaXRzIDAtMTogb3AgbW9kZVxyXG4gICAgKiogYml0cyAyLTM6IEMgYXJnIG1vZGVcclxuICAgICoqIGJpdHMgNC01OiBCIGFyZyBtb2RlXHJcbiAgICAqKiBiaXQgNjogaW5zdHJ1Y3Rpb24gc2V0IHJlZ2lzdGVyIEFcclxuICAgICoqIGJpdCA3OiBvcGVyYXRvciBpcyBhIHRlc3RcclxuICAgICovXHJcbiAgICAvKiogYXJnIG1vZGVzICovXHJcbiAgICBGdW5jU3RhdGUuT1BfQVJHX04gPSAwO1xyXG4gICAgRnVuY1N0YXRlLk9QX0FSR19VID0gMTtcclxuICAgIEZ1bmNTdGF0ZS5PUF9BUkdfUiA9IDI7XHJcbiAgICBGdW5jU3RhdGUuT1BfQVJHX0sgPSAzO1xyXG4gICAgLyoqIG9wIG1vZGVzICovXHJcbiAgICBGdW5jU3RhdGUuaUFCQyA9IDA7XHJcbiAgICBGdW5jU3RhdGUuaUFCeCA9IDE7XHJcbiAgICBGdW5jU3RhdGUuaUFzQnggPSAyO1xyXG4gICAgRnVuY1N0YXRlLk9QTU9ERSA9IFtcclxuICAgICAgICAvKiAgICAgIFQgIEEgIEIgICAgICAgICBDICAgICAgICAgbW9kZSAgICAgICAgICAgICAgICBvcGNvZGUgICovXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAxLCBGdW5jU3RhdGUuT1BfQVJHX1IsIEZ1bmNTdGF0ZS5PUF9BUkdfTiwgRnVuY1N0YXRlLmlBQkMpIC8qIE9QX01PVkUgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAxLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5PUF9BUkdfTiwgRnVuY1N0YXRlLmlBQngpIC8qIE9QX0xPQURLICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19VLCBGdW5jU3RhdGUuT1BfQVJHX1UsIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9MT0FEQk9PTCAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfUiwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfTE9BRE5JTCAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfVSwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfR0VUVVBWQUwgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAxLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5PUF9BUkdfTiwgRnVuY1N0YXRlLmlBQngpIC8qIE9QX0dFVEdMT0JBTCAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfUiwgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfR0VUVEFCTEUgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAwLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5PUF9BUkdfTiwgRnVuY1N0YXRlLmlBQngpIC8qIE9QX1NFVEdMT0JBTCAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDAsIEZ1bmNTdGF0ZS5PUF9BUkdfVSwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfU0VUVVBWQUwgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAwLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5PUF9BUkdfSywgRnVuY1N0YXRlLmlBQkMpIC8qIE9QX1NFVFRBQkxFICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19VLCBGdW5jU3RhdGUuT1BfQVJHX1UsIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9ORVdUQUJMRSAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfUiwgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfU0VMRiAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfSywgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfQUREICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9TVUIgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAxLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5PUF9BUkdfSywgRnVuY1N0YXRlLmlBQkMpIC8qIE9QX01VTCAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfSywgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfRElWICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9NT0QgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAxLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5PUF9BUkdfSywgRnVuY1N0YXRlLmlBQkMpIC8qIE9QX1BPVyAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfUiwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfVU5NICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19SLCBGdW5jU3RhdGUuT1BfQVJHX04sIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9OT1QgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgwLCAxLCBGdW5jU3RhdGUuT1BfQVJHX1IsIEZ1bmNTdGF0ZS5PUF9BUkdfTiwgRnVuY1N0YXRlLmlBQkMpIC8qIE9QX0xFTiAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfUiwgRnVuY1N0YXRlLk9QX0FSR19SLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfQ09OQ0FUICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMCwgRnVuY1N0YXRlLk9QX0FSR19SLCBGdW5jU3RhdGUuT1BfQVJHX04sIEZ1bmNTdGF0ZS5pQXNCeCkgLyogT1BfSk1QICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMSwgMCwgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9FUSAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDEsIDAsIEZ1bmNTdGF0ZS5PUF9BUkdfSywgRnVuY1N0YXRlLk9QX0FSR19LLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfTFQgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgxLCAwLCBGdW5jU3RhdGUuT1BfQVJHX0ssIEZ1bmNTdGF0ZS5PUF9BUkdfSywgRnVuY1N0YXRlLmlBQkMpIC8qIE9QX0xFICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMSwgMSwgRnVuY1N0YXRlLk9QX0FSR19SLCBGdW5jU3RhdGUuT1BfQVJHX1UsIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9URVNUICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMSwgMSwgRnVuY1N0YXRlLk9QX0FSR19SLCBGdW5jU3RhdGUuT1BfQVJHX1UsIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9URVNUU0VUICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19VLCBGdW5jU3RhdGUuT1BfQVJHX1UsIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9DQUxMICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19VLCBGdW5jU3RhdGUuT1BfQVJHX1UsIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9UQUlMQ0FMTCAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDAsIEZ1bmNTdGF0ZS5PUF9BUkdfVSwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfUkVUVVJOICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMSwgRnVuY1N0YXRlLk9QX0FSR19SLCBGdW5jU3RhdGUuT1BfQVJHX04sIEZ1bmNTdGF0ZS5pQXNCeCkgLyogT1BfRk9STE9PUCAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfUiwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFzQngpIC8qIE9QX0ZPUlBSRVAgKi8sXHJcbiAgICAgICAgRnVuY1N0YXRlLm9wbW9kZSgxLCAwLCBGdW5jU3RhdGUuT1BfQVJHX04sIEZ1bmNTdGF0ZS5PUF9BUkdfVSwgRnVuY1N0YXRlLmlBQkMpIC8qIE9QX1RGT1JMT09QICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMCwgRnVuY1N0YXRlLk9QX0FSR19VLCBGdW5jU3RhdGUuT1BfQVJHX1UsIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9TRVRMSVNUICovLFxyXG4gICAgICAgIEZ1bmNTdGF0ZS5vcG1vZGUoMCwgMCwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuT1BfQVJHX04sIEZ1bmNTdGF0ZS5pQUJDKSAvKiBPUF9DTE9TRSAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfVSwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFCeCkgLyogT1BfQ0xPU1VSRSAqLyxcclxuICAgICAgICBGdW5jU3RhdGUub3Btb2RlKDAsIDEsIEZ1bmNTdGF0ZS5PUF9BUkdfVSwgRnVuY1N0YXRlLk9QX0FSR19OLCBGdW5jU3RhdGUuaUFCQykgLyogT1BfVkFSQVJHICovXHJcbiAgICBdO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuY1N0YXRlLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9FeHBkZXNjXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5MSFNBc3NpZ24gPSB2b2lkIDA7XHJcbiAgICBjb25zdCBFeHBkZXNjXzEgPSByZXF1aXJlKFwiLi9FeHBkZXNjXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL1N5bnRheC5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIGNsYXNzIExIU0Fzc2lnbiB7XHJcbiAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fdiA9IG5ldyBFeHBkZXNjXzEuRXhwZGVzYygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbml0KHByZXYpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJldiA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IHByZXYoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCBwcmV2KHByZXYpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJldiA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IHYoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTEhTQXNzaWduID0gTEhTQXNzaWduO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TEhTQXNzaWduLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9FT0ZFeGNlcHRpb25cIiwgXCIuLi9qYXZhL0lPRXhjZXB0aW9uXCIsIFwiLi4vamF2YS9OdWxsUG9pbnRlckV4Y2VwdGlvblwiLCBcIi4uL2phdmEvQnl0ZUFycmF5XCIsIFwiLi9Qcm90b1wiLCBcIi4vU2xvdFwiLCBcIi4vTG9jVmFyXCIsIFwiLi9MdWFcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkxvYWRlciA9IHZvaWQgMDtcclxuICAgIGNvbnN0IEVPRkV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2phdmEvRU9GRXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgSU9FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0lPRXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgTnVsbFBvaW50ZXJFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL051bGxQb2ludGVyRXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgQnl0ZUFycmF5XzEgPSByZXF1aXJlKFwiLi4vamF2YS9CeXRlQXJyYXlcIik7XHJcbiAgICBjb25zdCBQcm90b18xID0gcmVxdWlyZShcIi4vUHJvdG9cIik7XHJcbiAgICBjb25zdCBTbG90XzEgPSByZXF1aXJlKFwiLi9TbG90XCIpO1xyXG4gICAgY29uc3QgTG9jVmFyXzEgPSByZXF1aXJlKFwiLi9Mb2NWYXJcIik7XHJcbiAgICBjb25zdCBMdWFfMSA9IHJlcXVpcmUoXCIuL0x1YVwiKTtcclxuICAgIC8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9Mb2FkZXIuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIEx1YSA1LjEgYmluYXJ5IGNodW5rcy5cclxuICAgICAqIFRoaXMgbG9hZGVyIGlzIHJlc3RyaWN0ZWQgdG8gbG9hZGluZyBMdWEgNS4xIGJpbmFyeSBjaHVua3Mgd2hlcmU6XHJcbiAgICAgKiA8dWw+XHJcbiAgICAgKiA8bGk+PGNvZGU+TFVBQ19WRVJTSU9OPC9jb2RlPiBpcyA8Y29kZT4weDUxPC9jb2RlPi48L2xpPlxyXG4gICAgICogPGxpPjxjb2RlPmludDwvY29kZT4gaXMgMzIgYml0cy48L2xpPlxyXG4gICAgICogPGxpPjxjb2RlPnNpemVfdDwvY29kZT4gaXMgMzIgYml0cy48L2xpPlxyXG4gICAgICogPGxpPjxjb2RlPkluc3RydWN0aW9uPC9jb2RlPiBpcyAzMiBiaXRzICh0aGlzIGlzIGEgdHlwZSBkZWZpbmVkIGluXHJcbiAgICAgKiB0aGUgUFVDLVJpbyBMdWEpLjwvbGk+XHJcbiAgICAgKiA8bGk+PGNvZGU+bHVhX051bWJlcjwvY29kZT4gaXMgYW4gSUVFRSA3NTQgNjQtYml0IGRvdWJsZS4gIFN1aXRhYmxlXHJcbiAgICAgKiBmb3IgcGFzc2luZyB0byB7QGxpbmsgamF2YS5sYW5nLkRvdWJsZSNsb25nQml0c1RvRG91YmxlfS48L2xpPlxyXG4gICAgICogPGxpPmVuZGlhbm5lc3MgZG9lcyBub3QgbWF0dGVyICh0aGUgbG9hZGVyIHN3YWJzIGFzIGFwcHJvcHJpYXRlKS48L2xpPlxyXG4gICAgICogPC91bD5cclxuICAgICAqIEFueSBMdWEgY2h1bmsgY29tcGlsZWQgYnkgYSBzdG9jayBMdWEgNS4xIHJ1bm5pbmcgb24gYSAzMi1iaXQgV2luZG93c1xyXG4gICAgICogUEMgb3IgYXQgMzItYml0IE9TIFggbWFjaGluZSBzaG91bGQgYmUgZmluZS5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgTG9hZGVyIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIEEgbmV3IGNodW5rIGxvYWRlci4gIFRoZSA8Y29kZT5JbnB1dFN0cmVhbTwvY29kZT4gbXVzdCBiZVxyXG4gICAgICAgICogcG9zaXRpb25lZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSA8Y29kZT5MVUFfU0lHTkFUVVJFPC9jb2RlPiB0aGF0XHJcbiAgICAgICAgKiBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgTHVhIGJpbmFyeSBjaHVuay5cclxuICAgICAgICAqIEBwYXJhbSBpbiAgICBUaGUgYmluYXJ5IHN0cmVhbSBmcm9tIHdoaWNoIHRoZSBjaHVuayBpcyByZWFkLlxyXG4gICAgICAgICogQHBhcmFtIG5hbWUgIFRoZSBuYW1lIG9mIHRoZSBjaHVuay5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9pbiwgbmFtZSkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBpbnRlZ2VycyBpbiB0aGUgYmluYXJ5IGNodW5rIGFyZSBzdG9yZWQgYmlnLWVuZGlhbiBvclxyXG4gICAgICAgICAgICAgKiBsaXR0bGUtZW5kaWFuLiAgUmVjYWxsIHRoYXQgdGhlIG51bWJlciAweDEyMzQ1Njc4IGlzIHN0b3JlZDogMHgxMlxyXG4gICAgICAgICAgICAgKiAweDM0IDB4NTYgMHg3OCBpbiBiaWctZW5kaWFuIGZvcm1hdDsgYW5kLCAweDc4IDB4NTYgMHgzNCAweDEyIGluXHJcbiAgICAgICAgICAgICAqIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fYmlnZW5kaWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vVE9ETzrov5nph4zmnInpl67pophcclxuICAgICAgICAgICAgLy8gYXV4aWxpYXJ5IGZvciByZWFkaW5nIGludHMvbnVtYmVyc1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRidWYgPSBuZXcgQnl0ZUFycmF5XzEuQnl0ZUFycmF5KCk7IC8vbmV3IEFycmF5KDQpIDsgLy9ieXRlIFtdIFxyXG4gICAgICAgICAgICB0aGlzLl9sb25nYnVmID0gbmV3IEJ5dGVBcnJheV8xLkJ5dGVBcnJheSgpOyAvL25ldyBBcnJheSg4KSA7IC8vYnl0ZSBbXSBcclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gX2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb25fMS5OdWxsUG9pbnRlckV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2luID0gX2luO1xyXG4gICAgICAgICAgICAvLyBUaGUgbmFtZSBpcyB0cmVhdGVkIHNsaWdodGx5LiAgU2VlIGx1bmR1bXAuYyBpbiB0aGUgUFVDLVJpb1xyXG4gICAgICAgICAgICAvLyBzb3VyY2UgZm9yIGRldGFpbHMuXHJcbiAgICAgICAgICAgIGlmIChuYW1lLnN1YnN0cigwLCAxKSA9PSBcIkBcIiB8fCBuYW1lLnN1YnN0cigwLCAxKSA9PSBcIj1cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA6dG9kbzogU2VsZWN0IHNvbWUgZXF1aXZhbGVudCBmb3IgdGhlIGJpbmFyeSBzdHJpbmcgY2FzZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX25hbWUgPSBcImJpbmFyeSBzdHJpbmdcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzICh1bmR1bXBzKSBhIGR1bXBlZCBiaW5hcnkgY2h1bmsuXHJcbiAgICAgICAgICogQHRocm93cyBJT0V4Y2VwdGlvbiAgaWYgY2h1bmsgaXMgbWFsZm9ybWVkIG9yIHVuYWNjZXB0YWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1bmR1bXAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mdW5jdGlvbihudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpbWl0aXZlIHJlYWRlciBmb3IgdW5kdW1waW5nLlxyXG4gICAgICAgICAqIFJlYWRzIGV4YWN0bHkgZW5vdWdoIGJ5dGVzIGZyb20gPGNvZGU+dGhpcy5pbjwvY29kZT4gdG8gZmlsbCB0aGVcclxuICAgICAgICAgKiBhcnJheSA8Y29kZT5iPC9jb2RlPi4gIElmIHRoZXJlIGFyZW4ndCBlbm91Z2ggdG8gZmlsbFxyXG4gICAgICAgICAqIDxjb2RlPmI8L2NvZGU+IHRoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93bi4gIFNpbWlsYXIgdG9cclxuICAgICAgICAgKiA8Y29kZT5Mb2FkQmxvY2s8L2NvZGU+IGZyb20gUFVDLVJpbydzIDxjb2RlPmx1bmR1bXAuYzwvY29kZT4uXHJcbiAgICAgICAgICogQHBhcmFtIGIgIGJ5dGUgYXJyYXkgdG8gZmlsbC5cclxuICAgICAgICAgKiBAdGhyb3dzIEVPRkV4Y2VwdGlvbiB3aGVuIHRoZSBzdHJlYW0gaXMgZXhoYXVzdGVkIHRvbyBlYXJseS5cclxuICAgICAgICAgKiBAdGhyb3dzIElPRXhjZXB0aW9uIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRvZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYmxvY2soYikge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX2luLnJlYWRCeXRlcyhiKTtcclxuICAgICAgICAgICAgaWYgKG4gIT0gYi5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRU9GRXhjZXB0aW9uXzEuRU9GRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuZHVtcHMgYSBieXRlIGFzIGFuIDggYml0IHVuc2lnbmVkIG51bWJlci4gIFJldHVybnNcclxuICAgICAgICAgKiBhbiBpbnQgdG8gYWNjb21tb2RhdGUgdGhlIHJhbmdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJ5dGVMb2FkKCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2luLnJlYWQoKTtcclxuICAgICAgICAgICAgaWYgKGMgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRU9GRXhjZXB0aW9uXzEuRU9GRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBjICYgMHhGRjsgLy8gcGFyYW5vaWFcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5kdW1wcyB0aGUgY29kZSBmb3IgYSA8Y29kZT5Qcm90bzwvY29kZT4uICBUaGUgY29kZSBpcyBhbiBhcnJheSBvZlxyXG4gICAgICAgICAqIFZNIGluc3RydWN0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb2RlKCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuaW50TG9hZCgpO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IG5ldyBBcnJheShuKTsgLy9pbnRbXSBcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIC8vIDpJbnN0cnVjdGlvbjpzaXplICBIZXJlIHdlIGFzc3VtZSB0aGF0IGEgZHVtcGVkIEluc3RydWN0aW9uIGlzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2FtZSBzaXplIGFzIGEgZHVtcGVkIGludC5cclxuICAgICAgICAgICAgICAgIGNvZGVbaV0gPSB0aGlzLmludExvYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5kdW1wcyB0aGUgY29uc3RhbnQgYXJyYXkgY29udGFpbmVkIGluc2lkZSBhIDxjb2RlPlByb3RvPC9jb2RlPlxyXG4gICAgICAgICAqIG9iamVjdC4gIEZpcnN0IGhhbGYgb2YgPGNvZGU+TG9hZENvbnN0YW50czwvY29kZT4sIHNlZVxyXG4gICAgICAgICAqIDxjb2RlPnByb3RvPC9jb2RlPiBmb3IgdGhlIHNlY29uZCBoYWxmIG9mXHJcbiAgICAgICAgICogPGNvZGU+TG9hZENvbnN0YW50czwvY29kZT4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3RhbnQoKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5pbnRMb2FkKCk7XHJcbiAgICAgICAgICAgIHZhciBrID0gbmV3IEFycmF5KG4pOyAvL1Nsb3RbXSBcclxuICAgICAgICAgICAgLy8gTG9hZCBlYWNoIGNvbnN0YW50IG9uZSBieSBvbmUuICBXZSB1c2UgdGhlIGZvbGxvd2luZyB2YWx1ZXMgZm9yXHJcbiAgICAgICAgICAgIC8vIHRoZSBMdWEgdGFndHlwZXMgKHRha2VuIGZyb20gPGNvZGU+bHVhLmg8L2NvZGU+IGZyb20gdGhlIFBVQy1SaW9cclxuICAgICAgICAgICAgLy8gTHVhIDUuMSBkaXN0cmlidXRpb24pOlxyXG4gICAgICAgICAgICAvLyBMVUFfVE5JTCAgICAgICAgIDBcclxuICAgICAgICAgICAgLy8gTFVBX1RCT09MRUFOICAgICAxXHJcbiAgICAgICAgICAgIC8vIExVQV9UTlVNQkVSICAgICAgM1xyXG4gICAgICAgICAgICAvLyBMVUFfVFNUUklORyAgICAgIDRcclxuICAgICAgICAgICAgLy8gQWxsIG90aGVyIHRhZ3R5cGVzIGFyZSBpbnZhbGlkXHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBDdXJyZW50bHkgYSBuZXcgU2xvdCBpcyBjcmVhdGVkIGZvciBlYWNoIGNvbnN0YW50LlxyXG4gICAgICAgICAgICAvLyBDb25zaWRlciBhIHNwYWNlIG9wdGltaXNhdGlvbiB3aGVyZWJ5IGlkZW50aWNhbCBjb25zdGFudHMgaGF2ZVxyXG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBTbG90LiAgQ29uc3RhbnRzIGFyZSBwb29sZWQgcGVyIGZ1bmN0aW9uIGFueXdheSAoc28gYVxyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBuZXZlciBoYXMgMiBpZGVudGljYWwgY29uc3RhbnRzKSwgc28gd291bGQgaGF2ZSB0byB3b3JrXHJcbiAgICAgICAgICAgIC8vIGFjcm9zcyBmdW5jdGlvbnMuICBUaGUgZWFzeSBjYXNlcyBvZiBuaWwsIHRydWUsIGZhbHNlLCBtaWdodCBiZVxyXG4gICAgICAgICAgICAvLyB3b3J0aCBkb2luZyBzaW5jZSB0aGF0IGRvZXNuJ3QgcmVxdWlyZSBhIGdsb2JhbCB0YWJsZS5cclxuICAgICAgICAgICAgLy8gXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuYnl0ZUxvYWQoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogLy8gTFVBX1ROSUxcclxuICAgICAgICAgICAgICAgICAgICAgICAga1tpXSA9IG5ldyBTbG90XzEuU2xvdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrW2ldLmluaXQyKEx1YV8xLkx1YS5OSUwpOyAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gTFVBX1RCT09MRUFOXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5ieXRlTG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnQgYiA+PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSU9FeGNlcHRpb25fMS5JT0V4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrW2ldID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtbaV0uaW5pdDIoTHVhXzEuTHVhLnZhbHVlT2ZCb29sZWFuKGIgIT0gMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIExVQV9UTlVNQkVSXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtbaV0gPSBuZXcgU2xvdF8xLlNsb3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAga1tpXS5pbml0Mih0aGlzLm51bWJlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiAvLyBMVUFfVFNUUklOR1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrW2ldID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtbaV0uaW5pdDIodGhpcy5zdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJT0V4Y2VwdGlvbl8xLklPRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuZHVtcHMgdGhlIGRlYnVnIGluZm8gZm9yIGEgPGNvZGU+UHJvdG88L2NvZGU+LlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm90byAgVGhlIFByb3RvIGluc3RhbmNlIHRvIHdoaWNoIGRlYnVnIGluZm8gd2lsbCBiZSBhZGRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWJ1Zyhwcm90bykge1xyXG4gICAgICAgICAgICAvLyBsaW5laW5mb1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuaW50TG9hZCgpO1xyXG4gICAgICAgICAgICB2YXIgbGluZWluZm8gPSBuZXcgQXJyYXkobik7IC8vaW50W10gXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5laW5mb1tpXSA9IHRoaXMuaW50TG9hZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGxvY3ZhcnNcclxuICAgICAgICAgICAgbiA9IHRoaXMuaW50TG9hZCgpO1xyXG4gICAgICAgICAgICB2YXIgbG9jdmFyID0gbmV3IEFycmF5KG4pOyAvL0xvY1ZhcltdIFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmludExvYWQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmludExvYWQoKTtcclxuICAgICAgICAgICAgICAgIGxvY3ZhcltpXSA9IG5ldyBMb2NWYXJfMS5Mb2NWYXIoKTtcclxuICAgICAgICAgICAgICAgIGxvY3ZhcltpXS5pbml0KHMsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVwdmFsdWUgKG5hbWVzKVxyXG4gICAgICAgICAgICBuID0gdGhpcy5pbnRMb2FkKCk7XHJcbiAgICAgICAgICAgIHZhciB1cHZhbHVlID0gbmV3IEFycmF5KG4pOyAvL1N0cmluZ1tdXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHVwdmFsdWVbaV0gPSB0aGlzLnN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3RvLmRlYnVnKGxpbmVpbmZvLCBsb2N2YXIsIHVwdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuZHVtcHMgYSBQcm90byBvYmplY3QuICBUaGlzIGlzIG5hbWVkICdmdW5jdGlvbicgYWZ0ZXJcclxuICAgICAgICAgKiA8Y29kZT5Mb2FkRnVuY3Rpb248L2NvZGU+IGluIFBVQy1SaW8ncyA8Y29kZT5sdW5kdW1wLmM8L2NvZGU+LlxyXG4gICAgICAgICAqIEBwYXJhbSBwYXJlbnRTb3VyY2UgIE5hbWUgb2YgcGFyZW50IHNvdXJjZSBcImZpbGVcIi5cclxuICAgICAgICAgKiBAdGhyb3dzIElPRXhjZXB0aW9uICB3aGVuIGJpbmFyeSBpcyBtYWxmb3JtZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2Z1bmN0aW9uKHBhcmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlO1xyXG4gICAgICAgICAgICB2YXIgbGluZWRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBsYXN0bGluZWRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBudXBzO1xyXG4gICAgICAgICAgICB2YXIgbnVtcGFyYW1zO1xyXG4gICAgICAgICAgICB2YXIgdmFyYXJnQnl0ZTtcclxuICAgICAgICAgICAgdmFyIHZhcmFyZztcclxuICAgICAgICAgICAgdmFyIG1heHN0YWNrc2l6ZTtcclxuICAgICAgICAgICAgdmFyIGNvZGU7IC8vaW50W10gXHJcbiAgICAgICAgICAgIHZhciBjb25zdGFudDsgLy9TbG90W10gXHJcbiAgICAgICAgICAgIHZhciBwcm90bzsgLy9Qcm90b1tdIFxyXG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLnN0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHBhcmVudFNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5lZGVmaW5lZCA9IHRoaXMuaW50TG9hZCgpO1xyXG4gICAgICAgICAgICBsYXN0bGluZWRlZmluZWQgPSB0aGlzLmludExvYWQoKTtcclxuICAgICAgICAgICAgbnVwcyA9IHRoaXMuYnl0ZUxvYWQoKTtcclxuICAgICAgICAgICAgbnVtcGFyYW1zID0gdGhpcy5ieXRlTG9hZCgpO1xyXG4gICAgICAgICAgICB2YXJhcmdCeXRlID0gdGhpcy5ieXRlTG9hZCgpO1xyXG4gICAgICAgICAgICAvLyBcImlzX3ZhcmFyZ1wiIGlzIGEgMy1iaXQgZmllbGQsIHdpdGggdGhlIGZvbGxvd2luZyBiaXQgbWVhbmluZ3NcclxuICAgICAgICAgICAgLy8gKHNlZSBcImxvYmplY3QuaFwiKTpcclxuICAgICAgICAgICAgLy8gMSAtIFZBUkFSR19IQVNBUkdcclxuICAgICAgICAgICAgLy8gMiAtIFZBUkFSR19JU1ZBUkFSR1xyXG4gICAgICAgICAgICAvLyA0IC0gVkFSQVJHX05FRURTQVJHXHJcbiAgICAgICAgICAgIC8vIFZhbHVlcyAxIGFuZCA0IChiaXRzIDAgYW5kIDIpIGFyZSBvbmx5IHVzZWQgZm9yIDUuMFxyXG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5LlxyXG4gICAgICAgICAgICAvLyBIQVNBUkcgaW5kaWNhdGVzIHRoYXQgYSBmdW5jdGlvbiB3YXMgY29tcGlsZWQgaW4gNS4wXHJcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgaXMgZGVjbGFyZWQgdG8gaGF2ZSAuLi4gaW4gaXRzIHBhcmFtZXRlclxyXG4gICAgICAgICAgICAvLyBsaXN0LlxyXG4gICAgICAgICAgICAvLyBORUVEU0FSRyBpbmRpY2F0ZXMgdGhhdCBhIGZ1bmN0aW9uIHdhcyBjb21waWxlZCBpbiA1LjBcclxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBpcyBkZWNsYXJlZCB0byBoYXZlIC4uLiBpbiBpdHMgcGFyYW1ldGVyXHJcbiAgICAgICAgICAgIC8vIGxpc3QgYW5kIGRvZXMgX25vdF8gdXNlIHRoZSA1LjEgc3R5bGUgb2YgdmFyYXJnIGFjY2VzcyAodXNpbmcgLi4uXHJcbiAgICAgICAgICAgIC8vIGFzIGFuIGV4cHJlc3Npb24pLiAgSXQgaXMgYXNzdW1lZCB0byB1c2UgNS4wIHN0eWxlIHZhcmFyZyBhY2Nlc3NcclxuICAgICAgICAgICAgLy8gKHRoZSBsb2NhbCAnYXJnJyB2YXJpYWJsZSkuICBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSmlsbC5cclxuICAgICAgICAgICAgLy8gSVNWQVJBUkcgaW5kaWNhdGVzIHRoYXQgYSBmdW5jdGlvbiBoYXMgLi4uIGluIGl0cyBwYXJhbWV0ZXIgbGlzdFxyXG4gICAgICAgICAgICAvLyAod2hldGhlciBjb21waWxlZCBpbiA1LjAgY29tcGF0aWJpbGl0eSBtb2RlIG9yIG5vdCkuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEF0IHJ1bnRpbWUgTkVFRFNBUkcgY2hhbmdlcyB0aGUgcHJvdG9jb2wgZm9yIGNhbGxpbmcgYSB2YXJhcmdcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb24uICBXZSBkb24ndCBzdXBwb3J0IHRoaXMsIHNvIHdlIGNoZWNrIHRoYXQgaXQgaXMgYWJzZW50XHJcbiAgICAgICAgICAgIC8vIGhlcmUgaW4gdGhlIGxvYWRlci5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhhdCBtZWFucyB0aGF0IHRoZSBsZWdhbCB2YWx1ZXMgZm9yIHRoaXMgZmllbGQgYXIgMCwxLDIsMy5cclxuICAgICAgICAgICAgaWYgKHZhcmFyZ0J5dGUgPCAwIHx8IHZhcmFyZ0J5dGUgPiAzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSU9FeGNlcHRpb25fMS5JT0V4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhcmFyZyA9ICgwICE9IHZhcmFyZ0J5dGUpO1xyXG4gICAgICAgICAgICBtYXhzdGFja3NpemUgPSB0aGlzLmJ5dGVMb2FkKCk7XHJcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLmNvZGUoKTtcclxuICAgICAgICAgICAgY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50KCk7XHJcbiAgICAgICAgICAgIHByb3RvID0gdGhpcy5wcm90byhzb3VyY2UpO1xyXG4gICAgICAgICAgICB2YXIgbmV3UHJvdG8gPSBuZXcgUHJvdG9fMS5Qcm90bygpO1xyXG4gICAgICAgICAgICBuZXdQcm90by5pbml0MShjb25zdGFudCwgY29kZSwgcHJvdG8sIG51cHMsIG51bXBhcmFtcywgdmFyYXJnLCBtYXhzdGFja3NpemUpOyAvL1RPRE86XHJcbiAgICAgICAgICAgIG5ld1Byb3RvLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgbmV3UHJvdG8ubGluZWRlZmluZWQgPSBsaW5lZGVmaW5lZDtcclxuICAgICAgICAgICAgbmV3UHJvdG8ubGFzdGxpbmVkZWZpbmVkID0gbGFzdGxpbmVkZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKG5ld1Byb3RvKTtcclxuICAgICAgICAgICAgLy8gOnRvZG86IGNhbGwgY29kZSB2ZXJpZmllclxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UHJvdG87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGFuZCBjaGVja3MgdGhlIGJpbmFyeSBjaHVuayBoZWFkZXIuICBTZXRzXHJcbiAgICAgICAgICogPGNvZGU+dGhpcy5iaWdlbmRpYW48L2NvZGU+IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQSBMdWEgNS4xIGhlYWRlciBsb29rcyBsaWtlIHRoaXM6XHJcbiAgICAgICAgICogPHByZT5cclxuICAgICAgICAgICAgICogYlswXSAgICAweDMzXHJcbiAgICAgICAgICAgICAqIGJbMS4uM10gXCJMdWFcIjtcclxuICAgICAgICAgICAgICogYls0XSAgICAweDUxIChMVUFDX1ZFUlNJT04pXHJcbiAgICAgICAgICAgICAqIGJbNV0gICAgMCAoTFVBQ19GT1JNQVQpXHJcbiAgICAgICAgICAgICAqIGJbNl0gICAgMCBiaWctZW5kaWFuLCAxIGxpdHRsZS1lbmRpYW5cclxuICAgICAgICAgICAgICogYls3XSAgICA0IChzaXplb2YoaW50KSlcclxuICAgICAgICAgICAgICogYls4XSAgICA0IChzaXplb2Yoc2l6ZV90KSlcclxuICAgICAgICAgICAgICogYls5XSAgICA0IChzaXplb2YoSW5zdHJ1Y3Rpb24pKVxyXG4gICAgICAgICAgICAgKiBiWzEwXSAgIDggKHNpemVvZihsdWFfTnVtYmVyKSlcclxuICAgICAgICAgICAgICogYlsxMV0gICAwIChmbG9hdGluZyBwb2ludClcclxuICAgICAgICAgICAgICogPC9wcmU+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRvIGNvbnNlcnZlIEpWTSBieXRlY29kZXMgdGhlIHNpemVzIG9mIHRoZSB0eXBlcyA8Y29kZT5pbnQ8L2NvZGU+LFxyXG4gICAgICAgICAgICAgKiA8Y29kZT5zaXplX3Q8L2NvZGU+LCA8Y29kZT5JbnN0cnVjdGlvbjwvY29kZT4sXHJcbiAgICAgICAgICAgICAqIDxjb2RlPmx1YV9OdW1iZXI8L2NvZGU+IGFyZSBhc3N1bWVkIGJ5IHRoZSBjb2RlIHRvIGJlIDQsIDQsIDQsIGFuZFxyXG4gICAgICAgICAgICAgKiA4LCByZXNwZWN0aXZlbHkuICBXaGVyZSB0aGlzIGFzc3VtcHRpb24gaXMgbWFkZSB0aGUgdGFncyA6aW50OnNpemUsXHJcbiAgICAgICAgICAgICAqIDpzaXplX3Q6c2l6ZSA6SW5zdHJ1Y3Rpb246c2l6ZSA6bHVhX051bWJlcjpzaXplIHdpbGwgYXBwZWFyIHNvIHRoYXRcclxuICAgICAgICAgICAgICogeW91IGNhbiBncmVwIGZvciB0aGVtLCBzaG91bGQgeW91IHdpc2ggdG8gbW9kaWZ5IHRoaXMgbG9hZGVyIHRvXHJcbiAgICAgICAgICAgICAqIGxvYWQgYmluYXJ5IGNodW5rcyBmcm9tIGRpZmZlcmVudCBhcmNoaXRlY3R1cmVzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIElPRXhjZXB0aW9uICB3aGVuIGhlYWRlciBpcyBtYWxmb3JtZWQgb3Igbm90IHN1aXRhYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICBoZWFkZXIoKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETzpKYXZhIHRvIEFTM1xyXG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ5dGVBcnJheV8xLkJ5dGVBcnJheSgpOyAvLyAoSEVBREVSU0laRSk7IC8vYnl0ZVtdXHJcbiAgICAgICAgICAgIHZhciBhcnJCdWYgPSBuZXcgQXJyYXkoTG9hZGVyLkhFQURFUlNJWkUpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IExvYWRlci5IRUFERVJTSVpFOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyckJ1ZltpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG47XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2soYnVmKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IExvYWRlci5IRUFERVJTSVpFOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyckJ1ZltpXSA9IGJ1Zi5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHBva2UgdGhlIEhFQURFUidzIGVuZGlhbm5lc3MgYnl0ZSBhbmQgY29tcGFyZS5cclxuICAgICAgICAgICAgTG9hZGVyLkhFQURFUls2XSA9IGFyckJ1Zls2XTtcclxuICAgICAgICAgICAgaWYgKGJ1Zi5nZXQoNikgPCAwIHx8IGJ1Zi5nZXQoNikgPiAxIHx8ICFMb2FkZXIuYXJyYXlFcXVhbHMoTG9hZGVyLkhFQURFUiwgYXJyQnVmKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElPRXhjZXB0aW9uXzEuSU9FeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9iaWdlbmRpYW4gPSAoYnVmLmdldCg2KSA9PSAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5kdW1wcyBhbiBpbnQuICBUaGlzIG1ldGhvZCBzd2FicyBhY2NvcmRpbmdseS5cclxuICAgICAgICAgKiBzaXplX3QgYW5kIEluc3RydWN0aW9uIG5lZWQgc3dhYmJpbmcgdG9vLCBidXQgdGhlIGNvZGVcclxuICAgICAgICAgKiBzaW1wbHkgdXNlcyB0aGlzIG1ldGhvZCB0byBsb2FkIHNpemVfdCBhbmQgSW5zdHJ1Y3Rpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW50TG9hZCgpIHtcclxuICAgICAgICAgICAgLy8gOmludDpzaXplICBIZXJlIHdlIGFzc3VtZSBhbiBpbnQgaXMgNCBieXRlcy5cclxuICAgICAgICAgICAgdGhpcy5ibG9jayh0aGlzLl9pbnRidWYpO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgLy8gQ2F1dGlvbjogYnl0ZSBpcyBzaWduZWQgc28gXCImMHhmZlwiIGNvbnZlcnRzIHRvIHVuc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fYmlnZW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gKCh0aGlzLl9pbnRidWYuZ2V0KDApICYgMHhmZikgPDwgMjQpIHwgKCh0aGlzLl9pbnRidWYuZ2V0KDEpICYgMHhmZikgPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAoKHRoaXMuX2ludGJ1Zi5nZXQoMikgJiAweGZmKSA8PCA4KSB8ICh0aGlzLl9pbnRidWYuZ2V0KDMpICYgMHhmZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpID0gKCh0aGlzLl9pbnRidWYuZ2V0KDMpICYgMHhmZikgPDwgMjQpIHwgKCh0aGlzLl9pbnRidWYuZ2V0KDIpICYgMHhmZikgPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAoKHRoaXMuX2ludGJ1Zi5nZXQoMSkgJiAweGZmKSA8PCA4KSB8ICh0aGlzLl9pbnRidWYuZ2V0KDApICYgMHhmZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIC8qIG1pbmltdW0gZm9vdHByaW50IHZlcnNpb24/XHJcbiAgICAgICAgICAgIGludCByZXN1bHQgPSAwIDtcclxuICAgICAgICAgICAgZm9yIChpbnQgc2hpZnQgPSAwIDsgc2hpZnQgPCAzMiA7IHNoaWZ0Kz04KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgYnl0ID0gYnl0ZUxvYWQgKCkgO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJpZ2VuZGlhbilcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgfCBieXQgO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IGJ5dCA8PCBzaGlmdCA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA7XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8qIGFub3RoZXIgdmVyc2lvbj9cclxuICAgICAgICAgICAgaWYgKGJpZ2VuZGlhbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHJlc3VsdCA9IGJ5dGVMb2FkKCkgPDwgMjQgO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IGJ5dGVMb2FkICgpIDw8IDE2IDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSBieXRlTG9hZCAoKSA8PCA4IDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSBieXRlTG9hZCAoKSA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHJlc3VsdCA9IGJ5dGVMb2FkKCkgO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IGJ5dGVMb2FkICgpIDw8IDggO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IGJ5dGVMb2FkICgpIDw8IDE2IDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSBieXRlTG9hZCAoKSA8PCAyNCA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0IDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbmR1bXBzIGEgTHVhIG51bWJlci4gIFdoaWNoIGlzIGFzc3VtZWQgdG8gYmUgYSA2NC1iaXQgSUVFRSBkb3VibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbnVtYmVyKCkge1xyXG4gICAgICAgICAgICAvLyA6bHVhX051bWJlcjpzaXplICBIZXJlIHdlIGFzc3VtZSB0aGF0IHRoZSBzaXplIGlzIDguXHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2sodGhpcy5fbG9uZ2J1Zik7XHJcbiAgICAgICAgICAgIC8vIEJpZy1lbmRpYW4gYXJjaGl0ZWN0dXJlcyBzdG9yZSBkb3VibGVzIHdpdGggdGhlIHNpZ24gYml0IGZpcnN0O1xyXG4gICAgICAgICAgICAvLyBsaXR0bGUtZW5kaWFuIGlzIHRoZSBvdGhlciB3YXkgYXJvdW5kLlxyXG4gICAgICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYmlnZW5kaWFuKVxyXG4gICAgICAgICAgICAgICAgICAgIGwgPSAobCA8PCA4KSB8ICh0aGlzLl9sb25nYnVmLmdldChpKSAmIDB4ZmYpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGwgPSAobCA+Pj4gOCkgfCAoKHRoaXMuX2xvbmdidWYuZ2V0KGkpICYgMHhmZikgPDwgNTYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVE9ETzpcclxuICAgICAgICAgICAgdmFyIGQgPSBsOyAvL0RvdWJsZS5sb25nQml0c1RvRG91YmxlKGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gTHVhXzEuTHVhLnZhbHVlT2ZOdW1iZXIoZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuZHVtcHMgdGhlIDxjb2RlPlByb3RvPC9jb2RlPiBhcnJheSBjb250YWluZWQgaW5zaWRlIGFcclxuICAgICAgICAgKiA8Y29kZT5Qcm90bzwvY29kZT4gb2JqZWN0LiAgVGhlc2UgYXJlIHRoZSA8Y29kZT5Qcm90bzwvY29kZT5cclxuICAgICAgICAgKiBvYmplY3RzIGZvciBhbGwgaW5uZXIgZnVuY3Rpb25zIGRlZmluZWQgaW5zaWRlIGFuIGV4aXN0aW5nXHJcbiAgICAgICAgICogZnVuY3Rpb24uICBDb3JyZXNwb25kcyB0byB0aGUgc2Vjb25kIGhhbGYgb2YgUFVDLVJpbydzXHJcbiAgICAgICAgICogPGNvZGU+TG9hZENvbnN0YW50czwvY29kZT4gZnVuY3Rpb24uICBTZWUgPGNvZGU+Y29uc3RhbnQ8L2NvZGU+IGZvclxyXG4gICAgICAgICAqIHRoZSBmaXJzdCBoYWxmLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByb3RvKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuaW50TG9hZCgpO1xyXG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBBcnJheShuKTsgLy9Qcm90b1tdIFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgcFtpXSA9IHRoaXMuX2Z1bmN0aW9uKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuZHVtcHMgYSB7QGxpbmsgU3RyaW5nfSBvciA8Y29kZT5udWxsPC9jb2RlPi4gIEFzIHBlclxyXG4gICAgICAgICAqIDxjb2RlPkxvYWRTdHJpbmc8L2NvZGU+IGluXHJcbiAgICAgICAgICogUFVDLVJpbydzIGx1bmR1bXAuYy4gIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCBmcm9tIHRoZSBiaW5hcnlcclxuICAgICAgICAgKiB1c2luZyB0aGUgVVRGLTggZW5jb2RpbmcsIHVzaW5nIHRoZSB7QGxpbmtcclxuICAgICAgICAgKiBqYXZhLmxhbmcuU3RyaW5nI1N0cmluZyhieXRlW10sIFN0cmluZykgU3RyaW5nKGJ5dGVbXSwgU3RyaW5nKX1cclxuICAgICAgICAgKiBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdHJpbmcoKSB7XHJcbiAgICAgICAgICAgIC8vIDpzaXplX3Q6c2l6ZSB3ZSBhc3N1bWUgdGhhdCBzaXplX3QgaXMgc2FtZSBzaXplIGFzIGludC5cclxuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmludExvYWQoKTtcclxuICAgICAgICAgICAgaWYgKHNpemUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy92YXIgYnVmOkFycmF5ID0gbmV3IEFycmF5KHNpemUgLSAxKTsgLy9ieXRlW11cclxuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCeXRlQXJyYXlfMS5CeXRlQXJyYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5ibG9jayhidWYpO1xyXG4gICAgICAgICAgICAvLyBEaXNjYXJkIHRyYWlsaW5nIE5VTCBieXRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbi5yZWFkKCkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRU9GRXhjZXB0aW9uXzEuRU9GRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWYucmVhZFVURkJ5dGVzKHNpemUgLSAxKTsgLy8obmV3IFN0cmluZyhidWYsIFwiVVRGLThcIikpLmludGVybigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDTERDIDEuMSBkb2VzIG5vdCBwcm92aWRlIDxjb2RlPmphdmEudXRpbC5BcnJheXM8L2NvZGU+IHNvIHdlIG1ha2VcclxuICAgICAgICAgKiBkbyB3aXRoIHRoaXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGFycmF5RXF1YWxzKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHgubGVuZ3RoICE9IHkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeFtpXSAhPSB5W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTG9hZGVyID0gTG9hZGVyO1xyXG4gICAgTG9hZGVyLkhFQURFUlNJWkUgPSAxMjtcclxuICAgIC8qKiBBIGNodW5rIGhlYWRlciB0aGF0IGlzIGNvcnJlY3QuICBFeGNlcHQgZm9yIHRoZSBlbmRpYW4gYnl0ZSwgYXRcclxuICAgICAqIGluZGV4IDYsIHdoaWNoIGlzIGFsd2F5cyBvdmVyd3JpdHRlbiB3aXRoIHRoZSBvbmUgZnJvbSB0aGUgZmlsZSxcclxuICAgICAqIGJlZm9yZSBjb21wYXJpc29uLiAgV2UgY29wZSB3aXRoIGVpdGhlciBlbmRpYW5uZXNzLlxyXG4gICAgICogRGVmYXVsdCBhY2Nlc3Mgc28gdGhhdCB7QGxpbmsgTHVhI2xvYWR9IGNhbiByZWFkIHRoZSBmaXJzdCBlbnRyeS5cclxuICAgICAqIE9uIG5vIGFjY291bnQgc2hvdWxkIGFueW9uZSBleGNlcHQge0BsaW5rICNoZWFkZXJ9IG1vZGlmeVxyXG4gICAgICogdGhpcyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgTG9hZGVyLkhFQURFUiA9IFtcclxuICAgICAgICBwYXJzZUludChcIjAzM1wiLCA4KSwgKCdMJy5jaGFyQ29kZUF0KDApKSwgKCd1Jy5jaGFyQ29kZUF0KDApKSwgKCdhJy5jaGFyQ29kZUF0KDApKSxcclxuICAgICAgICAweDUxLCAwLCA5OSwgNCxcclxuICAgICAgICA0LCA0LCA4LCAwXHJcbiAgICBdO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyLmpzLm1hcCIsIi8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9Mb2NWYXIuamF2YSMxICRcclxuICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkxvY1ZhciA9IHZvaWQgMDtcclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIGNsYXNzIExvY1ZhciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zhcm5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydHBjID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kcGMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbml0KHZhcm5hbWUsIHN0YXJ0cGMsIGVuZHBjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zhcm5hbWUgPSB2YXJuYW1lO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydHBjID0gc3RhcnRwYztcclxuICAgICAgICAgICAgdGhpcy5fZW5kcGMgPSBlbmRwYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgdmFybmFtZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zhcm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgc2V0IHZhcm5hbWUodmFybmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YXJuYW1lID0gdmFybmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgc3RhcnRwYygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0cGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgc2V0IHN0YXJ0cGMoc3RhcnRwYykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydHBjID0gc3RhcnRwYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgZW5kcGMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRwYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBzZXQgZW5kcGMoZW5kcGMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5kcGMgPSBlbmRwYztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkxvY1ZhciA9IExvY1ZhcjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvY1Zhci5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL2phdmEvRGF0YU91dHB1dFN0cmVhbVwiLCBcIi4uL2phdmEvSU9FeGNlcHRpb25cIiwgXCIuLi9qYXZhL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiLCBcIi4uL2phdmEvTnVsbFBvaW50ZXJFeGNlcHRpb25cIiwgXCIuLi9qYXZhL051bWJlckZvcm1hdEV4Y2VwdGlvblwiLCBcIi4uL2phdmEvT3V0T2ZNZW1vcnlFcnJvclwiLCBcIi4uL2phdmEvUnVudGltZVwiLCBcIi4uL2phdmEvUnVudGltZUV4Y2VwdGlvblwiLCBcIi4uL2phdmEvU3RhY2tcIiwgXCIuLi9qYXZhL1N0cmluZ0J1ZmZlclwiLCBcIi4uL2phdmEvU3lzdGVtVXRpbFwiLCBcIi4vU2xvdFwiLCBcIi4vTHVhVGFibGVcIiwgXCIuL0NhbGxJbmZvXCIsIFwiLi9MdWFGdW5jdGlvblwiLCBcIi4vTHVhSmF2YUNhbGxiYWNrXCIsIFwiLi9MdWFVc2VyZGF0YVwiLCBcIi4vTHVhRXJyb3JcIiwgXCIuL0RlYnVnXCIsIFwiLi9TdHJpbmdSZWFkZXJcIiwgXCIuL0x1YUludGVybmFsXCIsIFwiLi9VcFZhbFwiLCBcIi4vRm9ybWF0SXRlbVwiLCBcIi4vRHVtcFN0YXRlXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5MdWEgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBEYXRhT3V0cHV0U3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vamF2YS9EYXRhT3V0cHV0U3RyZWFtXCIpO1xyXG4gICAgY29uc3QgSU9FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0lPRXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vamF2YS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbiAgICBjb25zdCBOdWxsUG9pbnRlckV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2phdmEvTnVsbFBvaW50ZXJFeGNlcHRpb25cIik7XHJcbiAgICBjb25zdCBOdW1iZXJGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL051bWJlckZvcm1hdEV4Y2VwdGlvblwiKTtcclxuICAgIGNvbnN0IE91dE9mTWVtb3J5RXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL091dE9mTWVtb3J5RXJyb3JcIik7XHJcbiAgICBjb25zdCBSdW50aW1lXzEgPSByZXF1aXJlKFwiLi4vamF2YS9SdW50aW1lXCIpO1xyXG4gICAgY29uc3QgUnVudGltZUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2phdmEvUnVudGltZUV4Y2VwdGlvblwiKTtcclxuICAgIGNvbnN0IFN0YWNrXzEgPSByZXF1aXJlKFwiLi4vamF2YS9TdGFja1wiKTtcclxuICAgIGNvbnN0IFN0cmluZ0J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL2phdmEvU3RyaW5nQnVmZmVyXCIpO1xyXG4gICAgY29uc3QgU3lzdGVtVXRpbF8xID0gcmVxdWlyZShcIi4uL2phdmEvU3lzdGVtVXRpbFwiKTtcclxuICAgIGNvbnN0IFNsb3RfMSA9IHJlcXVpcmUoXCIuL1Nsb3RcIik7XHJcbiAgICBjb25zdCBMdWFUYWJsZV8xID0gcmVxdWlyZShcIi4vTHVhVGFibGVcIik7XHJcbiAgICBjb25zdCBDYWxsSW5mb18xID0gcmVxdWlyZShcIi4vQ2FsbEluZm9cIik7XHJcbiAgICBjb25zdCBMdWFGdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vTHVhRnVuY3Rpb25cIik7XHJcbiAgICBjb25zdCBMdWFKYXZhQ2FsbGJhY2tfMSA9IHJlcXVpcmUoXCIuL0x1YUphdmFDYWxsYmFja1wiKTtcclxuICAgIGNvbnN0IEx1YVVzZXJkYXRhXzEgPSByZXF1aXJlKFwiLi9MdWFVc2VyZGF0YVwiKTtcclxuICAgIGNvbnN0IEx1YUVycm9yXzEgPSByZXF1aXJlKFwiLi9MdWFFcnJvclwiKTtcclxuICAgIGNvbnN0IERlYnVnXzEgPSByZXF1aXJlKFwiLi9EZWJ1Z1wiKTtcclxuICAgIGNvbnN0IFN0cmluZ1JlYWRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nUmVhZGVyXCIpO1xyXG4gICAgY29uc3QgTHVhSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL0x1YUludGVybmFsXCIpO1xyXG4gICAgY29uc3QgVXBWYWxfMSA9IHJlcXVpcmUoXCIuL1VwVmFsXCIpO1xyXG4gICAgY29uc3QgRm9ybWF0SXRlbV8xID0gcmVxdWlyZShcIi4vRm9ybWF0SXRlbVwiKTtcclxuICAgIGNvbnN0IER1bXBTdGF0ZV8xID0gcmVxdWlyZShcIi4vRHVtcFN0YXRlXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL0x1YS5qYXZhIzMgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIC8qKlxyXG4gICAgICogPHA+XHJcbiAgICAgKiBFbmNhcHN1bGF0ZXMgYSBMdWEgZXhlY3V0aW9uIGVudmlyb25tZW50LiAgQSBsb3Qgb2YgSmlsbCdzIHB1YmxpYyBBUElcclxuICAgICAqIG1hbmlmZXN0cyBhcyBwdWJsaWMgbWV0aG9kcyBpbiB0aGlzIGNsYXNzLiAgQSBrZXkgcGFydCBvZiB0aGUgQVBJIGlzXHJcbiAgICAgKiB0aGUgYWJpbGl0eSB0byBjYWxsIEx1YSBmdW5jdGlvbnMgZnJvbSBKYXZhICh1bHRpbWF0ZWx5LCBhbGwgTHVhIGNvZGVcclxuICAgICAqIGlzIGV4ZWN1dGVkIGluIHRoaXMgbWFubmVyKS5cclxuICAgICAqIDwvcD5cclxuICAgICAqXHJcbiAgICAgKiA8cD5cclxuICAgICAqIFRoZSBTdGFja1xyXG4gICAgICogPC9wPlxyXG4gICAgICpcclxuICAgICAqIDxwPlxyXG4gICAgICogQWxsIGFyZ3VtZW50cyB0byBMdWEgZnVuY3Rpb25zIGFuZCBhbGwgcmVzdWx0cyByZXR1cm5lZCBieSBMdWFcclxuICAgICAqIGZ1bmN0aW9ucyBhcmUgcGxhY2VkIG9udG8gYSBzdGFjay4gIFRoZSBzdGFjayBjYW4gYmUgaW5kZXhlZCBieSBhblxyXG4gICAgICogaW50ZWdlciBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIFBVQy1SaW8gaW1wbGVtZW50YXRpb24uICBBIHBvc2l0aXZlXHJcbiAgICAgKiBpbmRleCBpcyBhbiBhYnNvbHV0ZSBpbmRleCBhbmQgcmFuZ2VzIGZyb20gMSAodGhlIGJvdHRvbS1tb3N0XHJcbiAgICAgKiBlbGVtZW50KSB0aHJvdWdoIHRvIDx2YXI+bjwvdmFyPiAodGhlIHRvcC1tb3N0IGVsZW1lbnQpLFxyXG4gICAgICogd2hlcmUgPHZhcj5uPC92YXI+IGlzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb24gdGhlIHN0YWNrLiAgTmVnYXRpdmVcclxuICAgICAqIGluZGV4ZXMgYXJlIHJlbGF0aXZlIGluZGV4ZXMsIC0xIGlzIHRoZSB0b3AtbW9zdCBlbGVtZW50LCAtMiBpcyB0aGVcclxuICAgICAqIGVsZW1lbnQgdW5kZXJuZWF0aCB0aGF0LCBhbmQgc28gb24uICAwIGlzIG5vdCB1c2VkLlxyXG4gICAgICogPC9wPlxyXG4gICAgICpcclxuICAgICAqIDxwPlxyXG4gICAgICogTm90ZSB0aGF0IGluIEppbGwgdGhlIHN0YWNrIGlzIHVzZWQgb25seSBmb3IgcGFzc2luZyBhcmd1bWVudHMgYW5kXHJcbiAgICAgKiByZXR1cm5pbmcgcmVzdWx0cywgdW5saWtlIFBVQy1SaW8uXHJcbiAgICAgKiA8L3A+XHJcbiAgICAgKlxyXG4gICAgICogPHA+XHJcbiAgICAgKiBUaGUgcHJvdG9jb2wgZm9yIGNhbGxpbmcgYSBmdW5jdGlvbiBpcyBkZXNjcmliZWQgaW4gdGhlIHtAbGluayAjY2FsbH1cclxuICAgICAqIG1ldGhvZC4gIEluIGJyaWVmOiBwdXNoIHRoZSBmdW5jdGlvbiBvbnRvIHRoZSBzdGFjaywgdGhlbiBwdXNoIHRoZVxyXG4gICAgICogYXJndW1lbnRzIHRvIHRoZSBjYWxsLlxyXG4gICAgICogPC9wPlxyXG4gICAgICpcclxuICAgICAqIDxwPlxyXG4gICAgICogVGhlIG1ldGhvZHMge0BsaW5rICNwdXNofSwge0BsaW5rICNwb3B9LCB7QGxpbmsgI3ZhbHVlfSxcclxuICAgICAqIHtAbGluayAjZ2V0VG9wfSwge0BsaW5rICNzZXRUb3B9IGFyZSB1c2VkIHRvIG1hbmlwdWxhdGUgdGhlIHN0YWNrLlxyXG4gICAgICogPC9wPlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBMdWEge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgdG8gY29uc3RydWN0IGEgTHVhIHRocmVhZCB0aGF0IHNoYXJlcyBpdHMgZ2xvYmFsIHN0YXRlIHdpdGhcclxuICAgICAgICAgKiBhbm90aGVyIEx1YSBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdHJ1Y3RvcihMKSB7XHJcbiAgICAgICAgICAgIC8qKiBWTSBkYXRhIHN0YWNrLlxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFjayA9IG5ldyBBcnJheSgpOyAvL1RPRE86PTA/IFNsb3RbXSBcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICogT25lIG1vcmUgdGhhbiB0aGUgaGlnaGVzdCBzdGFjayBzbG90IHRoYXQgaGFzIGJlZW4gd3JpdHRlbiB0b1xyXG4gICAgICAgICAgICAqIChldmVyKS5cclxuICAgICAgICAgICAgKiBVc2VkIGJ5IHtAbGluayAjc3RhY2tzZXRzaXplfSB0byBkZXRlcm1pbmUgd2hpY2ggc3RhY2sgc2xvdHNcclxuICAgICAgICAgICAgKiBuZWVkIG5pbGxpbmcgd2hlbiBncm93aW5nIHRoZSBzdGFjay5cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fc3RhY2toaWdod2F0ZXIgPSAwOyAvLyA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAqIE51bWJlciBvZiBhY3RpdmUgZWxlbWVtZW50cyBpbiB0aGUgVk0gc3RhY2suICBTaG91bGQgYWx3YXlzIGJlXHJcbiAgICAgICAgICAgICogPGNvZGU+PD0gc3RhY2subGVuZ3RoPC9jb2RlPi5cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tTaXplID0gMDsgLy8gPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgKiBUaGUgYmFzZSBzdGFjayBlbGVtZW50IGZvciB0aGlzIHN0YWNrIGZyYW1lLiAgSWYgaW4gYSBMdWEgZnVuY3Rpb25cclxuICAgICAgICAgICAgKiB0aGVuIHRoaXMgaXMgdGhlIGVsZW1lbnQgaW5kZXhlZCBieSBvcGVyYW5kIGZpZWxkIDA7IGlmIGluIGEgSmF2YVxyXG4gICAgICAgICAgICAqIGZ1bmN0aXBuIHRoZW4gdGhpcyBpcyB0aGUgZWxlbWVudCBpbmRleGVkIGJ5IEx1YS52YWx1ZSgxKS5cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fYmFzZSA9IDA7IC8vID0gMDtcclxuICAgICAgICAgICAgLy9UT0RPOnB1YmxpY1xyXG4gICAgICAgICAgICB0aGlzLl9uQ2NhbGxzID0gMDsgLy8gPSAwO1xyXG4gICAgICAgICAgICAvKiogSW5zdHJ1Y3Rpb24gdG8gcmVzdW1lIGV4ZWN1dGlvbiBhdC4gIEluZGV4IGludG8gY29kZSBhcnJheS4gKi9cclxuICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IDA7IC8vID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICogVmVjdG9yIG9mIENhbGxJbmZvIHJlY29yZHMuICBBY3R1YWxseSBpdCdzIGEgU3RhY2sgd2hpY2ggaXMgYVxyXG4gICAgICAgICAgICAqIHN1YmNsYXNzIG9mIFZlY3RvciwgYnV0IGl0IG1vc3RseSB0aGUgVmVjdG9yIG1ldGhvZHMgdGhhdCBhcmUgdXNlZC5cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fY2l2ID0gbmV3IFN0YWNrXzEuU3RhY2soKTtcclxuICAgICAgICAgICAgLyoqIE9wZW4gVXB2YWx1ZXMuICBBbGwgVXBWYWwgb2JqZWN0cyB0aGF0IHJlZmVyZW5jZSB0aGUgVk0gc3RhY2suXHJcbiAgICAgICAgICAgICogb3BlbnVwdmFsIGlzIGEgamF2YS51dGlsLlZlY3RvciBvZiBVcFZhbCBzdG9yZWQgaW4gb3JkZXIgb2Ygc3RhY2tcclxuICAgICAgICAgICAgKiBzbG90IGluZGV4OiBoaWdoZXIgc3RhY2sgaW5kZXhlcyBhcmUgc3RvcmVkIGF0IGhpZ2hlciBWZWN0b3JcclxuICAgICAgICAgICAgKiBwb3NpdGlvbnMuXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX29wZW51cHZhbCA9IG5ldyBBcnJheSgpOyAvL1ZlY3RvciA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5faG9va2NvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYmFzZWhvb2tjb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbG93aG9vayA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvb2sgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9ob29rbWFzayA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAqIFRoZSBjdXJyZW50IGVycm9yIGhhbmRsZXIgKHNldCBieSB7QGxpbmsgI3BjYWxsfSkuICBBIEx1YVxyXG4gICAgICAgICAgICAqIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2VycmZ1bmMgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgKiB0aHJlYWQgYWN0aXZhdGlvbiBzdGF0dXMuXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDA7XHJcbiAgICAgICAgICAgIGlmIChMID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vQ3JlYXRlcyBhIGZyZXNoIEx1YSBzdGF0ZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2dsb2JhbCA9IG5ldyBMdWFUYWJsZV8xLkx1YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IG5ldyBMdWFUYWJsZV8xLkx1YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhdGFibGUgPSBuZXcgQXJyYXkoTHVhLk5VTV9UQUdTKTsgLy9MdWFUYWJsZVtdXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWluID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGdsb2JhbCBzdGF0ZSwgdGhhdCdzIHNoYXJlZCBhY3Jvc3MgYWxsIHRocmVhZHMgdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gc2hhcmUgdGhlIHNhbWUgbWFpbiB0aHJlYWQsIGludG8gdGhlIG5ldyBMdWEgdGhyZWFkLlxyXG4gICAgICAgICAgICAgICAgLy8gQW55IG1vcmUgdGhhbiB0aGlzIGFuZCB0aGUgZ2xvYmFsIHN0YXRlIHNob3VsZCBiZSBzaHVudGVkIHRvIGFcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRlIG9iamVjdCAoYXMgaXQgaXMgaW4gUFVDLVJpbykuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWwgPSBMLl9nbG9iYWw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IEwuX3JlZ2lzdHJ5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0YXRhYmxlID0gTC5fbWV0YXRhYmxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFpbiA9IChMID09IG51bGwgPyBMIDogdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9UT0RPOumZhOWKoOaTjeS9nO+8jOWIneWni+WMlkNhbGxJbmZv5aCG5qCIXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdENpdigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgaW5pdENpdigpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2l2LmFkZEVsZW1lbnQobmV3IENhbGxJbmZvXzEuQ2FsbEluZm8oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBDYWxsSW5mbyByZWNvcmQgZm9yIGN1cnJlbnRseSBhY3RpdmUgZnVuY3Rpb24uICovXHJcbiAgICAgICAgX19jaSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Npdi5sYXN0RWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxscyBhIEx1YSB2YWx1ZS4gIE5vcm1hbGx5IHRoaXMgaXMgY2FsbGVkIG9uIGZ1bmN0aW9ucywgYnV0IHRoZVxyXG4gICAgICAgICAqIHNlbWFudGljcyBvZiBMdWEgcGVybWl0IGNhbGxzIG9uIGFueSB2YWx1ZSBhcyBsb25nIGFzIGl0cyBtZXRhdGFibGVcclxuICAgICAgICAgKiBwZXJtaXRzIGl0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSW4gb3JkZXIgdG8gY2FsbCBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gbXVzdCBiZVxyXG4gICAgICAgICAqIHB1c2hlZCBvbnRvIHRoZSBzdGFjaywgdGhlbiBpdHMgYXJndW1lbnRzIG11c3QgYmVcclxuICAgICAgICAgKiB7QGxpbmsgI3B1c2ggcHVzaGVkfSBvbnRvIHRoZSBzdGFjazsgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHB1c2hlZFxyXG4gICAgICAgICAqIGRpcmVjdGx5IGFmdGVyIHRoZSBmdW5jdGlvbixcclxuICAgICAgICAgKiB0aGVuIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzIGFyZSBwdXNoZWQgaW4gb3JkZXIgKGRpcmVjdFxyXG4gICAgICAgICAqIG9yZGVyKS4gIFRoZSBwYXJhbWV0ZXIgPHZhcj5uYXJnczwvdmFyPiBzcGVjaWZpZXMgdGhlIG51bWJlciBvZlxyXG4gICAgICAgICAqIGFyZ3VtZW50cyAod2hpY2ggbWF5IGJlIDApLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgZnVuY3Rpb24gdmFsdWUgb24gdGhlIHN0YWNrIGFuZCBhbGxcclxuICAgICAgICAgKiB0aGUgYXJndW1lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhlIHN0YWNrIGFuZCByZXBsYWNlZCB3aXRoIHRoZVxyXG4gICAgICAgICAqIHJlc3VsdHMgb2YgdGhlIGZ1bmN0aW9uLCBhZGp1c3RlZCB0byB0aGUgbnVtYmVyIHNwZWNpZmllZCBieVxyXG4gICAgICAgICAqIDx2YXI+bnJlc3VsdHM8L3Zhcj4uICBTbyB0aGUgZmlyc3QgcmVzdWx0IGZyb20gdGhlIGZ1bmN0aW9uIGNhbGwgd2lsbFxyXG4gICAgICAgICAqIGJlIGF0IHRoZSBzYW1lIGluZGV4IHdoZXJlIHRoZSBmdW5jdGlvbiB3YXMgaW1tZWRpYXRlbHkgcHJpb3IgdG9cclxuICAgICAgICAgKiBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG5hcmdzICAgICBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiB0aGlzIGZ1bmN0aW9uIGNhbGwuXHJcbiAgICAgICAgICogQHBhcmFtIG5yZXN1bHRzICBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgcmVxdWlyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2FsbChuYXJncywgbnJlc3VsdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5hcGlDaGVja25lbGVtcyhuYXJncyArIDEpO1xyXG4gICAgICAgICAgICB2YXIgZnVuYyA9IHRoaXMuX3N0YWNrU2l6ZSAtIChuYXJncyArIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnZtQ2FsbChmdW5jLCBucmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsb3NlcyBhIEx1YSBzdGF0ZS4gIEluIHRoaXMgaW1wbGVtZW50YXRpb24sIHRoaXMgbWV0aG9kIGRvZXNcclxuICAgICAgICAgKiBub3RoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsb3NlKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25jYXRlbmF0ZSB2YWx1ZXMgKHVzdWFsbHkgc3RyaW5ncykgb24gdGhlIHN0YWNrLlxyXG4gICAgICAgICAqIDx2YXI+bjwvdmFyPiB2YWx1ZXMgZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFjayBhcmUgY29uY2F0ZW5hdGVkLCBhc1xyXG4gICAgICAgICAqIHN0cmluZ3MsIGFuZCByZXBsYWNlZCB3aXRoIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBuICB0aGUgbnVtYmVyIG9mIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25jYXQobikge1xyXG4gICAgICAgICAgICB0aGlzLmFwaUNoZWNrbmVsZW1zKG4pO1xyXG4gICAgICAgICAgICBpZiAobiA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZtQ29uY2F0KG4sICh0aGlzLl9zdGFja1NpemUgLSB0aGlzLl9iYXNlKSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3AobiAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG4gPT0gMCkgLy8gcHVzaCBlbXB0eSBzdHJpbmdcclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFN0cmluZyhcIlwiKTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIG4gPT0gMTsgbm90aGluZyB0byBkb1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIENyZWF0ZXMgYSBuZXcgZW1wdHkgdGFibGUgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgICAgKiBAcGFyYW0gbmFyciAgbnVtYmVyIG9mIGFycmF5IGVsZW1lbnRzIHRvIHByZS1hbGxvY2F0ZS5cclxuICAgICAgICAqIEBwYXJhbSBucmVjICBudW1iZXIgb2Ygbm9uLWFycmF5IGVsZW1lbnRzIHRvIHByZS1hbGxvY2F0ZS5cclxuICAgICAgICAqIEByZXR1cm4gYSBmcmVzaCB0YWJsZS5cclxuICAgICAgICAqIEBzZWUgI25ld1RhYmxlXHJcbiAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVUYWJsZShuYXJyLCBucmVjKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gbmV3IEx1YVRhYmxlXzEuTHVhVGFibGUoKTtcclxuICAgICAgICAgICAgdC5pbml0KG5hcnIsIG5yZWMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHVtcHMgYSBmdW5jdGlvbiBhcyBhIGJpbmFyeSBjaHVuay5cclxuICAgICAgICAgKiBAcGFyYW0gZnVuY3Rpb24gIHRoZSBMdWEgZnVuY3Rpb24gdG8gZHVtcC5cclxuICAgICAgICAgKiBAcGFyYW0gd3JpdGVyICAgIHRoZSBzdHJlYW0gdGhhdCByZWNlaXZlcyB0aGUgZHVtcGVkIGJpbmFyeS5cclxuICAgICAgICAgKiBAdGhyb3dzIElPRXhjZXB0aW9uIHdoZW4gd3JpdGVyIGRvZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGR1bXAoX2Z1bmN0aW9uLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEoX2Z1bmN0aW9uIGluc3RhbmNlb2YgTHVhRnVuY3Rpb25fMS5MdWFGdW5jdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJT0V4Y2VwdGlvbl8xLklPRXhjZXB0aW9uKFwiQ2Fubm90IGR1bXAgXCIgKyB0aGlzLnR5cGVOYW1lKHRoaXMuX19fX3R5cGUoX2Z1bmN0aW9uKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmID0gX2Z1bmN0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnVEdW1wKGYucHJvdG8sIHdyaXRlciwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBmb3IgZXF1YWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBzZW1hbnRpY3Mgb2YgTHVhJ3NcclxuICAgICAgICAgKiA8Y29kZT49PTwvY29kZT4gb3BlcmF0b3IgKHNvIG1heSBjYWxsIG1ldGFtZXRob2RzKS5cclxuICAgICAgICAgKiBAcGFyYW0gbzEgIGEgTHVhIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSBvMiAgYW5vdGhlciBMdWEgdmFsdWUuXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIHdoZW4gZXF1YWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXF1YWwobzEsIG8yKSB7XHJcbiAgICAgICAgICAgIGlmIChvMSBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2YgKG8xKSA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG8xID09PSAobzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZtRXF1YWxSZWYobzEsIG8yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGVzIGEgTHVhIGVycm9yIHVzaW5nIHRoZSBlcnJvciBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXNzYWdlICB0aGUgZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICAgKiBAcmV0dXJuIG5ldmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ0Vycm9ybXNnKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIENvbnRyb2wgZ2FyYmFnZSBjb2xsZWN0b3IuICBOb3RlIHRoYXQgaW4gSmlsbCBtb3N0IG9mIHRoZSBvcHRpb25zXHJcbiAgICAgICAgKiB0byB0aGlzIGZ1bmN0aW9uIG1ha2Ugbm8gc2Vuc2UgYW5kIHRoZXkgd2lsbCBub3QgZG8gYW55dGhpbmcuXHJcbiAgICAgICAgKiBAcGFyYW0gd2hhdCAgc3BlY2lmaWVzIHdoYXQgR0MgYWN0aW9uIHRvIHRha2UuXHJcbiAgICAgICAgKiBAcGFyYW0gZGF0YSAgZGF0YSB0aGF0IG1heSBiZSB1c2VkIGJ5IHRoZSBhY3Rpb24uXHJcbiAgICAgICAgKiBAcmV0dXJuIHZhcmllcy5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGdjKHdoYXQsIGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHJ0O1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHdoYXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLkdDU1RPUDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLkdDUkVTVEFSVDpcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLkdDQ09MTEVDVDpcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLkdDU1RFUDpcclxuICAgICAgICAgICAgICAgICAgICBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5nYygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuR0NDT1VOVDpcclxuICAgICAgICAgICAgICAgICAgICBydCA9IFJ1bnRpbWVfMS5SdW50aW1lLmdldFJ1bnRpbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChydC50b3RhbE1lbW9yeSgpIC0gcnQuZnJlZU1lbW9yeSgpKSAvIDEwMjQpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuR0NDT1VOVEI6XHJcbiAgICAgICAgICAgICAgICAgICAgcnQgPSBSdW50aW1lXzEuUnVudGltZS5nZXRSdW50aW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgocnQudG90YWxNZW1vcnkoKSAtIHJ0LmZyZWVNZW1vcnkoKSkgJSAxMDI0KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLkdDU0VUUEFVU0U6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5HQ1NFVFNURVBNVUw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyB0aGUgZW52aXJvbm1lbnQgdGFibGUgb2YgdGhlIEx1YSB2YWx1ZS5cclxuICAgICAgICAqIEBwYXJhbSBvICB0aGUgTHVhIHZhbHVlLlxyXG4gICAgICAgICogQHJldHVybiBpdHMgZW52aXJvbm1lbnQgdGFibGUuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBnZXRGZW52KG8pIHtcclxuICAgICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBMdWFGdW5jdGlvbl8xLkx1YUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZjEgPSBvO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGYxLmVudjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEx1YUphdmFDYWxsYmFja18xLkx1YUphdmFDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYyID0gbztcclxuICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBpbXBsZW1lbnQgdGhpcyBjYXNlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBMdWFVc2VyZGF0YV8xLkx1YVVzZXJkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IG87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdS5lbnY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBMdWEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gbztcclxuICAgICAgICAgICAgICAgIHJldHVybiBsLmdsb2JhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGEgZmllbGQgZnJvbSBhIHRhYmxlIChvciBvdGhlciBvYmplY3QpLlxyXG4gICAgICAgICAqIEBwYXJhbSB0ICAgICAgVGhlIG9iamVjdCB3aG9zZSBmaWVsZCB0byByZXRyaWV2ZS5cclxuICAgICAgICAgKiBAcGFyYW0gZmllbGQgIFRoZSBuYW1lIG9mIHRoZSBmaWVsZC5cclxuICAgICAgICAgKiBAcmV0dXJuICB0aGUgTHVhIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RmllbGQodCwgZmllbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFibGUodCwgZmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYSBnbG9iYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgIFRoZSBuYW1lIG9mIHRoZSBnbG9iYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHJldHVybiAgVGhlIHZhbHVlIG9mIHRoZSBnbG9iYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0R2xvYmFsKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGQodGhpcy5fZ2xvYmFsLCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZ2xvYmFsIGVudmlyb25tZW50LiAgVGhlIGdsb2JhbCBlbnZpcm9ubWVudCwgd2hlcmUgZ2xvYmFsXHJcbiAgICAgICAgICogdmFyaWFibGVzIGxpdmUsIGlzIHJldHVybmVkIGFzIGEgPGNvZGU+THVhVGFibGU8L2NvZGU+LiAgTm90ZSB0aGF0XHJcbiAgICAgICAgICogbW9kaWZ5aW5nIHRoaXMgdGFibGUgaGFzIGV4YWN0bHkgdGhlIHNhbWUgZWZmZWN0IGFzIGNyZWF0aW5nIG9yXHJcbiAgICAgICAgICogY2hhbmdpbmcgZ2xvYmFsIHZhcmlhYmxlcyBmcm9tIHdpdGhpbiBMdWEuXHJcbiAgICAgICAgICogQHJldHVybiAgVGhlIGdsb2JhbCBlbnZpcm9ubWVudCBhcyBhIHRhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEdsb2JhbHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbG9iYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBHZXQgbWV0YXRhYmxlLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgTHVhIHZhbHVlIHdob3NlIG1ldGF0YWJsZSB0byByZXRyaWV2ZS5cclxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBtZXRhdGFibGUsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbWV0YXRhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE1ldGF0YWJsZShvKSB7XHJcbiAgICAgICAgICAgIHZhciBtdDtcclxuICAgICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBMdWFUYWJsZV8xLkx1YVRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG87XHJcbiAgICAgICAgICAgICAgICBtdCA9IHQubWV0YXRhYmxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBMdWFVc2VyZGF0YV8xLkx1YVVzZXJkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IG87XHJcbiAgICAgICAgICAgICAgICBtdCA9IHUubWV0YXRhYmxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbXQgPSB0aGlzLl9tZXRhdGFibGVbTHVhLl9fX190eXBlKG8pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHJlZ2lzdHJ5IHRhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFJlZ2lzdHJ5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGV4ZXMgaW50byBhIHRhYmxlIGFuZCByZXR1cm5zIHRoZSB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0gdCAgdGhlIEx1YSB2YWx1ZSB0byBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0gayAgdGhlIGtleSB3aG9zZSB2YWx1ZSB0byByZXR1cm4uXHJcbiAgICAgICAgICogQHJldHVybiB0aGUgdmFsdWUgdFtrXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUYWJsZSh0LCBrKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgIHMuaW5pdDIoayk7XHJcbiAgICAgICAgICAgIHZhciB2ID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgIHRoaXMudm1HZXR0YWJsZSh0LCBzLCB2KTtcclxuICAgICAgICAgICAgcmV0dXJuIHYuYXNPYmplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBzdGFjay4gIElmIHRoZSBzdGFjayBpcyBub3RcclxuICAgICAgICAgKiBlbXB0eSB0aGVuIHRoaXMgaXMgdGhlIGluZGV4IG9mIHRoZSB0b3AtbW9zdCBlbGVtZW50LlxyXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIHN0YWNrIGVsZW1lbnRzLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgZ2V0VG9wKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tTaXplIC0gdGhpcy5fYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0IEx1YSB2YWx1ZSBpbnRvIHN0YWNrIGltbWVkaWF0ZWx5IGF0IHNwZWNpZmllZCBpbmRleC4gIFZhbHVlc1xyXG4gICAgICAgICAqIGluIHN0YWNrIGF0IHRoYXQgaW5kZXggYW5kIGhpZ2hlciBnZXQgcHVzaGVkIHVwLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICAgIHRoZSBMdWEgdmFsdWUgdG8gaW5zZXJ0IGludG8gdGhlIHN0YWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSBpZHggIHRoZSBzdGFjayBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zZXJ0KG8sIGlkeCkge1xyXG4gICAgICAgICAgICBpZHggPSB0aGlzLmFic0luZGV4VW5jbGFtcGVkKGlkeCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tJbnNlcnRBdChvLCBpZHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB0aGF0IGFuIG9iamVjdCBpcyBhIEx1YSBib29sZWFuLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBvYmplY3QgaXMgYSBMdWEgYm9vbGVhbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgaXNCb29sZWFuKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBCb29sZWFuIHx8IHR5cGVvZiAobykgPT0gJ2Jvb2xlYW4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB0aGF0IGFuIG9iamVjdCBpcyBhIEx1YSBmdW5jdGlvbiBpbXBsZW1lbnRhdGVkIGluIEphdmEgKGEgTHVhXHJcbiAgICAgICAgICogSmF2YSBGdW5jdGlvbikuXHJcbiAgICAgICAgICogQHBhcmFtIG8gIHRoZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIG9iamVjdCBpcyBhIEx1YSBKYXZhIEZ1bmN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBpc0phdmFGdW5jdGlvbihvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvIGluc3RhbmNlb2YgTHVhSmF2YUNhbGxiYWNrXzEuTHVhSmF2YUNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB0aGF0IGFuIG9iamVjdCBpcyBhIEx1YSBmdW5jdGlvbiAoaW1wbGVtZW50ZWQgaW4gTHVhIG9yXHJcbiAgICAgICAgICogSmF2YSkuXHJcbiAgICAgICAgICogQHBhcmFtIG8gIHRoZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIG9iamVjdCBpcyBhIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBpc0Z1bmN0aW9uKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBMdWFGdW5jdGlvbl8xLkx1YUZ1bmN0aW9uIHx8XHJcbiAgICAgICAgICAgICAgICBvIGluc3RhbmNlb2YgTHVhSmF2YUNhbGxiYWNrXzEuTHVhSmF2YUNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB0aGF0IGEgTHVhIHRocmVhZCBpcyB0aGUgbWFpbiB0aHJlYWQuXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGFuZCBvbmx5IGlmIGlzIHRoZSBtYWluIHRocmVhZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc01haW4oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzID09IHRoaXMuX21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIHRoYXQgYW4gb2JqZWN0IGlzIEx1YSA8Y29kZT5uaWw8L2NvZGU+LlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBvYmplY3QgaXMgTHVhIDxjb2RlPm5pbDwvY29kZT4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGlzTmlsKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIEx1YS5OSUwgPT0gbztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgdGhhdCBhbiBvYmplY3QgaXMgYSBMdWEgbnVtYmVyIG9yIGEgc3RyaW5nIGNvbnZlcnRpYmxlIHRvIGFcclxuICAgICAgICAgKiBudW1iZXIuXHJcbiAgICAgICAgICogQHBhcmFtIG8gIHRoZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIG9iamVjdCBpcyBhIG51bWJlciBvciBhIGNvbnZlcnRpYmxlIHN0cmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgaXNOdW1iZXIobykge1xyXG4gICAgICAgICAgICBMdWEuU1BBUkVfU0xPVC5zZXRPYmplY3Qobyk7XHJcbiAgICAgICAgICAgIHJldHVybiBMdWEudG9udW1iZXIoTHVhLlNQQVJFX1NMT1QsIEx1YS5OVU1PUCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIHRoYXQgYW4gb2JqZWN0IGlzIGEgTHVhIHN0cmluZyBvciBhIG51bWJlciAod2hpY2ggaXMgYWx3YXlzXHJcbiAgICAgICAgICogY29udmVydGlibGUgdG8gYSBzdHJpbmcpLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGFuZCBvbmx5IGlmIG9iamVjdCBpcyBhIHN0cmluZyBvciBudW1iZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGlzU3RyaW5nKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBTdHJpbmcgfHwgbyBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2YgKG8pID09ICdzdHJpbmcnIHx8IHR5cGVvZiAobykgPT0gJ251bWJlcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIHRoYXQgYW4gb2JqZWN0IGlzIGEgTHVhIHRhYmxlLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgICAgICogQHJldHVybiA8Y29kZT50cnVlPC9jb2RlPiBpZiBhbmQgb25seSBpZiB0aGUgb2JqZWN0IGlzIGEgTHVhIHRhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBpc1RhYmxlKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBMdWFUYWJsZV8xLkx1YVRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB0aGF0IGFuIG9iamVjdCBpcyBhIEx1YSB0aHJlYWQuXHJcbiAgICAgICAgICogQHBhcmFtIG8gIHRoZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAgICAgKiBAcmV0dXJuIDxjb2RlPnRydWU8L2NvZGU+IGlmIGFuZCBvbmx5IGlmIHRoZSBvYmplY3QgaXMgYSBMdWEgdGhyZWFkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBpc1RocmVhZChvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvIGluc3RhbmNlb2YgTHVhO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB0aGF0IGFuIG9iamVjdCBpcyBhIEx1YSB1c2VyZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gbyAgdGhlIE9iamVjdCB0byB0ZXN0LlxyXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGUgb2JqZWN0IGlzIGEgTHVhIHVzZXJkYXRhLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBpc1VzZXJkYXRhKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBMdWFVc2VyZGF0YV8xLkx1YVVzZXJkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA8cD5cclxuICAgICAgICAgKiBUZXN0cyB0aGF0IGFuIG9iamVjdCBpcyBhIEx1YSB2YWx1ZS4gIFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gZm9yXHJcbiAgICAgICAgICogYW4gYXJndW1lbnQgdGhhdCBpcyBhIEppbGwgcmVwcmVzZW50YXRpb24gb2YgYSBMdWEgdmFsdWUsXHJcbiAgICAgICAgICogPGNvZGU+ZmFsc2U8L2NvZGU+IGZvciBKYXZhIHJlZmVyZW5jZXMgdGhhdCBhcmUgbm90IEx1YSB2YWx1ZXMuXHJcbiAgICAgICAgICogRm9yIGV4YW1wbGUgPGNvZGU+aXNWYWx1ZShuZXcgTHVhVGFibGUoKSk8L2NvZGU+IGlzXHJcbiAgICAgICAgICogPGNvZGU+dHJ1ZTwvY29kZT4sIGJ1dCA8Y29kZT5pc1ZhbHVlKG5ldyBPYmplY3RbXSB7IH0pPC9jb2RlPiBpc1xyXG4gICAgICAgICAqIDxjb2RlPmZhbHNlPC9jb2RlPiBiZWNhdXNlIEphdmEgYXJyYXlzIGFyZSBub3QgYSByZXByZXNlbnRhdGlvbiBvZlxyXG4gICAgICAgICAqIGFueSBMdWEgdmFsdWUuXHJcbiAgICAgICAgICogPC9wPlxyXG4gICAgICAgICAqIDxwPlxyXG4gICAgICAgICAqIFBVQy1SaW8gTHVhIHByb3ZpZGVzIG5vXHJcbiAgICAgICAgICogY291bnRlcnBhcnQgZm9yIHRoaXMgbWV0aG9kIGJlY2F1c2UgaW4gdGhlaXIgaW1wbGVtZW50YXRpb24gaXQgaXNcclxuICAgICAgICAgKiBpbXBvc3NpYmxlIHRvIGdldCBub24gTHVhIHZhbHVlcyBvbiB0aGUgc3RhY2ssIHdoZXJlYXMgaW4gSmlsbCBpdFxyXG4gICAgICAgICAqIGlzIGNvbW1vbiB0byBtaXggTHVhIHZhbHVlcyB3aXRoIG9yZGluYXJ5LCBub24gTHVhLCBKYXZhIG9iamVjdHMuXHJcbiAgICAgICAgICogPC9wPlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGFuZCBpZiBpdCByZXByZXNlbnRzIGEgTHVhIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBpc1ZhbHVlKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8gPT0gTHVhLk5JTCB8fFxyXG4gICAgICAgICAgICAgICAgbyBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgdHlwZW9mIChvKSA9PSAnYm9vbGVhbic7XHJcbiAgICAgICAgICAgIG8gaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIChvKSA9PSAnc3RyaW5nJztcclxuICAgICAgICAgICAgbyBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2YgKG8pID09ICdudW1iZXInO1xyXG4gICAgICAgICAgICBvIGluc3RhbmNlb2YgTHVhRnVuY3Rpb25fMS5MdWFGdW5jdGlvbiB8fFxyXG4gICAgICAgICAgICAgICAgbyBpbnN0YW5jZW9mIEx1YUphdmFDYWxsYmFja18xLkx1YUphdmFDYWxsYmFjayB8fFxyXG4gICAgICAgICAgICAgICAgbyBpbnN0YW5jZW9mIEx1YVRhYmxlXzEuTHVhVGFibGUgfHxcclxuICAgICAgICAgICAgICAgIG8gaW5zdGFuY2VvZiBMdWFVc2VyZGF0YV8xLkx1YVVzZXJkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wYXJlcyB0d28gTHVhIHZhbHVlcyBhY2NvcmRpbmcgdG8gdGhlIHNlbWFudGljcyBvZiBMdWEnc1xyXG4gICAgICAgICAqIDxjb2RlPiZsdDs8L2NvZGU+IG9wZXJhdG9yLCBzbyBtYXkgY2FsbCBtZXRhbWV0aG9kcy5cclxuICAgICAgICAgKiBAcGFyYW0gbzEgIHRoZSBsZWZ0LWhhbmQgb3BlcmFuZC5cclxuICAgICAgICAgKiBAcGFyYW0gbzIgIHRoZSByaWdodC1oYW5kIG9wZXJhbmQuXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIHdoZW4gPGNvZGU+bzEgPCBvMjwvY29kZT4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGVzc1RoYW4obzEsIG8yKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgIGEuaW5pdDIobzEpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBTbG90XzEuU2xvdCgpO1xyXG4gICAgICAgICAgICBiLmluaXQyKG8yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudm1MZXNzdGhhbihhLCBiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogPHA+XHJcbiAgICAgICAgICogTG9hZHMgYSBMdWEgY2h1bmsgaW4gYmluYXJ5IG9yIHNvdXJjZSBmb3JtLlxyXG4gICAgICAgICAqIENvbXBhcmFibGUgdG8gQydzIGx1YV9sb2FkLiAgSWYgdGhlIGNodW5rIGlzIGRldGVybWluZWQgdG8gYmVcclxuICAgICAgICAgKiBiaW5hcnkgdGhlbiBpdCBpcyBsb2FkZWQgZGlyZWN0bHkuICBPdGhlcndpc2UgdGhlIGNodW5rIGlzIGFzc3VtZWRcclxuICAgICAgICAgKiB0byBiZSBhIEx1YSBzb3VyY2UgY2h1bmsgYW5kIGNvbXBpbGF0aW9uIGlzIHJlcXVpcmVkIGZpcnN0OyB0aGVcclxuICAgICAgICAgKiA8Y29kZT5JbnB1dFN0cmVhbTwvY29kZT4gaXMgdXNlZCB0byBjcmVhdGUgYSA8Y29kZT5SZWFkZXI8L2NvZGU+XHJcbiAgICAgICAgICogdXNpbmcgdGhlIFVURi04IGVuY29kaW5nXHJcbiAgICAgICAgICogKHVzaW5nIGEgc2Vjb25kIGFyZ3VtZW50IG9mIDxjb2RlPlwiVVRGLThcIjwvY29kZT4gdG8gdGhlXHJcbiAgICAgICAgICoge0BsaW5rIGphdmEuaW8uSW5wdXRTdHJlYW1SZWFkZXIjSW5wdXRTdHJlYW1SZWFkZXIoamF2YS5pby5JbnB1dFN0cmVhbSxcclxuICAgICAgICAgKiBqYXZhLmxhbmcuU3RyaW5nKX1cclxuICAgICAgICAgKiBjb25zdHJ1Y3RvcikgYW5kIHRoZSBMdWEgc291cmNlIGlzIGNvbXBpbGVkLlxyXG4gICAgICAgICAqIDwvcD5cclxuICAgICAgICAgKiA8cD5cclxuICAgICAgICAgKiBJZiBzdWNjZXNzZnVsLCBUaGUgY29tcGlsZWQgY2h1bmssIGEgTHVhIGZ1bmN0aW9uLCBpcyBwdXNoZWQgb250b1xyXG4gICAgICAgICAqIHRoZSBzdGFjayBhbmQgYSB6ZXJvIHN0YXR1cyBjb2RlIGlzIHJldHVybmVkLiAgT3RoZXJ3aXNlIGEgbm9uLXplcm9cclxuICAgICAgICAgKiBzdGF0dXMgY29kZSBpcyByZXR1cm5lZCB0byBpbmRpY2F0ZSBhbiBlcnJvciBhbmQgdGhlIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgKiBpcyBwdXNoZWQgb250byB0aGUgc3RhY2suXHJcbiAgICAgICAgICogPC9wPlxyXG4gICAgICAgICAqIEBwYXJhbSBpbiAgICAgICAgIFRoZSBiaW5hcnkgY2h1bmsgYXMgYW4gSW5wdXRTdHJlYW0sIGZvciBleGFtcGxlIGZyb21cclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICB7QGxpbmsgQ2xhc3MjZ2V0UmVzb3VyY2VBc1N0cmVhbX0uXHJcbiAgICAgICAgICogQHBhcmFtIGNodW5rbmFtZSAgVGhlIG5hbWUgb2YgdGhlIGNodW5rLlxyXG4gICAgICAgICAqIEByZXR1cm4gICAgICAgICAgIEEgc3RhdHVzIGNvZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbG9hZChfaW4sIGNodW5rbmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgbGkgPSBuZXcgTHVhSW50ZXJuYWxfMS5MdWFJbnRlcm5hbCgpO1xyXG4gICAgICAgICAgICBsaS5pbml0MShfaW4sIGNodW5rbmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChsaSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBjYWxsKDAsIDEsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIEx1YSBjaHVuayBpbiBzb3VyY2UgZm9ybS5cclxuICAgICAgICAgKiBDb21wYXJhYmxlIHRvIEMncyBsdWFfbG9hZC4gIFRoaXMgbWV0aG9kIHRha2VzIGEge0BsaW5rXHJcbiAgICAgICAgICogamF2YS5pby5SZWFkZXJ9IHBhcmFtZXRlcixcclxuICAgICAgICAgKiBhbmQgaXMgbm9ybWFsbHkgdXNlZCB0byBsb2FkIEx1YSBjaHVua3MgaW4gc291cmNlIGZvcm0uXHJcbiAgICAgICAgICogSG93ZXZlciwgaXQgaWYgdGhlIGlucHV0IGxvb2tzIGxpa2UgaXQgaXMgdGhlIG91dHB1dCBmcm9tIEx1YSdzXHJcbiAgICAgICAgICogPGNvZGU+c3RyaW5nLmR1bXA8L2NvZGU+IGZ1bmN0aW9uIHRoZW4gaXQgd2lsbCBiZSBwcm9jZXNzZWQgYXMgYVxyXG4gICAgICAgICAqIGJpbmFyeSBjaHVuay5cclxuICAgICAgICAgKiBJbiBldmVyeSBvdGhlciByZXNwZWN0IHRoaXMgbWV0aG9kIGlzIGp1c3QgbGlrZSB7QGxpbmtcclxuICAgICAgICAgKiAjbG9hZChJbnB1dFN0cmVhbSwgU3RyaW5nKX0uXHJcbiAgICAgICAgICog5bqf5byD77yM5ZCI5bm25YWlbG9hZFxyXG4gICAgICAgICAqIEBwYXJhbSBpbiAgICAgICAgIFRoZSBzb3VyY2UgY2h1bmsgYXMgYSBSZWFkZXIsIGZvciBleGFtcGxlIGZyb21cclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICA8Y29kZT5qYXZhLmlvLklucHV0U3RyZWFtUmVhZGVyKENsYXNzLmdldFJlc291cmNlQXNTdHJlYW0oKSk8L2NvZGU+LlxyXG4gICAgICAgICAqIEBwYXJhbSBjaHVua25hbWUgIFRoZSBuYW1lIG9mIHRoZSBjaHVuay5cclxuICAgICAgICAgKiBAcmV0dXJuICAgICAgICAgICBBIHN0YXR1cyBjb2RlLlxyXG4gICAgICAgICAqIEBzZWUgamF2YS5pby5JbnB1dFN0cmVhbVJlYWRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fbG9hZChfaW4sIGNodW5rbmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgbGkgPSBuZXcgTHVhSW50ZXJuYWxfMS5MdWFJbnRlcm5hbCgpO1xyXG4gICAgICAgICAgICBsaS5pbml0MihfaW4sIGNodW5rbmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChsaSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBjYWxsKDAsIDEsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTbG93bHkgZ2V0IHRoZSBuZXh0IGtleSBmcm9tIGEgdGFibGUuICBVbmxpa2UgbW9zdCBvdGhlciBmdW5jdGlvbnNcclxuICAgICAgICAgKiBpbiB0aGUgQVBJIHRoaXMgb25lIHVzZXMgdGhlIHN0YWNrLiAgVGhlIHRvcC1vZi1zdGFjayBpcyBwb3BwZWQgYW5kXHJcbiAgICAgICAgICogdXNlZCB0byBmaW5kIHRoZSBuZXh0IGtleSBpbiB0aGUgdGFibGUgYXQgdGhlIHBvc2l0aW9uIHNwZWNpZmllZCBieVxyXG4gICAgICAgICAqIGluZGV4LiAgSWYgdGhlcmUgaXMgYSBuZXh0IGtleSB0aGVuIHRoZSBrZXkgYW5kIGl0cyB2YWx1ZSBhcmVcclxuICAgICAgICAgKiBwdXNoZWQgb250byB0aGUgc3RhY2sgYW5kIDxjb2RlPnRydWU8L2NvZGU+IGlzIHJldHVybmVkLlxyXG4gICAgICAgICAqIE90aGVyd2lzZSAodGhlIGVuZCBvZiB0aGUgdGFibGUgaGFzIGJlZW4gcmVhY2hlZClcclxuICAgICAgICAgKiA8Y29kZT5mYWxzZTwvY29kZT4gaXMgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGlkeCAgc3RhY2sgaW5kZXggb2YgdGFibGUuXHJcbiAgICAgICAgICogQHJldHVybiAgdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGVyZSBhcmUgbW9yZSBrZXlzIGluIHRoZSB0YWJsZS5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rICN0YWJsZUtleXN9IGVudW1lcmF0aW9uIHByb3RvY29sIGluc3RlYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbmV4dChpZHgpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLnZhbHVlKGlkeCk7XHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBhcGkgY2hlY2tcclxuICAgICAgICAgICAgdmFyIHQgPSBvO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy52YWx1ZSgtMSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wKDEpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHQua2V5cygpO1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09IEx1YS5OSUwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmhhc01vcmVFbGVtZW50cygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZS5uZXh0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdCh0LmdldGx1YShrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoZS5oYXNNb3JlRWxlbWVudHMoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGsgPSBlLm5leHRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5oYXNNb3JlRWxlbWVudHMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBlLm5leHRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hPYmplY3QodC5nZXRsdWEoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvdG9jb2wgZXJyb3Igd2hpY2ggd2UgY291bGQgcG90ZW50aWFsbHkgZGlhZ25vc2UuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBlbXB0eSB0YWJsZSBhbmQgcmV0dXJucyBpdC5cclxuICAgICAgICAgKiBAcmV0dXJuIGEgZnJlc2ggdGFibGUuXHJcbiAgICAgICAgICogQHNlZSAjY3JlYXRlVGFibGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBuZXdUYWJsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMdWFUYWJsZV8xLkx1YVRhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgTHVhIHRocmVhZCBhbmQgcmV0dXJucyBpdC5cclxuICAgICAgICAgKiBAcmV0dXJuIGEgbmV3IEx1YSB0aHJlYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbmV3VGhyZWFkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEx1YSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JhcHMgYW4gYXJiaXRyYXJ5IEphdmEgcmVmZXJlbmNlIGluIGEgTHVhIHVzZXJkYXRhIGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSByZWYgIHRoZSBKYXZhIHJlZmVyZW5jZSB0byB3cmFwLlxyXG4gICAgICAgICAqIEByZXR1cm4gdGhlIG5ldyBMdWFVc2VyZGF0YS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZXdVc2VyZGF0YShyZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMdWFVc2VyZGF0YV8xLkx1YVVzZXJkYXRhKHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgPGVtPmxlbmd0aDwvZW0+IG9mIGEgTHVhIHZhbHVlLiAgRm9yIHN0cmluZ3MgdGhpcyBpc1xyXG4gICAgICAgICAqIHRoZSBzdHJpbmcgbGVuZ3RoOyBmb3IgdGFibGVzLCB0aGlzIGlzIHJlc3VsdCBvZiB0aGUgPGNvZGU+IzwvY29kZT5cclxuICAgICAgICAgKiBvcGVyYXRvcjsgZm9yIG90aGVyIHZhbHVlcyBpdCBpcyAwLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICBhIEx1YSB2YWx1ZS5cclxuICAgICAgICAgKiBAcmV0dXJuIGl0cyBsZW5ndGguXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIG9iakxlbihvKSB7XHJcbiAgICAgICAgICAgIGlmIChvIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiAobykgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gbztcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEx1YVRhYmxlXzEuTHVhVGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gbztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0LmdldG4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobyBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2YgKG8pID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52bVRvc3RyaW5nKG8pLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogPHA+XHJcbiAgICAgICAgICogUHJvdGVjdGVkIHtAbGluayAjY2FsbH0uICA8dmFyPm5hcmdzPC92YXI+IGFuZFxyXG4gICAgICAgICAqIDx2YXI+bnJlc3VsdHM8L3Zhcj4gaGF2ZSB0aGUgc2FtZSBtZWFuaW5nIGFzIGluIHtAbGluayAjY2FsbH0uXHJcbiAgICAgICAgICogSWYgdGhlcmUgYXJlIG5vIGVycm9ycyBkdXJpbmcgdGhlIGNhbGwsIHRoaXMgbWV0aG9kIGJlaGF2ZXMgYXNcclxuICAgICAgICAgKiB7QGxpbmsgI2NhbGx9LiAgQW55IGVycm9ycyBhcmUgY2F1Z2h0LCB0aGUgZXJyb3Igb2JqZWN0ICh1c3VhbGx5XHJcbiAgICAgICAgICogYSBtZXNzYWdlKSBpcyBwdXNoZWQgb250byB0aGUgc3RhY2ssIGFuZCBhIG5vbi16ZXJvIGVycm9yIGNvZGUgaXNcclxuICAgICAgICAgKiByZXR1cm5lZC5cclxuICAgICAgICAgKiA8L3A+XHJcbiAgICAgICAgICogPHA+XHJcbiAgICAgICAgICogSWYgPHZhcj5lcjwvdmFyPiBpcyA8Y29kZT5udWxsPC9jb2RlPiB0aGVuIHRoZSBlcnJvciBvYmplY3QgdGhhdCBpc1xyXG4gICAgICAgICAqIG9uIHRoZSBzdGFjayBpcyB0aGUgb3JpZ2luYWwgZXJyb3Igb2JqZWN0LiAgT3RoZXJ3aXNlXHJcbiAgICAgICAgICogPHZhcj5lZjwvdmFyPiBzcGVjaWZpZXMgYW4gPGVtPmVycm9yIGhhbmRsaW5nIGZ1bmN0aW9uPC9lbT4gd2hpY2hcclxuICAgICAgICAgKiBpcyBjYWxsZWQgd2hlbiB0aGUgb3JpZ2luYWwgZXJyb3IgaXMgZ2VuZXJhdGVkOyBpdHMgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICogYmVjb21lcyB0aGUgZXJyb3Igb2JqZWN0IGxlZnQgb24gdGhlIHN0YWNrIGJ5IDxjb2RlPnBjYWxsPC9jb2RlPi5cclxuICAgICAgICAgKiA8L3A+XHJcbiAgICAgICAgICogQHBhcmFtIG5hcmdzICAgICBudW1iZXIgb2YgYXJndW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSBucmVzdWx0cyAgbnVtYmVyIG9mIHJlc3VsdCByZXF1aXJlZC5cclxuICAgICAgICAgKiBAcGFyYW0gZWYgICAgICAgIGVycm9yIGZ1bmN0aW9uIHRvIGNhbGwgaW4gY2FzZSBvZiBlcnJvci5cclxuICAgICAgICAgKiBAcmV0dXJuIDAgaWYgc3VjY2Vzc2Z1bCwgZWxzZSBhIG5vbi16ZXJvIGVycm9yIGNvZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGNhbGwobmFyZ3MsIG5yZXN1bHRzLCBlZikge1xyXG4gICAgICAgICAgICB0aGlzLmFwaUNoZWNrbmVsZW1zKG5hcmdzICsgMSk7XHJcbiAgICAgICAgICAgIHZhciByZXN0b3JlU3RhY2sgPSB0aGlzLl9zdGFja1NpemUgLSAobmFyZ3MgKyAxKTtcclxuICAgICAgICAgICAgLy8gTW9zdCBvZiB0aGlzIGNvZGUgY29tZXMgZnJvbSBsdWFEX3BjYWxsXHJcbiAgICAgICAgICAgIHZhciByZXN0b3JlQ2kgPSB0aGlzLl9jaXYuc2l6ZTtcclxuICAgICAgICAgICAgdmFyIG9sZG5DY2FsbHMgPSB0aGlzLl9uQ2NhbGxzO1xyXG4gICAgICAgICAgICB2YXIgb2xkX2VycmZ1bmMgPSB0aGlzLl9lcnJmdW5jO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJmdW5jID0gZWY7XHJcbiAgICAgICAgICAgIHZhciBvbGRfYWxsb3dob29rID0gdGhpcy5fYWxsb3dob29rO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JTdGF0dXMgPSAwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKG5hcmdzLCBucmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTHVhRXJyb3JfMS5MdWFFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZkNsb3NlKHJlc3RvcmVTdGFjayk7IC8vIGNsb3NlIGV2ZW50dWFsIHBlbmRpbmcgY2xvc3VyZXNcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRTZXRlcnJvcm9iaihlLmVycm9yU3RhdHVzLCByZXN0b3JlU3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25DY2FsbHMgPSBvbGRuQ2NhbGxzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Npdi5zaXplID0gcmVzdG9yZUNpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaSA9IHRoaXMuX19jaSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2UgPSBjaS5iYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkcGMgPSBjaS5zYXZlZHBjO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbG93aG9vayA9IG9sZF9hbGxvd2hvb2s7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTdGF0dXMgPSBlLmVycm9yU3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZSBpbnN0YW5jZW9mIE91dE9mTWVtb3J5RXJyb3JfMS5PdXRPZk1lbW9yeUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mQ2xvc2UocmVzdG9yZVN0YWNrKTsgLy8gY2xvc2UgZXZlbnR1YWwgcGVuZGluZyBjbG9zdXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZFNldGVycm9yb2JqKEx1YS5FUlJNRU0sIHJlc3RvcmVTdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbkNjYWxscyA9IG9sZG5DY2FsbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2l2LnNpemUgPSByZXN0b3JlQ2k7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNpMiA9IHRoaXMuX19jaSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2UgPSBjaTIuYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gY2kyLnNhdmVkcGM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dob29rID0gb2xkX2FsbG93aG9vaztcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclN0YXR1cyA9IEx1YS5FUlJNRU07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqL1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJmdW5jID0gb2xkX2VycmZ1bmM7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvclN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyAoYW5kIGRpc2NhcmRzKSB0aGUgdG9wLW1vc3QgPHZhcj5uPC92YXI+IGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSBuICB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwb3Aobikge1xyXG4gICAgICAgICAgICBpZiAobiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZSh0aGlzLl9zdGFja1NpemUgLSBuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHVzaGVzIGEgdmFsdWUgb250byB0aGUgc3RhY2sgaW4gcHJlcGFyYXRpb24gZm9yIGNhbGxpbmcgYVxyXG4gICAgICAgICAqIGZ1bmN0aW9uIChvciByZXR1cm5pbmcgZnJvbSBvbmUpLiAgU2VlIHtAbGluayAjY2FsbH0gZm9yXHJcbiAgICAgICAgICogdGhlIHByb3RvY29sIHRvIGJlIHVzZWQgZm9yIGNhbGxpbmcgZnVuY3Rpb25zLiAgU2VlIHtAbGlua1xyXG4gICAgICAgICAqICNwdXNoTnVtYmVyfSBmb3IgcHVzaGluZyBudW1iZXJzLCBhbmQge0BsaW5rICNwdXNoVmFsdWV9IGZvclxyXG4gICAgICAgICAqIHB1c2hpbmcgYSB2YWx1ZSB0aGF0IGlzIGFscmVhZHkgb24gdGhlIHN0YWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgTHVhIHZhbHVlIHRvIHB1c2guXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVzaE9iamVjdChvKSB7XHJcbiAgICAgICAgICAgIC8vIHNlZSBhbHNvIGEgcHJpdmF0ZSBvdmVybG9hZGVkIHZlcnNpb24gb2YgdGhpcyBmb3IgU2xvdC5cclxuICAgICAgICAgICAgdGhpcy5zdGFja0FkZChvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHVzaCBib29sZWFuIG9udG8gdGhlIHN0YWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSBiICB0aGUgYm9vbGVhbiB0byBwdXNoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1c2hCb29sZWFuKGIpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoT2JqZWN0KEx1YS52YWx1ZU9mQm9vbGVhbihiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFB1c2ggbGl0ZXJhbCBzdHJpbmcgb250byB0aGUgc3RhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHMgIHRoZSBzdHJpbmcgdG8gcHVzaC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXNoTGl0ZXJhbChzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFB1c2ggbmlsIG9udG8gdGhlIHN0YWNrLiAqL1xyXG4gICAgICAgIHB1c2hOaWwoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChMdWEuTklMKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBQdXNoZXMgYSBudW1iZXIgb250byB0aGUgc3RhY2suICBTZWUgYWxzbyB7QGxpbmsgI3B1c2h9LlxyXG4gICAgICAgICogQHBhcmFtIGQgIHRoZSBudW1iZXIgdG8gcHVzaC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHB1c2hOdW1iZXIoZCkge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogb3B0aW1pc2UgdG8gYXZvaWQgY3JlYXRpbmcgRG91YmxlIGluc3RhbmNlXHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChuZXcgTnVtYmVyKGQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHVzaCBzdHJpbmcgb250byB0aGUgc3RhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHMgIHRoZSBzdHJpbmcgdG8gcHVzaC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXNoU3RyaW5nKHMpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoT2JqZWN0KHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3BpZXMgYSBzdGFjayBlbGVtZW50IG9udG8gdGhlIHRvcCBvZiB0aGUgc3RhY2suXHJcbiAgICAgICAgICogRXF1aXZhbGVudCB0byA8Y29kZT5MLnB1c2goTC52YWx1ZShpZHgpKTwvY29kZT4uXHJcbiAgICAgICAgICogQHBhcmFtIGlkeCAgc3RhY2sgaW5kZXggb2YgdmFsdWUgdG8gcHVzaC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXNoVmFsdWUoaWR4KSB7XHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBvcHRpbWlzZWQgdG8gYXZvaWQgY3JlYXRpbmcgRG91YmxlIGluc3RhbmNlXHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdCh0aGlzLnZhbHVlKGlkeCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVxdWFsaXR5IHdpdGhvdXQgbWV0YW1ldGhvZHMuXHJcbiAgICAgICAgICogQHBhcmFtIG8xICB0aGUgZmlyc3QgTHVhIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgICAgICogQHBhcmFtIG8yICB0aGUgb3RoZXIgTHVhIHZhbHVlLlxyXG4gICAgICAgICAqIEByZXR1cm4gIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhleSBjb21wYXJlIGVxdWFsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyByYXdFcXVhbChvMSwgbzIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEx1YS5vUmF3ZXF1YWwobzEsIG8yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBlbGVtZW50IGZyb20gYSB0YWJsZSwgd2l0aG91dCB1c2luZyBtZXRhbWV0aG9kcy5cclxuICAgICAgICAgKiBAcGFyYW0gdCAgVGhlIHRhYmxlIHRvIGFjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0gayAgVGhlIGluZGV4IChrZXkpIGludG8gdGhlIHRhYmxlLlxyXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIHJhd0dldCh0LCBrKSB7XHJcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRsdWEoayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogR2V0cyBhbiBlbGVtZW50IGZyb20gYW4gYXJyYXksIHdpdGhvdXQgdXNpbmcgbWV0YW1ldGhvZHMuXHJcbiAgICAgICAgKiBAcGFyYW0gdCAgdGhlIGFycmF5ICh0YWJsZSkuXHJcbiAgICAgICAgKiBAcGFyYW0gaSAgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHJpZXZlLlxyXG4gICAgICAgICogQHJldHVybiAgdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgcmF3R2V0SSh0LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRudW0oaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYW4gZWxlbWVudCBpbiBhIHRhYmxlLCB3aXRob3V0IHVzaW5nIG1ldGFtZXRob2RzLlxyXG4gICAgICAgICAqIEBwYXJhbSB0ICBUaGUgdGFibGUgdG8gbW9kaWZ5LlxyXG4gICAgICAgICAqIEBwYXJhbSBrICBUaGUgaW5kZXggaW50byB0aGUgdGFibGUuXHJcbiAgICAgICAgICogQHBhcmFtIHYgIFRoZSBuZXcgdmFsdWUgdG8gYmUgc3RvcmVkIGF0IGluZGV4IDx2YXI+azwvdmFyPi5cclxuICAgICAgICAgKi9cclxuICAgICAgICByYXdTZXQodCwgaywgdikge1xyXG4gICAgICAgICAgICB2YXIgdGFibGUgPSB0O1xyXG4gICAgICAgICAgICB0YWJsZS5wdXRsdWFPYmoodGhpcywgaywgdik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogU2V0cyBhbiBlbGVtZW50IGluIGFuIGFycmF5LCB3aXRob3V0IHVzaW5nIG1ldGFtZXRob2RzLlxyXG4gICAgICAgICogQHBhcmFtIHQgIHRoZSBhcnJheSAodGFibGUpLlxyXG4gICAgICAgICogQHBhcmFtIGkgIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBzZXQuXHJcbiAgICAgICAgKiBAcGFyYW0gdiAgdGhlIG5ldyB2YWx1ZSB0byBiZSBzdG9yZWQgYXQgaW5kZXggPHZhcj5pPC92YXI+LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgcmF3U2V0SSh0LCBpLCB2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBpQ2hlY2sodCBpbnN0YW5jZW9mIEx1YVRhYmxlXzEuTHVhVGFibGUpO1xyXG4gICAgICAgICAgICB2YXIgaCA9IHQ7XHJcbiAgICAgICAgICAgIGgucHV0bnVtKGksIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlciBhIHtAbGluayBMdWFKYXZhQ2FsbGJhY2t9IGFzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGdsb2JhbFxyXG4gICAgICAgICAqIDx2YXI+bmFtZTwvdmFyPi5cclxuICAgICAgICAgKiBAcGFyYW0gbmFtZSAgdGhlIG5hbWUgb2YgdGhlIGdsb2JhbC5cclxuICAgICAgICAgKiBAcGFyYW0gZiAgICAgdGhlIEx1YUphdmFDYWxsYmFjayB0byByZWdpc3Rlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWdpc3RlcihuYW1lLCBmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0R2xvYmFsKG5hbWUsIGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGFydHMgYW5kIHJlc3VtZXMgYSBMdWEgdGhyZWFkLiAgVGhyZWFkcyBjYW4gYmUgY3JlYXRlZCB1c2luZ1xyXG4gICAgICAgICAqIHtAbGluayAjbmV3VGhyZWFkfS4gIE9uY2UgYSB0aHJlYWQgaGFzIGJlZ3VuIGV4ZWN1dGluZyBpdCB3aWxsXHJcbiAgICAgICAgICogcnVuIHVudGlsIGl0IGVpdGhlciBjb21wbGV0ZXMgKHdpdGggZXJyb3Igb3Igbm9ybWFsbHkpIG9yIGhhcyBiZWVuXHJcbiAgICAgICAgICogc3VzcGVuZGVkIGJ5IGludm9raW5nIHtAbGluayAjeWllbGR9LlxyXG4gICAgICAgICAqIEBwYXJhbSBuYXJnICBOdW1iZXIgb2YgdmFsdWVzIHRvIHBhc3MgdG8gdGhyZWFkLlxyXG4gICAgICAgICAqIEByZXR1cm4gTHVhLllJRUxELCAwLCBvciBhbiBlcnJvciBjb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc3VtZShuYXJnKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPSBMdWEuWUlFTEQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VtZV9lcnJvcihcImNhbm5vdCByZXN1bWUgZGVhZCBjb3JvdXRpbmVcIik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jaXYuc2l6ZSAhPSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VtZV9lcnJvcihcImNhbm5vdCByZXN1bWUgbm9uLXN1c3BlbmRlZCBjb3JvdXRpbmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXNzZXJ0IGVycmZ1bmMgPT0gMCAmJiBuQ2NhbGxzID09IDA7XHJcbiAgICAgICAgICAgIHZhciBlcnJvclN0YXR1cyA9IDA7XHJcbiAgICAgICAgICAgIHByb3RlY3Q6IHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGlzIGVxdWl2YWxlbnQgdG8gcmVzdW1lIGZyb20gbGRvLmNcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEFyZyA9IHRoaXMuX3N0YWNrU2l6ZSAtIG5hcmc7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gMCkgLy8gc3RhcnQgY29yb3V0aW5lP1xyXG4gICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnQgY2l2LnNpemUoKSA9PSAxICYmIGZpcnN0QXJnID4gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudm1QcmVjYWxsKGZpcnN0QXJnIC0gMSwgTHVhLk1VTFRSRVQpICE9IEx1YS5QQ1JMVUEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHByb3RlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIC8vIHJlc3VtaW5nIGZyb20gcHJldmlvdXMgeWllbGRcclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHN0YXR1cyA9PSBZSUVMRDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTHVhKHRoaXMuX19jaSgpKSkgLy8gJ2NvbW1vbicgeWllbGRcclxuICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggaW50ZXJydXB0ZWQgZXhlY3V0aW9uIG9mICdPUF9DQUxMJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnQgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZtUG9zY2FsbChmaXJzdEFyZykpIC8vIGNvbXBsZXRlIGl0Li4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZSh0aGlzLl9fY2koKS50b3ApOyAvLyBhbmQgY29ycmVjdCB0b3BcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyB5aWVsZGVkIGluc2lkZSBhIGhvb2s6IGp1c3QgY29udGludWUgaXRzIGV4ZWN1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYXNlID0gdGhpcy5fX2NpKCkuYmFzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudm1FeGVjdXRlKHRoaXMuX2Npdi5zaXplIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTHVhRXJyb3JfMS5MdWFFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gZS5lcnJvclN0YXR1czsgLy8gbWFyayB0aHJlYWQgYXMgJ2RlYWQnXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kU2V0ZXJyb3JvYmooZS5lcnJvclN0YXR1cywgdGhpcy5fc3RhY2tTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY2koKS50b3AgPSB0aGlzLl9zdGFja1NpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFNldCB0aGUgZW52aXJvbm1lbnQgZm9yIGEgZnVuY3Rpb24sIHRocmVhZCwgb3IgdXNlcmRhdGEuXHJcbiAgICAgICAgKiBAcGFyYW0gbyAgICAgIE9iamVjdCB3aG9zZSBlbnZpcm9ubWVudCB3aWxsIGJlIHNldC5cclxuICAgICAgICAqIEBwYXJhbSB0YWJsZSAgRW52aXJvbm1lbnQgdGFibGUgdG8gdXNlLlxyXG4gICAgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgaGFkIGl0cyBlbnZpcm9ubWVudCBzZXQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHNldEZlbnYobywgdGFibGUpIHtcclxuICAgICAgICAgICAgLy8gOnRvZG86IGNvbnNpZGVyIGltcGxlbWVudGluZyBjb21tb24gZW52IGludGVyZmFjZSBmb3JcclxuICAgICAgICAgICAgLy8gTHVhRnVuY3Rpb24sIEx1YUphdmFDYWxsYmFjaywgTHVhVXNlcmRhdGEsIEx1YS4gIE9uZSBjYXN0IHRvIGFuXHJcbiAgICAgICAgICAgIC8vIGludGVyZmFjZSBhbmQgYW4gaW50ZXJmYWNlIG1ldGhvZCBjYWxsIG1heSBiZSBzaG9ydGVyXHJcbiAgICAgICAgICAgIC8vIHRoYW4gdGhpcyBtZXNzLlxyXG4gICAgICAgICAgICB2YXIgdCA9IHRhYmxlO1xyXG4gICAgICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEx1YUZ1bmN0aW9uXzEuTHVhRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmMSA9IG87XHJcbiAgICAgICAgICAgICAgICBmMS5lbnYgPSB0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBMdWFKYXZhQ2FsbGJhY2tfMS5MdWFKYXZhQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciBmMiA9IG87XHJcbiAgICAgICAgICAgICAgICAvLyA6dG9kbzogaW1wbGVtZW50IHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEx1YVVzZXJkYXRhXzEuTHVhVXNlcmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1ID0gbztcclxuICAgICAgICAgICAgICAgIHUuZW52ID0gdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvIGluc3RhbmNlb2YgTHVhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IG87XHJcbiAgICAgICAgICAgICAgICBsLmdsb2JhbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBhIGZpZWxkIGluIGEgTHVhIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB0ICAgICBMdWEgdmFsdWUgb2Ygd2hpY2ggdG8gc2V0IGEgZmllbGQuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgIE5hbWUgb2YgZmllbGQgdG8gc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB2ICAgICBuZXcgTHVhIHZhbHVlIGZvciBmaWVsZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRGaWVsZCh0LCBuYW1lLCB2KSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgIHMuaW5pdDIobmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMudm1TZXR0YWJsZSh0LCBzLCB2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBTZXRzIHRoZSBtZXRhdGFibGUgZm9yIGEgTHVhIHZhbHVlLlxyXG4gICAgICAgICogQHBhcmFtIG8gICBMdWEgdmFsdWUgb2Ygd2hpY2ggdG8gc2V0IG1ldGF0YWJsZS5cclxuICAgICAgICAqIEBwYXJhbSBtdCAgVGhlIG5ldyBtZXRhdGFibGUuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBzZXRNZXRhdGFibGUobywgbXQpIHtcclxuICAgICAgICAgICAgaWYgKEx1YS5pc05pbChtdCkpIHtcclxuICAgICAgICAgICAgICAgIG10ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBpQ2hlY2sobXQgaW5zdGFuY2VvZiBMdWFUYWJsZV8xLkx1YVRhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbXR0ID0gbXQ7XHJcbiAgICAgICAgICAgIGlmIChvIGluc3RhbmNlb2YgTHVhVGFibGVfMS5MdWFUYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBvO1xyXG4gICAgICAgICAgICAgICAgdC5zZXRNZXRhdGFibGUobXR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvIGluc3RhbmNlb2YgTHVhVXNlcmRhdGFfMS5MdWFVc2VyZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSBvO1xyXG4gICAgICAgICAgICAgICAgdS5tZXRhdGFibGUgPSBtdHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhdGFibGVbTHVhLl9fX190eXBlKG8pXSA9IG10dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgYSBnbG9iYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgICBuYW1lIG9mIHRoZSBnbG9iYWwgdmFyaWFibGUgdG8gc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgZGVzaXJlZCBuZXcgdmFsdWUgZm9yIHRoZSB2YXJpYWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRHbG9iYWwobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBuZXcgU2xvdF8xLlNsb3QoKTtcclxuICAgICAgICAgICAgcy5pbml0MihuYW1lKTtcclxuICAgICAgICAgICAgdGhpcy52bVNldHRhYmxlKHRoaXMuX2dsb2JhbCwgcywgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEb2VzIHRoZSBlcXVpdmFsZW50IG9mIDxjb2RlPnRba10gPSB2PC9jb2RlPi5cclxuICAgICAgICAgKiBAcGFyYW0gdCAgdGhlIHRhYmxlIHRvIG1vZGlmeS5cclxuICAgICAgICAgKiBAcGFyYW0gayAgdGhlIGluZGV4IHRvIG1vZGlmeS5cclxuICAgICAgICAgKiBAcGFyYW0gdiAgdGhlIG5ldyB2YWx1ZSBhdCBpbmRleCA8dmFyPms8L3Zhcj4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0VGFibGUodCwgaywgdikge1xyXG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBTbG90XzEuU2xvdCgpO1xyXG4gICAgICAgICAgICBzLmluaXQyKGspO1xyXG4gICAgICAgICAgICB0aGlzLnZtU2V0dGFibGUodCwgcywgdik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogU2V0IHRoZSBzdGFjayB0b3AuXHJcbiAgICAgICAgKiBAcGFyYW0gbiAgdGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgc3RhY2sgKGluIGVsZW1lbnRzKS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHNldFRvcChuKSB7XHJcbiAgICAgICAgICAgIGlmIChuIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLklsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tzZXRzaXplKHRoaXMuX2Jhc2UgKyBuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhdHVzIG9mIGEgTHVhIHRocmVhZC5cclxuICAgICAgICAgKiBAcmV0dXJuIDAsIGFuIGVycm9yIGNvZGUsIG9yIEx1YS5ZSUVMRC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgc3RhdHVzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgc3RhdHVzKHN0YXR1cykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4ge0BsaW5rIGphdmEudXRpbC5FbnVtZXJhdGlvbn0gZm9yIHRoZSBrZXlzIG9mIGEgdGFibGUuXHJcbiAgICAgICAgICogQHBhcmFtIHQgIGEgTHVhIHRhYmxlLlxyXG4gICAgICAgICAqIEByZXR1cm4gYW4gRW51bWVyYXRpb24gb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRhYmxlS2V5cyh0KSB7XHJcbiAgICAgICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBMdWFUYWJsZV8xLkx1YVRhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcInRhYmxlIHJlcXVpcmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9UUkVBQ0hFRFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0LmtleXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydCB0byBib29sZWFuLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICBMdWEgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAgICAgKiBAcmV0dXJuICB0aGUgcmVzdWx0aW5nIHByaW1pdGl2ZSBib29sZWFuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvQm9vbGVhbihvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKG8gPT0gTHVhLk5JTCB8fCBvID09IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydCB0byBpbnRlZ2VyIGFuZCByZXR1cm4gaXQuICBSZXR1cm5zIDAgaWYgY2Fubm90IGJlXHJcbiAgICAgICAgICogY29udmVydGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICBMdWEgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAgICAgKiBAcmV0dXJuICB0aGUgcmVzdWx0aW5nIGludC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0b0ludGVnZXIobykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b051bWJlcihvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydCB0byBudW1iZXIgYW5kIHJldHVybiBpdC4gIFJldHVybnMgMCBpZiBjYW5ub3QgYmVcclxuICAgICAgICAgKiBjb252ZXJ0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIG8gIEx1YSB2YWx1ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqIEByZXR1cm4gIFRoZSByZXN1bHRpbmcgbnVtYmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvTnVtYmVyKG8pIHtcclxuICAgICAgICAgICAgTHVhLlNQQVJFX1NMT1Quc2V0T2JqZWN0KG8pO1xyXG4gICAgICAgICAgICBpZiAoTHVhLnRvbnVtYmVyKEx1YS5TUEFSRV9TTE9ULCBMdWEuTlVNT1ApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTHVhLk5VTU9QWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0IHRvIHN0cmluZyBhbmQgcmV0dXJuIGl0LiAgSWYgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0aGVuXHJcbiAgICAgICAgICogPGNvZGU+bnVsbDwvY29kZT4gaXMgcmV0dXJuZWQuICBOb3RlIHRoYXQgdW5saWtlXHJcbiAgICAgICAgICogPGNvZGU+bHVhX3Rvc3RyaW5nPC9jb2RlPiB0aGlzXHJcbiAgICAgICAgICogZG9lcyBub3QgbW9kaWZ5IHRoZSBMdWEgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIG8gIEx1YSB2YWx1ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqIEByZXR1cm4gIFRoZSByZXN1bHRpbmcgc3RyaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvU3RyaW5nXyhvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMdWEudm1Ub3N0cmluZyhvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydCB0byBMdWEgdGhyZWFkIGFuZCByZXR1cm4gaXQgb3IgPGNvZGU+bnVsbDwvY29kZT4uXHJcbiAgICAgICAgICogQHBhcmFtIG8gIEx1YSB2YWx1ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqIEByZXR1cm4gIFRoZSByZXN1bHRpbmcgTHVhIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvVGhyZWFkKG8pIHtcclxuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEx1YSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0IHRvIHVzZXJkYXRhIG9yIDxjb2RlPm51bGw8L2NvZGU+LiAgSWYgdmFsdWUgaXMgYSB7QGxpbmtcclxuICAgICAgICAgKiBMdWFVc2VyZGF0YX0gdGhlbiBpdCBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlLCA8Y29kZT5udWxsPC9jb2RlPiBpc1xyXG4gICAgICAgICAqIHJldHVybmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICBMdWEgdmFsdWUuXHJcbiAgICAgICAgICogQHJldHVybiAgdmFsdWUgYXMgdXNlcmRhdGEgb3IgPGNvZGU+bnVsbDwvY29kZT4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9Vc2VyZGF0YShvKSB7XHJcbiAgICAgICAgICAgIGlmIChvIGluc3RhbmNlb2YgTHVhVXNlcmRhdGFfMS5MdWFVc2VyZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFR5cGUgb2YgdGhlIEx1YSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHN0YWNrIGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSBpZHggIHN0YWNrIGluZGV4IHRvIHR5cGUuXHJcbiAgICAgICAgICogQHJldHVybiAgdGhlIHR5cGUsIG9yIHtAbGluayAjVE5PTkV9IGlmIHRoZXJlIGlzIG5vIHZhbHVlIGF0IDx2YXI+aWR4PC92YXI+XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHlwZShpZHgpIHtcclxuICAgICAgICAgICAgaWR4ID0gdGhpcy5hYnNJbmRleChpZHgpO1xyXG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5UTk9ORTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX190eXBlKHRoaXMuX3N0YWNrW2lkeF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDlup/lvIPvvIzlubblhaV0eXBlXHJcbiAgICAgICAgICogQHBhcmFtXHRzXHJcbiAgICAgICAgICogQHJldHVyblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fX3R5cGUocykge1xyXG4gICAgICAgICAgICBpZiAocy5yID09IEx1YS5OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMdWEuVE5VTUJFUjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTHVhLl9fX190eXBlKHMucik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFR5cGUgb2YgYSBMdWEgdmFsdWUuXHJcbiAgICAgICAgICog5bqf5byD77yM5bm25YWldHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgTHVhIHZhbHVlIHdob3NlIHR5cGUgdG8gcmV0dXJuLlxyXG4gICAgICAgICAqIEByZXR1cm4gIHRoZSBMdWEgdHlwZSBmcm9tIGFuIGVudW1lcmF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBfX19fdHlwZShvKSB7XHJcbiAgICAgICAgICAgIGlmIChvID09IEx1YS5OSUwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMdWEuVE5JTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvIGluc3RhbmNlb2YgTnVtYmVyIHx8ICh0eXBlb2YgKG8pID09ICdzdHJpbmcnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5UTlVNQkVSO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBCb29sZWFuIHx8ICh0eXBlb2YgKG8pID09ICdib29sZWFuJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMdWEuVEJPT0xFQU47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIFN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5UU1RSSU5HO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBMdWFUYWJsZV8xLkx1YVRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTHVhLlRUQUJMRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvIGluc3RhbmNlb2YgTHVhRnVuY3Rpb25fMS5MdWFGdW5jdGlvbiB8fCBvIGluc3RhbmNlb2YgTHVhSmF2YUNhbGxiYWNrXzEuTHVhSmF2YUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTHVhLlRGVU5DVElPTjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvIGluc3RhbmNlb2YgTHVhVXNlcmRhdGFfMS5MdWFVc2VyZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5UVVNFUkRBVEE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIEx1YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5UVEhSRUFEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBMdWEuVE5PTkU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5hbWUgb2YgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0gdHlwZSAgYSBMdWEgdHlwZSBmcm9tLCBmb3IgZXhhbXBsZSwge0BsaW5rICN0eXBlfS5cclxuICAgICAgICAgKiBAcmV0dXJuICB0aGUgdHlwZSdzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIHR5cGVOYW1lKHR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKEx1YS5UTk9ORSA9PSB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJubyB2YWx1ZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBMdWEuVFlQRU5BTUVbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cclxuICAgICAgICAgKiBJZiA8dmFyPmlkeDwvdmFyPiBpcyBwb3NpdGl2ZSBhbmQgZXhjZWVkc1xyXG4gICAgICAgICAqIHRoZSBzaXplIG9mIHRoZSBzdGFjaywge0BsaW5rICNOSUx9IGlzIHJldHVybmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBpZHggIHRoZSBzdGFjayBpbmRleCBvZiB0aGUgdmFsdWUgdG8gcmV0cmlldmUuXHJcbiAgICAgICAgICogQHJldHVybiAgdGhlIEx1YSB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YWx1ZShpZHgpIHtcclxuICAgICAgICAgICAgaWR4ID0gdGhpcy5hYnNJbmRleChpZHgpO1xyXG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5OSUw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrW2lkeF0uYXNPYmplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBDb252ZXJ0cyBwcmltaXRpdmUgYm9vbGVhbiBpbnRvIGEgTHVhIHZhbHVlLlxyXG4gICAgICAgICogQHBhcmFtIGIgIHRoZSBib29sZWFuIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgKiBAcmV0dXJuICB0aGUgcmVzdWx0aW5nIEx1YSB2YWx1ZS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyB2YWx1ZU9mQm9vbGVhbihiKSB7XHJcbiAgICAgICAgICAgIC8vIElmIENMREMgMS4xIGhhZFxyXG4gICAgICAgICAgICAvLyA8Y29kZT5qYXZhLmxhbmcuQm9vbGVhbi52YWx1ZU9mKGJvb2xlYW4pOzwvY29kZT4gdGhlbiBJIHByb2JhYmx5XHJcbiAgICAgICAgICAgIC8vIHdvdWxkbid0IGhhdmUgd3JpdHRlbiB0aGlzLiAgVGhpcyBkb2VzIGhhdmUgYSBzbWFsbCBhZHZhbnRhZ2U6XHJcbiAgICAgICAgICAgIC8vIGNvZGUgdGhhdCB1c2VzIHRoaXMgbWV0aG9kIGRvZXMgbm90IG5lZWQgdG8gYXNzdW1lIHRoYXQgTHVhIGJvb2xlYW5zIGluXHJcbiAgICAgICAgICAgIC8vIEppbGwgYXJlIHJlcHJlc2VudGVkIHVzaW5nIEphdmEubGFuZy5Cb29sZWFuLlxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgcHJpbWl0aXZlIG51bWJlciBpbnRvIGEgTHVhIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSBkICB0aGUgbnVtYmVyIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICogQHJldHVybiAgdGhlIHJlc3VsdGluZyBMdWEgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIHZhbHVlT2ZOdW1iZXIoZCkge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogY29uc2lkZXIgaW50ZXJuaW5nIFwiY29tbW9uXCIgbnVtYmVycywgbGlrZSAwLCAxLCAtMSwgZXRjLlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlcihkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBFeGNoYW5nZSB2YWx1ZXMgYmV0d2VlbiBkaWZmZXJlbnQgdGhyZWFkcy5cclxuICAgICAgICAqIEBwYXJhbSB0byAgZGVzdGluYXRpb24gTHVhIHRocmVhZC5cclxuICAgICAgICAqIEBwYXJhbSBuICAgbnVtYmVycyBvZiBzdGFjayBpdGVtcyB0byBtb3ZlLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgeG1vdmUodG8sIG4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMgPT0gdG8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFwaUNoZWNrbmVsZW1zKG4pO1xyXG4gICAgICAgICAgICAvLyBMLmFwaUNoZWNrKGZyb20uRygpID09IHRvLkcoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB0by5wdXNoT2JqZWN0KHRoaXMudmFsdWUoLW4gKyBpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wb3Aobik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFlpZWxkcyBhIHRocmVhZC4gIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBhcyB0aGUgcmV0dXJuIGV4cHJlc3Npb25cclxuICAgICAgICAgKiBvZiBhIEx1YSBKYXZhIGZ1bmN0aW9uOiA8Y29kZT5yZXR1cm4gTC55aWVsZChucmVzdWx0cyk7PC9jb2RlPi5cclxuICAgICAgICAgKiBBIHtAbGluayBSdW50aW1lRXhjZXB0aW9ufSBjYW4gYWxzbyBiZSB0aHJvd24gdG8geWllbGQuICBJZiB0aGVcclxuICAgICAgICAgKiBKYXZhIGNvZGUgdGhhdCBpcyBleGVjdXRpbmcgdGhyb3dzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xyXG4gICAgICAgICAqIFJ1bnRpbWVFeGNlcHRpb259IChkaXJlY3Qgb3IgaW5kaXJlY3QpIHRoZW4gdGhpcyBjYXVzZXMgdGhlIEx1YVxyXG4gICAgICAgICAqIHRocmVhZCB0byBiZSBzdXNwZW5kZWQsIGFzIGlmIDxjb2RlPkwueWllbGQoMCk7PC9jb2RlPiBoYWQgYmVlblxyXG4gICAgICAgICAqIGV4ZWN1dGVkLCBhbmQgdGhlIGV4Y2VwdGlvbiBpcyByZS10aHJvd24gdG8gdGhlIGNvZGUgdGhhdCBpbnZva2VkXHJcbiAgICAgICAgICoge0BsaW5rICNyZXN1bWV9LlxyXG4gICAgICAgICAqIEBwYXJhbSBucmVzdWx0cyAgTnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuIHRvIHtAbGluayAjcmVzdW1lfS5cclxuICAgICAgICAgKiBAcmV0dXJuICBhIHNlY3JldCB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB5aWVsZChucmVzdWx0cykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbkNjYWxscyA+IDApXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdSdW5lcnJvcihcImF0dGVtcHQgdG8geWllbGQgYWNyb3NzIG1ldGFtZXRob2QvSmF2YS1jYWxsIGJvdW5kYXJ5XCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlID0gdGhpcy5fc3RhY2tTaXplIC0gbnJlc3VsdHM7IC8vIHByb3RlY3Qgc3RhY2sgc2xvdHMgYmVsb3dcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBMdWEuWUlFTEQ7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWlzY2VsbGFuZW91cyBwcml2YXRlIGZ1bmN0aW9ucy5cclxuICAgICAgICAvKiogQ29udmVydCBmcm9tIEphdmEgQVBJIHN0YWNrIGluZGV4IHRvIGFic29sdXRlIGluZGV4LlxyXG4gICAgICAgICAqIEByZXR1cm4gYW4gaW5kZXggaW50byA8Y29kZT50aGlzLnN0YWNrPC9jb2RlPiBvciAtMSBpZiBvdXQgb2YgcmFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWJzSW5kZXgoaWR4KSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fc3RhY2tTaXplO1xyXG4gICAgICAgICAgICBpZiAoaWR4ID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkeCArIHRoaXMuX2Jhc2UgPiBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2UgKyBpZHggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlkeCA8IDBcclxuICAgICAgICAgICAgaWYgKHMgKyBpZHggPCB0aGlzLl9iYXNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHMgKyBpZHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQXMge0BsaW5rICNhYnNJbmRleH0gYnV0IGRvZXMgbm90IHJldHVybiAtMSBmb3Igb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgKiBpbmRleGVzLiAgRXNzZW50aWFsIGZvciB7QGxpbmsgI2luc2VydH0gYmVjYXVzZSBhbiBpbmRleCBlcXVhbFxyXG4gICAgICAgICogdG8gdGhlIHNpemUgb2YgdGhlIHN0YWNrIGlzIHZhbGlkIGZvciB0aGF0IGNhbGwuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBhYnNJbmRleFVuY2xhbXBlZChpZHgpIHtcclxuICAgICAgICAgICAgaWYgKGlkeCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlkeCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXNlICsgaWR4IC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZHggPCAwXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFja1NpemUgKyBpZHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgICAgICAvLyBBdXhpbGlhcnkgQVBJXHJcbiAgICAgICAgLy8gOnRvZG86IGNvbnNpZGVyIHBsYWNpbmcgaW4gc2VwYXJhdGUgY2xhc3MgKG9yIG1hY3JvaXNlZCkgc28gdGhhdCB3ZVxyXG4gICAgICAgIC8vIGNhbiBjaGFuZ2UgaXRzIGRlZmluaXRpb24gKHRvIHJlbW92ZSB0aGUgY2hlY2sgZm9yIGV4YW1wbGUpLlxyXG4gICAgICAgIGFwaUNoZWNrKGNvbmQpIHtcclxuICAgICAgICAgICAgaWYgKCFjb25kKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXBpQ2hlY2tuZWxlbXMobikge1xyXG4gICAgICAgICAgICB0aGlzLmFwaUNoZWNrKG4gPD0gdGhpcy5fc3RhY2tTaXplIC0gdGhpcy5fYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBhIGdlbmVyYWwgY29uZGl0aW9uIGFuZCByYWlzZXMgZXJyb3IgaWYgZmFsc2UuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmQgICAgICB0aGUgKGV2YWx1YXRlZCkgY29uZGl0aW9uIHRvIGNoZWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSBudW1hcmcgICAgYXJndW1lbnQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIGV4dHJhbXNnICBleHRyYSBlcnJvciBtZXNzYWdlIHRvIGFwcGVuZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhcmdDaGVjayhjb25kLCBudW1hcmcsIGV4dHJhbXNnKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hcmdFcnJvcihudW1hcmcsIGV4dHJhbXNnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmFpc2UgYSBnZW5lcmFsIGVycm9yIGZvciBhbiBhcmd1bWVudC5cclxuICAgICAgICAgKiBAcGFyYW0gbmFyZyAgICAgIGFyZ3VtZW50IGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSBleHRyYW1zZyAgZXh0cmEgbWVzc2FnZSBzdHJpbmcgdG8gYXBwZW5kLlxyXG4gICAgICAgICAqIEByZXR1cm4gbmV2ZXIgKHVzZWQgaWRpb21hdGljYWxseSBpbiA8Y29kZT5yZXR1cm4gYXJnRXJyb3IoLi4uKTwvY29kZT4pXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXJnRXJyb3IobmFyZywgZXh0cmFtc2cpIHtcclxuICAgICAgICAgICAgLy8gOnRvZG86IHVzZSBkZWJ1ZyBBUEkgYXMgcGVyIFBVQy1SaW9cclxuICAgICAgICAgICAgaWYgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiYmFkIGFyZ3VtZW50IFwiICsgbmFyZyArIFwiIChcIiArIGV4dHJhbXNnICsgXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxscyBhIG1ldGFtZXRob2QuICBQdXNoZXMgMSByZXN1bHQgb250byBzdGFjayBpZiBtZXRob2QgY2FsbGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBvYmogICAgc3RhY2sgaW5kZXggb2Ygb2JqZWN0IHdob3NlIG1ldGFtZXRob2QgdG8gY2FsbFxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudCAgbWV0YW1ldGhvZCAoZXZlbnQpIG5hbWUuXHJcbiAgICAgICAgICogQHJldHVybiAgdHJ1ZSBpZiBhbmQgb25seSBpZiBtZXRhbWV0aG9kIHdhcyBmb3VuZCBhbmQgY2FsbGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNhbGxNZXRhKG9iaiwgZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLnZhbHVlKG9iaik7XHJcbiAgICAgICAgICAgIHZhciBldiA9IHRoaXMuZ2V0TWV0YWZpZWxkKG8sIGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKGV2ID09IEx1YS5OSUwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnB1c2hPYmplY3QoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hPYmplY3Qobyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbCgxLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGF0IGFuIGFyZ3VtZW50IGlzIHByZXNlbnQgKGNhbiBiZSBhbnl0aGluZykuXHJcbiAgICAgICAgICogUmFpc2VzIGVycm9yIGlmIG5vdC5cclxuICAgICAgICAgKiBAcGFyYW0gbmFyZyAgYXJndW1lbnQgaW5kZXguXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2hlY2tBbnkobmFyZykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlKG5hcmcpID09IEx1YS5UTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmdFcnJvcihuYXJnLCBcInZhbHVlIGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpcyBhIG51bWJlciBhbmQgcmV0dXJucyBpdCBhcyBhbiBpbnRlZ2VyLiAgUmFpc2VzIGVycm9yIGlmXHJcbiAgICAgICAgICogbm90IGEgbnVtYmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSBuYXJnICBhcmd1bWVudCBpbmRleC5cclxuICAgICAgICAgKiBAcmV0dXJuICB0aGUgYXJndW1lbnQgYXMgYW4gaW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNoZWNrSW50KG5hcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tOdW1iZXIobmFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpcyBhIG51bWJlci4gIFJhaXNlcyBlcnJvciBpZiBub3QgYSBudW1iZXIuXHJcbiAgICAgICAgICogQHBhcmFtIG5hcmcgIGFyZ3VtZW50IGluZGV4LlxyXG4gICAgICAgICAqIEByZXR1cm4gIHRoZSBhcmd1bWVudCBhcyBhIGRvdWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjaGVja051bWJlcihuYXJnKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy52YWx1ZShuYXJnKTtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLnRvTnVtYmVyKG8pO1xyXG4gICAgICAgICAgICBpZiAoZCA9PSAwICYmICFMdWEuaXNOdW1iZXIobykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnRXJyb3IobmFyZywgTHVhLlROVU1CRVIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdGhhdCBhbiBvcHRpb25hbCBzdHJpbmcgYXJndW1lbnQgaXMgYW4gZWxlbWVudCBmcm9tIGEgc2V0IG9mXHJcbiAgICAgICAgICogc3RyaW5ncy4gIFJhaXNlcyBlcnJvciBpZiBub3QuXHJcbiAgICAgICAgICogQHBhcmFtIG5hcmcgIGFyZ3VtZW50IGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSBkZWYgICBkZWZhdWx0IHN0cmluZyB0byB1c2UgaWYgYXJndW1lbnQgbm90IHByZXNlbnQuXHJcbiAgICAgICAgICogQHBhcmFtIGxzdCAgIHRoZSBzZXQgb2Ygc3RyaW5ncyB0byBtYXRjaCBhZ2FpbnN0LlxyXG4gICAgICAgICAqIEByZXR1cm4gYW4gaW5kZXggaW50byA8dmFyPmxzdDwvdmFyPiBzcGVjaWZ5aW5nIHRoZSBtYXRjaGluZyBzdHJpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2hlY2tPcHRpb24obmFyZywgZGVmLCBsc3QgLypTdHJpbmdbXSAqLykge1xyXG4gICAgICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICAgICAgaWYgKGRlZiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5jaGVja1N0cmluZyhuYXJnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLm9wdFN0cmluZyhuYXJnLCBkZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobHN0W2ldID09PSAobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdFcnJvcihuYXJnLCBcImludmFsaWQgb3B0aW9uICdcIiArIG5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBhcmd1bWVudCBpcyBhIHN0cmluZyBhbmQgcmV0dXJucyBpdC4gIFJhaXNlcyBlcnJvciBpZiBub3QgYVxyXG4gICAgICAgICAqIHN0cmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gbmFyZyAgYXJndW1lbnQgaW5kZXguXHJcbiAgICAgICAgICogQHJldHVybiAgdGhlIGFyZ3VtZW50IGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNoZWNrU3RyaW5nKG5hcmcpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnRvU3RyaW5nXyh0aGlzLnZhbHVlKG5hcmcpKTtcclxuICAgICAgICAgICAgaWYgKHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdFcnJvcihuYXJnLCBMdWEuVFNUUklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGUgdHlwZSBvZiBhbiBhcmd1bWVudCwgcmFpc2VzIGVycm9yIGlmIG5vdCBtYXRjaGluZy5cclxuICAgICAgICAgKiBAcGFyYW0gbmFyZyAgYXJndW1lbnQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHQgICAgIHR5cGVjb2RlIChmcm9tIHtAbGluayAjdHlwZX0gZm9yIGV4YW1wbGUpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNoZWNrVHlwZShuYXJnLCB0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUobmFyZykgIT0gdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdFcnJvcihuYXJnLCB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhbmQgcnVucyB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBzICB0aGUgc3RyaW5nIHRvIHJ1bi5cclxuICAgICAgICAgKiBAcmV0dXJuICBhIHN0YXR1cyBjb2RlLCBhcyBwZXIge0BsaW5rICNsb2FkfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkb1N0cmluZyhzKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLl9fbG9hZChMdWEuc3RyaW5nUmVhZGVyKHMpLCBzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB0aGlzLnBjYWxsKDAsIEx1YS5NVUxUUkVULCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlcnJmaWxlKHdoYXQsIGZuYW1lLCBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFN0cmluZyhcImNhbm5vdCBcIiArIHdoYXQgKyBcIiBcIiArIGZuYW1lICsgXCI6IFwiICsgZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIEx1YS5FUlJGSUxFO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcXVpdmFsZW50IHRvIGx1YUxfZmluZHRhYmxlLiAgSW5zdGVhZCBvZiB0aGUgdGFibGUgYmVpbmcgcGFzc2VkIG9uXHJcbiAgICAgICAgICogdGhlIHN0YWNrLCBpdCBpcyBwYXNzZWQgYXMgdGhlIGFyZ3VtZW50IDx2YXI+dDwvdmFyPi5cclxuICAgICAgICAgKiBMaWtlcyBpdHMgUFVDLVJpbyBlcXVpdmFsZW50IGhvd2V2ZXIsIHRoaXMgbWV0aG9kIGxlYXZlcyBhIHRhYmxlIG9uXHJcbiAgICAgICAgICogdGhlIEx1YSBzdGFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmaW5kVGFibGUodCwgZm5hbWUsIHN6aGludCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgZSA9IGZuYW1lLmluZGV4T2YoJy4nLCBpKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IGZuYW1lLnN1YnN0cmluZyhpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBmbmFtZS5zdWJzdHJpbmcoaSwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IEx1YS5yYXdHZXQodCwgcGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhLmlzTmlsKHYpKSAvLyBubyBzdWNoIGZpZWxkP1xyXG4gICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5jcmVhdGVUYWJsZSgwLCAoZSA+PSAwKSA/IDEgOiBzemhpbnQpOyAvLyBuZXcgdGFibGUgZm9yIGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUYWJsZSh0LCBwYXJ0LCB2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFMdWEuaXNUYWJsZSh2KSkgLy8gZmllbGQgaGFzIGEgbm9uLXRhYmxlIHZhbHVlP1xyXG4gICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHQgPSB2O1xyXG4gICAgICAgICAgICAgICAgaSA9IGUgKyAxO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChlID49IDApO1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hPYmplY3QodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYSBmaWVsZCAoZXZlbnQpIGZyb20gYW4gTHVhIHZhbHVlJ3MgbWV0YXRhYmxlLiAgUmV0dXJucyBMdWFcclxuICAgICAgICAgKiA8Y29kZT5uaWw8L2NvZGU+IGlmIHRoZXJlIGlzIGVpdGhlciBubyBtZXRhdGFibGUgb3Igbm8gZmllbGQuXHJcbiAgICAgICAgICogQHBhcmFtIG8gICAgICAgICAgIEx1YSB2YWx1ZSB0byBnZXQgbWV0YWZpZWxkIGZvci5cclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgICAgICAgbmFtZSBvZiBtZXRhZmllbGQgKGV2ZW50KS5cclxuICAgICAgICAgKiBAcmV0dXJuICAgICAgICAgICAgdGhlIGZpZWxkIGZyb20gdGhlIG1ldGF0YWJsZSwgb3IgbmlsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE1ldGFmaWVsZChvLCBldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgbXQgPSB0aGlzLmdldE1ldGF0YWJsZShvKTtcclxuICAgICAgICAgICAgaWYgKG10ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMdWEuTklMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtdC5nZXRsdWEoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc05vbmVPck5pbChuYXJnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUobmFyZykgPD0gTHVhLlROSUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGEgTHVhIGNodW5rIGZyb20gYSBmaWxlLiAgVGhlIDx2YXI+ZmlsZW5hbWU8L3Zhcj4gYXJndW1lbnQgaXNcclxuICAgICAgICAgKiB1c2VkIGluIGEgY2FsbCB0byB7QGxpbmsgQ2xhc3MjZ2V0UmVzb3VyY2VBc1N0cmVhbX0gd2hlcmVcclxuICAgICAgICAgKiA8Y29kZT50aGlzPC9jb2RlPiBpcyB0aGUge0BsaW5rIEx1YX0gaW5zdGFuY2UsIHRodXMgcmVsYXRpdmVcclxuICAgICAgICAgKiBwYXRobmFtZXMgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGUgbG9jYXRpb24gb2YgdGhlXHJcbiAgICAgICAgICogPGNvZGU+THVhLmNsYXNzPC9jb2RlPiBmaWxlLiAgUHVzaGVzIGNvbXBpbGVkIGNodW5rLCBvciBlcnJvclxyXG4gICAgICAgICAqIG1lc3NhZ2UsIG9udG8gc3RhY2suXHJcbiAgICAgICAgICogQHBhcmFtIGZpbGVuYW1lICBsb2NhdGlvbiBvZiBmaWxlLlxyXG4gICAgICAgICAqIEByZXR1cm4gc3RhdHVzIGNvZGUsIGFzIHBlciB7QGxpbmsgI2xvYWR9LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxvYWRGaWxlKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWxlbmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb25fMS5OdWxsUG9pbnRlckV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfaW4gPSBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5nZXRSZXNvdXJjZUFzU3RyZWFtKGZpbGVuYW1lKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICBpZiAoX2luID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycmZpbGUoXCJvcGVuXCIsIGZpbGVuYW1lLCBuZXcgSU9FeGNlcHRpb25fMS5JT0V4Y2VwdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIF9pbi5tYXJrKDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBfaW4ucmVhZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJyMnLmNoYXJDb2RlQXQoMCkpIC8vIFVuaXggZXhlYy4gZmlsZT9cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gOnRvZG86IGhhbmRsZSB0aGlzIGNhc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9pbi5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdGhpcy5sb2FkKF9pbiwgXCJAXCIgKyBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgSU9FeGNlcHRpb25fMS5JT0V4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycmZpbGUoXCJyZWFkXCIsIGZpbGVuYW1lLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIEx1YSBjaHVuayBmcm9tIGEgc3RyaW5nLiAgUHVzaGVzIGNvbXBpbGVkIGNodW5rLCBvciBlcnJvclxyXG4gICAgICAgICAqIG1lc3NhZ2UsIG9udG8gc3RhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHMgICAgICAgICAgIHRoZSBzdHJpbmcgdG8gbG9hZC5cclxuICAgICAgICAgKiBAcGFyYW0gY2h1bmtuYW1lICAgdGhlIG5hbWUgb2YgdGhlIGNodW5rLlxyXG4gICAgICAgICAqIEByZXR1cm4gc3RhdHVzIGNvZGUsIGFzIHBlciB7QGxpbmsgI2xvYWR9LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxvYWRTdHJpbmcocywgY2h1bmtuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbG9hZChMdWEuc3RyaW5nUmVhZGVyKHMpLCBjaHVua25hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgb3B0aW9uYWwgaW50ZWdlciBhcmd1bWVudC4gIFJhaXNlcyBlcnJvciBpZiBub24tbnVtYmVyXHJcbiAgICAgICAgICogc3VwcGxpZWQuXHJcbiAgICAgICAgICogQHBhcmFtIG5hcmcgIGFyZ3VtZW50IGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSBkZWYgICBkZWZhdWx0IHZhbHVlIGZvciBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEByZXR1cm4gYW4gaW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9wdEludChuYXJnLCBkZWYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOb25lT3JOaWwobmFyZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tJbnQobmFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvcHRpb25hbCBudW1iZXIgYXJndW1lbnQuICBSYWlzZXMgZXJyb3IgaWYgbm9uLW51bWJlciBzdXBwbGllZC5cclxuICAgICAgICAgKiBAcGFyYW0gbmFyZyAgYXJndW1lbnQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIGRlZiAgIGRlZmF1bHQgdmFsdWUgZm9yIG51bWJlci5cclxuICAgICAgICAgKiBAcmV0dXJuIGEgZG91YmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9wdE51bWJlcihuYXJnLCBkZWYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOb25lT3JOaWwobmFyZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tOdW1iZXIobmFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvcHRpb25hbCBzdHJpbmcgYXJndW1lbnQuICBSYWlzZXMgZXJyb3IgaWYgbm9uLXN0cmluZyBzdXBwbGllZC5cclxuICAgICAgICAgKiBAcGFyYW0gbmFyZyAgYXJndW1lbnQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIGRlZiAgIGRlZmF1bHQgdmFsdWUgZm9yIHN0cmluZy5cclxuICAgICAgICAgKiBAcmV0dXJuIGEgc3RyaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9wdFN0cmluZyhuYXJnLCBkZWYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOb25lT3JOaWwobmFyZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTdHJpbmcobmFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSB0YWJsZSBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZSBhbmQgcmVnaXN0ZXJzIGl0IGFzIGEgbG9hZGVkXHJcbiAgICAgICAgICogbW9kdWxlLlxyXG4gICAgICAgICAqIEByZXR1cm4gdGhlIG5ldyB0YWJsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fcmVnaXN0ZXIobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmRUYWJsZSh0aGlzLl9yZWdpc3RyeSwgTHVhLkxPQURFRCwgMSk7XHJcbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLnZhbHVlKC0xKTtcclxuICAgICAgICAgICAgdGhpcy5wb3AoMSk7XHJcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5nZXRGaWVsZChsb2FkZWQsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIUx1YS5pc1RhYmxlKHQpKSAvLyBub3QgZm91bmQ/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB0cnkgZ2xvYmFsIHZhcmlhYmxlIChhbmQgY3JlYXRlIG9uZSBpZiBpdCBkb2VzIG5vdCBleGlzdClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRUYWJsZSh0aGlzLmdldEdsb2JhbHMoKSwgbmFtZSwgMCkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJuYW1lIGNvbmZsaWN0IGZvciBtb2R1bGUgJ1wiICsgbmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHQgPSB0aGlzLnZhbHVlKC0xKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGaWVsZChsb2FkZWQsIG5hbWUsIHQpOyAvLyBfTE9BREVEW25hbWVdID0gbmV3IHRhYmxlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhZ0Vycm9yKG5hcmcsIHRhZykge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVycm9yKG5hcmcsIEx1YS50eXBlTmFtZSh0YWcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTmFtZSBvZiB0eXBlIG9mIHZhbHVlIGF0IDx2YXI+aWR4PC92YXI+LlxyXG4gICAgICAgICAqIEBwYXJhbSBpZHggIHN0YWNrIGluZGV4LlxyXG4gICAgICAgICAqIEByZXR1cm4gIHRoZSBuYW1lIG9mIHRoZSB2YWx1ZSdzIHR5cGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHlwZU5hbWVPZkluZGV4KGlkeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTHVhLlRZUEVOQU1FW3RoaXMudHlwZShpZHgpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjbGFyZSB0eXBlIGVycm9yIGluIGFyZ3VtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSBuYXJnICAgSW5kZXggb2YgYXJndW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHRuYW1lICBOYW1lIG9mIHR5cGUgZXhwZWN0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHlwZXJyb3IobmFyZywgdG5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hcmdFcnJvcihuYXJnLCB0bmFtZSArIFwiIGV4cGVjdGVkLCBnb3QgXCIgKyB0aGlzLnR5cGVOYW1lT2ZJbmRleChuYXJnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBzdHJpbmcgaWRlbnRpZnlpbmcgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBhdCBsZXZlbFxyXG4gICAgICAgICAqIDx2YXI+bGV2ZWw8L3Zhcj4uXHJcbiAgICAgICAgICogQHBhcmFtIGxldmVsICBzcGVjaWZpZXMgdGhlIGNhbGwtc3RhY2sgbGV2ZWwuXHJcbiAgICAgICAgICogQHJldHVybiBhIGRlc2NyaXB0aW9uIGZvciB0aGF0IGxldmVsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdoZXJlKGxldmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBhciA9IHRoaXMuZ2V0U3RhY2sobGV2ZWwpOyAvLyBjaGVjayBmdW5jdGlvbiBhdCBsZXZlbFxyXG4gICAgICAgICAgICBpZiAoYXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbmZvKFwiU2xcIiwgYXIpOyAvLyBnZXQgaW5mbyBhYm91dCBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKGFyLmN1cnJlbnRsaW5lID4gMCkgLy8gaXMgdGhlcmUgaW5mbz9cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyLnNob3J0c3JjICsgXCI6XCIgKyBhci5jdXJyZW50bGluZSArIFwiOiBcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjsgLy8gZWxzZSwgbm8gaW5mb3JtYXRpb24gYXZhaWxhYmxlLi4uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3ZpZGUge0BsaW5rIGphdmEuaW8uUmVhZGVyfSBpbnRlcmZhY2Ugb3ZlciBhIDxjb2RlPlN0cmluZzwvY29kZT4uXHJcbiAgICAgICAgICogRXF1aXZhbGVudCBvZiB7QGxpbmsgamF2YS5pby5TdHJpbmdSZWFkZXIjU3RyaW5nUmVhZGVyfSBmcm9tIEoyU0UuXHJcbiAgICAgICAgICogVGhlIGFiaWxpdHkgdG8gY29udmVydCBhIDxjb2RlPlN0cmluZzwvY29kZT4gdG8gYVxyXG4gICAgICAgICAqIDxjb2RlPlJlYWRlcjwvY29kZT4gaXMgcmVxdWlyZWQgaW50ZXJuYWxseSxcclxuICAgICAgICAgKiB0byBwcm92aWRlIHRoZSBMdWEgZnVuY3Rpb24gPGNvZGU+bG9hZHN0cmluZzwvY29kZT47IGV4cG9zZWRcclxuICAgICAgICAgKiBleHRlcm5hbGx5IGFzIGEgY29udmVuaWVuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHMgIHRoZSBzdHJpbmcgZnJvbSB3aGljaCB0byByZWFkLlxyXG4gICAgICAgICAqIEByZXR1cm4gYSB7QGxpbmsgamF2YS5pby5SZWFkZXJ9IHRoYXQgcmVhZHMgc3VjY2Vzc2l2ZSBjaGFycyBmcm9tIDx2YXI+czwvdmFyPi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgc3RyaW5nUmVhZGVyKHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdSZWFkZXJfMS5TdHJpbmdSZWFkZXIocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgICAgICAvLyBEZWJ1Z1xyXG4gICAgICAgIC8vIE1ldGhvZHMgZXF1aXZhbGVudCB0byBkZWJ1ZyBBUEkuICBJbiBQVUMtUmlvIG1vc3Qgb2YgdGhlc2UgYXJlIGluXHJcbiAgICAgICAgLy8gbGRlYnVnLmNcclxuICAgICAgICBnZXRJbmZvKHdoYXQsIGFyKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGNhbGxpbmZvID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gOnRvZG86IGNvbXBsZXRlIG1lXHJcbiAgICAgICAgICAgIGlmIChhci5pY2kgPiAwKSAvLyBubyB0YWlsIGNhbGw/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYWxsaW5mbyA9IHRoaXMuX2Npdi5lbGVtZW50QXQoYXIuaWNpKTtcclxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGFja1tjYWxsaW5mby5mdW5jXS5yO1xyXG4gICAgICAgICAgICAgICAgLy8jIGFzc2VydCBpc0Z1bmN0aW9uKGYpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuYXV4Z2V0aW5mbyh3aGF0LCBhciwgZiwgY2FsbGluZm8pO1xyXG4gICAgICAgICAgICBpZiAod2hhdC5pbmRleE9mKCdmJykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChMdWEuTklMKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2NhdGVzIGZ1bmN0aW9uIGFjdGl2YXRpb24gYXQgc3BlY2lmaWVkIGNhbGwgbGV2ZWwgYW5kIHJldHVybnMgYVxyXG4gICAgICAgICAqIHtAbGluayBEZWJ1Z31cclxuICAgICAgICAgKiByZWNvcmQgZm9yIGl0LCBvciA8Y29kZT5udWxsPC9jb2RlPiBpZiBsZXZlbCBpcyB0b28gaGlnaC5cclxuICAgICAgICAgKiBNYXkgYmVjb21lIHB1YmxpYy5cclxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwgIHRoZSBjYWxsIGxldmVsLlxyXG4gICAgICAgICAqIEByZXR1cm4gYSB7QGxpbmsgRGVidWd9IGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIGFjdGl2YXRpb24gcmVjb3JkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFN0YWNrKGxldmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBpY2k7IC8vIEluZGV4IG9mIENhbGxJbmZvXHJcbiAgICAgICAgICAgIGZvciAoaWNpID0gdGhpcy5fY2l2LnNpemUgLSAxOyBsZXZlbCA+IDAgJiYgaWNpID4gMDsgLS1pY2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaSA9IHRoaXMuX2Npdi5lbGVtZW50QXQoaWNpKTtcclxuICAgICAgICAgICAgICAgIC0tbGV2ZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0x1YShjaSkpIC8vIEx1YSBmdW5jdGlvbj9cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgLT0gY2kudGFpbGNhbGxzOyAvLyBza2lwIGxvc3QgdGFpbCBjYWxsc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZXZlbCA9PSAwICYmIGljaSA+IDApIC8vIGxldmVsIGZvdW5kP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z18xLkRlYnVnKGljaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGV2ZWwgPCAwKSAvLyBsZXZlbCBpcyBvZiBhIGxvc3QgdGFpbCBjYWxsP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z18xLkRlYnVnKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBkZWJ1ZyBob29rLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldEhvb2soZnVuYywgbWFzaywgY291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGZ1bmMgPT0gbnVsbCB8fCBtYXNrID09IDApIC8vIHR1cm4gb2ZmIGhvb2tzP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWFzayA9IDA7XHJcbiAgICAgICAgICAgICAgICBmdW5jID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ob29rID0gZnVuYztcclxuICAgICAgICAgICAgdGhpcy5fYmFzZWhvb2tjb3VudCA9IGNvdW50O1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0aG9va2NvdW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvb2ttYXNrID0gbWFzaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlzIG9rYXksIGZhbHNlIG90aGVyd2lzZSAoZm9yIGV4YW1wbGUsIGVycm9yKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhdXhnZXRpbmZvKHdoYXQsIGFyLCBmLCBjaSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gOnRvZG86IGltcGxlbWVudCBtZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdoYXQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAod2hhdC5jaGFyQXQoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mdW5jaW5mbyhhciwgZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhci5jdXJyZW50bGluZSA9IChjaSAhPSBudWxsKSA/IHRoaXMuY3VycmVudGxpbmUoY2kpIDogLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOiAvLyBoYW5kbGVkIGJ5IGdldEluZm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gOnRvZG86IG1vcmUgY2FzZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudGxpbmUoY2kpIHtcclxuICAgICAgICAgICAgdmFyIHBjID0gdGhpcy5jdXJyZW50cGMoY2kpO1xyXG4gICAgICAgICAgICBpZiAocGMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7IC8vIG9ubHkgYWN0aXZlIEx1YSBmdW5jdGlvbnMgaGF2ZSBjdXJyZW50LWxpbmUgaW5mb1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhc28gPSB0aGlzLl9zdGFja1tjaS5mdW5jXS5yO1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmYXNvO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGYucHJvdG8uZ2V0bGluZShwYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudHBjKGNpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0x1YShjaSkpIC8vIGZ1bmN0aW9uIGlzIG5vdCBhIEx1YSBmdW5jdGlvbj9cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2kgPT0gdGhpcy5fX2NpKCkpIHtcclxuICAgICAgICAgICAgICAgIGNpLnNhdmVkcGMgPSB0aGlzLl9zYXZlZHBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBMdWEucGNSZWwoY2kuc2F2ZWRwYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmNpbmZvKGFyLCBjbCkge1xyXG4gICAgICAgICAgICBpZiAoY2wgaW5zdGFuY2VvZiBMdWFKYXZhQ2FsbGJhY2tfMS5MdWFKYXZhQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGFyLnNvdXJjZSA9IFwiPVtKYXZhXVwiO1xyXG4gICAgICAgICAgICAgICAgYXIubGluZWRlZmluZWQgPSAtMTtcclxuICAgICAgICAgICAgICAgIGFyLmxhc3RsaW5lZGVmaW5lZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgYXIud2hhdCA9IFwiSmF2YVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjbC5wcm90bztcclxuICAgICAgICAgICAgICAgIGFyLnNvdXJjZSA9IHAuc291cmNlO1xyXG4gICAgICAgICAgICAgICAgYXIubGluZWRlZmluZWQgPSBwLmxpbmVkZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgYXIubGFzdGxpbmVkZWZpbmVkID0gcC5sYXN0bGluZWRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBhci53aGF0ID0gYXIubGluZWRlZmluZWQgPT0gMCA/IFwibWFpblwiIDogXCJMdWFcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byBtYWNybyBpc0x1YSBfYW5kXyBmX2lzTHVhIGZyb20gbHN0YXRlLmguICovXHJcbiAgICAgICAgaXNMdWEoY2FsbGluZm8pIHtcclxuICAgICAgICAgICAgdmFyIGYgPSB0aGlzLl9zdGFja1tjYWxsaW5mby5mdW5jXS5yO1xyXG4gICAgICAgICAgICByZXR1cm4gZiBpbnN0YW5jZW9mIEx1YUZ1bmN0aW9uXzEuTHVhRnVuY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBwY1JlbChwYykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGMgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAgICAgLy8gRG9cclxuICAgICAgICAvLyBNZXRob2RzIGVxdWl2YWxlbnQgdG8gdGhlIGZpbGUgbGRvLmMuICBQcmVmaXhlZCB3aXRoIGQuXHJcbiAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBhcmUgaW4gdm0qIGluc3RlYWQuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBFcXVpdmFsZW50IHRvIGx1YURfY2FsbGhvb2suXHJcbiAgICAgICAgKi9cclxuICAgICAgICBkQ2FsbGhvb2soZXZlbnQsIGxpbmUpIHtcclxuICAgICAgICAgICAgdmFyIGhvb2sgPSB0aGlzLl9ob29rO1xyXG4gICAgICAgICAgICBpZiAoaG9vayAhPSBudWxsICYmIHRoaXMuX2FsbG93aG9vaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuX3N0YWNrU2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBjaV90b3AgPSB0aGlzLl9fY2koKS50b3A7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWNpID0gdGhpcy5fY2l2LnNpemUgLSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ID09IEx1YS5IT09LVEFJTFJFVCkgLy8gbm90IHN1cHBvcnRlZCB5ZXRcclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWNpID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhciA9IG5ldyBEZWJ1Z18xLkRlYnVnKGljaSk7XHJcbiAgICAgICAgICAgICAgICBhci5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgYXIuY3VycmVudGxpbmUgPSBsaW5lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NpKCkudG9wID0gdGhpcy5fc3RhY2tTaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dob29rID0gZmFsc2U7IC8vIGNhbm5vdCBjYWxsIGhvb2tzIGluc2lkZSBhIGhvb2tcclxuICAgICAgICAgICAgICAgIGhvb2subHVhSG9vayh0aGlzLCBhcik7XHJcbiAgICAgICAgICAgICAgICAvLyMgYXNzZXJ0ICFhbGxvd2hvb2tcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbG93aG9vayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2koKS50b3AgPSBjaV90b3A7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZSh0b3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGx1YURfc2V0ZXJyb3JvYmouICBJdCBpcyB2YWxpZCBmb3Igb2xkdG9wIHRvIGJlXHJcbiAgICAgICAgKiBlcXVhbCB0byB0aGUgY3VycmVudCBzdGFjayBzaXplICg8Y29kZT5zdGFja1NpemU8L2NvZGU+KS5cclxuICAgICAgICAqIHtAbGluayAjcmVzdW1lfSB1c2VzIHRoaXMgdmFsdWUgZm9yIG9sZHRvcC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGRTZXRlcnJvcm9iaihlcnJjb2RlLCBvbGR0b3ApIHtcclxuICAgICAgICAgICAgdmFyIG1zZyA9IHRoaXMub2JqZWN0QXQodGhpcy5fc3RhY2tTaXplIC0gMSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFja1NpemUgPT0gb2xkdG9wKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZShvbGR0b3AgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKGVycmNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLkVSUk1FTTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tvbGR0b3BdLnIgPSBMdWEuTUVNRVJSTVNHO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuRVJSRVJSOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW29sZHRvcF0uciA9IFwiZXJyb3IgaW4gZXJyb3IgaGFuZGxpbmdcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLkVSUkZJTEU6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5FUlJSVU46XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5FUlJTWU5UQVg6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPYmplY3RBdChtc2csIG9sZHRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUob2xkdG9wICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRUaHJvdyhzdGF0dXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEx1YUVycm9yXzEuTHVhRXJyb3Ioc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgICAgIC8vIEZ1bmNcclxuICAgICAgICAvLyBNZXRob2RzIGVxdWl2YWxlbnQgdG8gdGhlIGZpbGUgbGZ1bmMuYy4gIFByZWZpeGVkIHdpdGggZi5cclxuICAgICAgICAvKiogRXF1aXZhbGVudCBvZiBsdWFGX2Nsb3NlLiAgQWxsIG9wZW4gdXB2YWx1ZXMgcmVmZXJlbmNpbmcgc3RhY2tcclxuICAgICAgICAgKiBzbG90cyBsZXZlbCBvciBoaWdoZXIgYXJlIGNsb3NlZC5cclxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwgIEFic29sdXRlIHN0YWNrIGluZGV4LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZDbG9zZShsZXZlbCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX29wZW51cHZhbC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHV2ID0gdGhpcy5fb3BlbnVwdmFsW2ldOyAvL0ZJWE1FOnZhciB1djpVcFZhbCA9IHRoaXMuX29wZW51cHZhbC5lbGVtZW50QXQoaSkgYXMgVXBWYWw7XHJcbiAgICAgICAgICAgICAgICBpZiAodXYub2Zmc2V0IDwgbGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHV2LmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb3BlbnVwdmFsLmxlbmd0aCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAvL29wZW51cHZhbC5zZXRTaXplKGkrMSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZkZpbmR1cHZhbChpZHgpIHtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICogV2Ugc2VhcmNoIGZyb20gdGhlIGVuZCBvZiB0aGUgVmVjdG9yIHRvd2FyZHMgdGhlIGJlZ2lubmluZyxcclxuICAgICAgICAgICAgICAgICogbG9va2luZyBmb3IgYW4gVXBWYWwgZm9yIHRoZSByZXF1aXJlZCBzdGFjay1zbG90LlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9vcGVudXB2YWwubGVuZ3RoOyAvL0ZJWE1FOi5zaXplKCk7XHJcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHV2MiA9IHRoaXMuX29wZW51cHZhbFtpXTsgLy9GSVhNRTp2YXIgdXYyOlVwVmFsID0gdGhpcy5fb3BlbnVwdmFsLmVsZW1lbnRBdChpKSBhcyBVcFZhbDtcclxuICAgICAgICAgICAgICAgIGlmICh1djIub2Zmc2V0ID09IGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1djI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXYyLm9mZnNldCA8IGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGkgcG9pbnRzIHRvIGJlIHBvc2l0aW9uIF9hZnRlcl8gd2hpY2ggd2Ugd2FudCB0byBpbnNlcnQgYSBuZXdcclxuICAgICAgICAgICAgLy8gVXBWYWwgKGl0J3MgLTEgd2hlbiB3ZSB3YW50IHRvIGluc2VydCBhdCB0aGUgYmVnaW5uaW5nKS5cclxuICAgICAgICAgICAgdmFyIHV2ID0gbmV3IFVwVmFsXzEuVXBWYWwoaWR4LCB0aGlzLl9zdGFja1tpZHhdKTtcclxuICAgICAgICAgICAgdGhpcy5fb3BlbnVwdmFsLnNwbGljZShpICsgMSwgMCwgdXYpOyAvL0ZJWE1FOnRoaXMuX29wZW51cHZhbC5pbnNlcnRFbGVtZW50QXQodXYsIGkrMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB1djtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgICAgIC8vIERlYnVnXHJcbiAgICAgICAgLy8gTWV0aG9kcyBlcXVpdmFsZW50IHRvIHRoZSBmaWxlIGxkZWJ1Zy5jLiAgUHJlZml4ZWQgd2l0aCBnLlxyXG4gICAgICAgIC8qKiA8dmFyPnAxPC92YXI+IGFuZCA8dmFyPnAyPC92YXI+IGFyZSBvcGVyYW5kcyB0byBhIG51bWVyaWMgb3Bjb2RlLlxyXG4gICAgICAgICAqIENvcnJ1cHRzIDxjb2RlPk5VTU9QWzBdPC9jb2RlPi5cclxuICAgICAgICAgKiBUaGVyZSBpcyB0aGUgcG9zc2liaWxpdHkgb2YgdXNpbmcgPHZhcj5wMTwvdmFyPiBhbmQgPHZhcj5wMjwvdmFyPiB0b1xyXG4gICAgICAgICAqIGlkZW50aWZ5IChmb3IgZXhhbXBsZSkgZm9yIGxvY2FsIHZhcmlhYmxlIGJlaW5nIHVzZWQgaW4gdGhlXHJcbiAgICAgICAgICogY29tcHV0YXRpb24gKGNvbnNpZGVyIHRoZSBlcnJvciBtZXNzYWdlIGZvciBjb2RlIGxpa2UgPGNvZGU+bG9jYWxcclxuICAgICAgICAgKiB5PSdhJzsgcmV0dXJuIHkrMTwvY29kZT4gZm9yIGV4YW1wbGUpLiAgQ3VycmVudGx5IHRoZSBkZWJ1ZyBpbmZvIGlzXHJcbiAgICAgICAgICogbm90IHVzZWQsIGFuZCB0aGlzIG9wcG9ydHVuaXR5IGlzIHdhc3RlZCAoaXQgd291bGQgcmVxdWlyZSBjaGFuZ2luZ1xyXG4gICAgICAgICAqIG9yIG92ZXJsb2FkaW5nIGdUeXBlZXJyb3IpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdBcml0aGVycm9yKHAxLCBwMikge1xyXG4gICAgICAgICAgICBpZiAoIUx1YS50b251bWJlcihwMSwgTHVhLk5VTU9QKSkge1xyXG4gICAgICAgICAgICAgICAgcDIgPSBwMTsgLy8gZmlyc3Qgb3BlcmFuZCBpcyB3cm9uZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ1R5cGVlcnJvcihwMiwgXCJwZXJmb3JtIGFyaXRobWV0aWMgb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiA8dmFyPnAxPC92YXI+IGFuZCA8dmFyPnAyPC92YXI+IGFyZSBhYnNvbHV0ZSBzdGFjayBpbmRleGVzLiAqL1xyXG4gICAgICAgIGdDb25jYXRlcnJvcihwMSwgcDIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YWNrW3AxXS5yIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiAodGhpcy5fc3RhY2tbcDFdLnIpID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBwMSA9IHAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFzc2VydCAhKHAxIGluc3RhbmNlb2YgU3RyaW5nKTtcclxuICAgICAgICAgICAgdGhpcy5nVHlwZWVycm9yKHRoaXMuX3N0YWNrW3AxXSwgXCJjb25jYXRlbmF0ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ0NoZWNrY29kZShwKSB7XHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBpbXBsZW1lbnQgbWUuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnRXJyb3Jtc2cobWVzc2FnZSkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hPYmplY3QobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJmdW5jICE9IG51bGwpIC8vIGlzIHRoZXJlIGFuIGVycm9yIGhhbmRsaW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUx1YS5pc0Z1bmN0aW9uKHRoaXMuX2VycmZ1bmMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kVGhyb3coTHVhLkVSUkVSUik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydCh0aGlzLl9lcnJmdW5jLCB0aGlzLmdldFRvcCgpKTsgLy8gcHVzaCBmdW5jdGlvbiAodW5kZXIgZXJyb3IgYXJnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy52bUNhbGwodGhpcy5fc3RhY2tTaXplIC0gMiwgMSk7IC8vIGNhbGwgaXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRUaHJvdyhMdWEuRVJSUlVOKTtcclxuICAgICAgICAgICAgLy8gTk9UUkVBQ0hFRFxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ09yZGVyZXJyb3IocDEsIHAyKSB7XHJcbiAgICAgICAgICAgIHZhciB0MSA9IEx1YS50eXBlTmFtZSh0aGlzLl9fX3R5cGUocDEpKTtcclxuICAgICAgICAgICAgdmFyIHQyID0gTHVhLnR5cGVOYW1lKHRoaXMuX19fdHlwZShwMikpO1xyXG4gICAgICAgICAgICBpZiAodDEuY2hhckF0KDIpID09IHQyLmNoYXJBdCgyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nUnVuZXJyb3IoXCJhdHRlbXB0IHRvIGNvbXBhcmUgdHdvIFwiICsgdDEgKyBcInZhbHVlc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ1J1bmVycm9yKFwiYXR0ZW1wdCB0byBjb21wYXJlIFwiICsgdDEgKyBcIiB3aXRoIFwiICsgdDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5PVFJFQUNIRURcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnUnVuZXJyb3Iocykge1xyXG4gICAgICAgICAgICB0aGlzLmdFcnJvcm1zZyhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ1R5cGVlcnJvcihvLCBvcCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IEx1YS50eXBlTmFtZShMdWEuX19fX3R5cGUobykpO1xyXG4gICAgICAgICAgICB0aGlzLmdSdW5lcnJvcihcImF0dGVtcHQgdG8gXCIgKyBvcCArIFwiIGEgXCIgKyB0ICsgXCIgdmFsdWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fZ1R5cGVlcnJvcihwLCBvcCkge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogUFVDLVJpbyBzZWFyY2hlcyB0aGUgc3RhY2sgdG8gc2VlIGlmIHRoZSB2YWx1ZSAod2hpY2ggbWF5XHJcbiAgICAgICAgICAgIC8vIGJlIGEgcmVmZXJlbmNlIHRvIHN0YWNrIGNlbGwpIGlzIGEgbG9jYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICAgIC8vIEZvciBub3cgd2UgY29wIG91dCBhbmQganVzdCBjYWxsIGdUeXBlZXJyb3IoT2JqZWN0LCBTdHJpbmcpXHJcbiAgICAgICAgICAgIHRoaXMuZ1R5cGVlcnJvcihwLmFzT2JqZWN0KCksIG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiBhIHN0cmluZyBubyBsb25nZXIgdGhhbiBJRFNJWkUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIG9DaHVua2lkKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gTHVhLklEU0laRTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQXQoMCkgPT0gXCI9XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UubGVuZ3RoIDwgTHVhLklEU0laRSArIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic3RyaW5nKDEsIDEgKyBsZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVsc2UgIFwic291cmNlXCIgb3IgXCIuLi5zb3VyY2VcIlxyXG4gICAgICAgICAgICBpZiAoc291cmNlLmNoYXJBdCgwKSA9PSBcIkBcIikge1xyXG4gICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIGxlbiAtPSBcIiAnLi4uJyBcIi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbDIgPSBzb3VyY2UubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGwyID4gbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiLi4uXCIgKyAvLyBnZXQgbGFzdCBwYXJ0IG9mIGZpbGUgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uuc3Vic3RyaW5nKHNvdXJjZS5sZW5ndGggLSBsZW4sIHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBlbHNlICBbc3RyaW5nIFwic3RyaW5nXCJdXHJcbiAgICAgICAgICAgIHZhciBsID0gc291cmNlLmluZGV4T2YoJ1xcbicpO1xyXG4gICAgICAgICAgICBpZiAobCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbCA9IHNvdXJjZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuIC09IFwiIFtzdHJpbmcgXFxcIi4uLlxcXCJdIFwiLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGwgPiBsZW4pIHtcclxuICAgICAgICAgICAgICAgIGwgPSBsZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgYnVmLmFwcGVuZFN0cmluZyhcIltzdHJpbmcgXFxcIlwiKTtcclxuICAgICAgICAgICAgYnVmLmFwcGVuZFN0cmluZyhzb3VyY2Uuc3Vic3RyaW5nKDAsIGwpKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5sZW5ndGggPiBsKSAvLyBtdXN0IHRydW5jYXRlXHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kU3RyaW5nKFwiLi4uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmRTdHJpbmcoXCJcXFwiXVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcXVpdmFsZW50IHRvIGx1YU9fZmIyaW50LlxyXG4gICAgICAgICAqIEBzZWUgU3ludGF4I29JbnQyZmJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgb0ZiMmludCh4KSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gKHggPj4+IDMpICYgMzE7XHJcbiAgICAgICAgICAgIGlmIChlID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoKHggJiA3KSArIDgpIDw8IChlIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGx1YU9fcmF3ZXF1YWxPYmouICovXHJcbiAgICAgICAgc3RhdGljIG9SYXdlcXVhbChhLCBiKSB7XHJcbiAgICAgICAgICAgIC8vIHNlZSBhbHNvIHZtRXF1YWxcclxuICAgICAgICAgICAgaWYgKEx1YS5OSUwgPT0gYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5OSUwgPT0gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBOb3cgYSBpcyBub3QgbnVsbCwgc28gYS5lcXVhbHMoKSBpcyBhIHZhbGlkIGNhbGwuXHJcbiAgICAgICAgICAgIC8vIE51bWJlcnMgKERvdWJsZXMpLCBCb29sZWFucywgU3RyaW5ncyBhbGwgZ2V0IGNvbXBhcmVkIGJ5IHZhbHVlLFxyXG4gICAgICAgICAgICAvLyBhcyB0aGV5IHNob3VsZDsgdGFibGVzLCBmdW5jdGlvbnMsIGdldCBjb21wYXJlZCBieSBpZGVudGl0eSBhc1xyXG4gICAgICAgICAgICAvLyB0aGV5IHNob3VsZC5cclxuICAgICAgICAgICAgcmV0dXJuIGEgPT09IChiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gbHVhT19zdHIyZC4gKi9cclxuICAgICAgICBzdGF0aWMgb1N0cjJkKHMsIG91dCAvKmRvdWJsZVtdICovKSB7XHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiB1c2luZyB0cnkvY2F0Y2ggbWF5IGJlIHRvbyBzbG93LiAgSW4gd2hpY2ggY2FzZSB3ZSdsbCBoYXZlXHJcbiAgICAgICAgICAgIC8vIHRvIHJlY29nbmlzZSB0aGUgdmFsaWQgZm9ybWF0cyBmaXJzdC5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG91dFswXSA9IE51bWJlcihzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlMF8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChlMF8gaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb25fMS5OdW1iZXJGb3JtYXRFeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlMF8uc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IGhleGFkZWNpbWFsIGNvbnZlcnNpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gOnRvZG86IHVzaW5nIFN0cmluZy50cmltIGlzIG5vdCBzdHJpY3RseSBhY2N1cmF0ZSwgYmVjYXVzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaW1zIG90aGVyIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyBhcyB3ZWxsIGFzIHdoaXRlc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvIC9nLCBcIlwiKS50b1VwcGVyQ2FzZSgpOyAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc3Vic3RyKDAsIDIpID09IFwiMFhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcoMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMuc3Vic3RyKDAsIDMpID09IChcIi0wWFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gXCItXCIgKyBzLnN1YnN0cmluZygzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0WzBdID0gcGFyc2VJbnQocyk7IC8vIFRPRE86MTbov5vliLYgMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUxXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlMV8gaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb25fMS5OdW1iZXJGb3JtYXRFeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZTFfLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3VucmVhY2hhYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSGFyZHdpcmVkIHZhbHVlcyBmb3Igc3BlZWQuXHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgb2YgbWFjcm8gR0VUX09QQ09ERSAqL1xyXG4gICAgICAgIHN0YXRpYyBPUENPREUoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gUE9TX09QID09IDAgKHNoaWZ0IGFtb3VudClcclxuICAgICAgICAgICAgLy8gU0laRV9PUCA9PSA2IChvcGNvZGUgd2lkdGgpXHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbiAmIDB4M2Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IG9mIG1hY3JvIEdFVF9PUENPREUgKi9cclxuICAgICAgICBzdGF0aWMgU0VUX09QQ09ERShpLCBvcCkge1xyXG4gICAgICAgICAgICAvLyBQT1NfT1AgPT0gMCAoc2hpZnQgYW1vdW50KVxyXG4gICAgICAgICAgICAvLyBTSVpFX09QID09IDYgKG9wY29kZSB3aWR0aClcclxuICAgICAgICAgICAgcmV0dXJuIChpICYgfjB4M0YpIHwgKG9wICYgMHgzRik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IG9mIG1hY3JvIEdFVEFSR19BICovXHJcbiAgICAgICAgc3RhdGljIEFSR0EoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gUE9TX0EgPT0gUE9TX09QICsgU0laRV9PUCA9PSA2IChzaGlmdCBhbW91bnQpXHJcbiAgICAgICAgICAgIC8vIFNJWkVfQSA9PSA4IChvcGVyYW5kIHdpZHRoKVxyXG4gICAgICAgICAgICByZXR1cm4gKGluc3RydWN0aW9uID4+PiA2KSAmIDB4ZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBTRVRBUkdfQShpLCB1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaSAmIH4oMHhmZiA8PCA2KSkgfCAoKHUgJiAweGZmKSA8PCA2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgb2YgbWFjcm8gR0VUQVJHX0IgKi9cclxuICAgICAgICBzdGF0aWMgQVJHQihpbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBQT1NfQiA9PSBQT1NfT1AgKyBTSVpFX09QICsgU0laRV9BICsgU0laRV9DID09IDIzIChzaGlmdCBhbW91bnQpXHJcbiAgICAgICAgICAgIC8vIFNJWkVfQiA9PSA5IChvcGVyYW5kIHdpZHRoKVxyXG4gICAgICAgICAgICAvKiBObyBtYXNrIHJlcXVpcmVkIGFzIGZpZWxkIG9jY3VwaWVzIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdHMgb2YgYVxyXG4gICAgICAgICAgICAgICAgKiAzMi1iaXQgaW50LiAqL1xyXG4gICAgICAgICAgICByZXR1cm4gKGluc3RydWN0aW9uID4+PiAyMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBTRVRBUkdfQihpLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaSAmIH4oMHgxZmYgPDwgMjMpKSB8ICgoYiAmIDB4MWZmKSA8PCAyMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IG9mIG1hY3JvIEdFVEFSR19DICovXHJcbiAgICAgICAgc3RhdGljIEFSR0MoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gUE9TX0MgPT0gUE9TX09QICsgU0laRV9PUCArIFNJWkVfQSA9PSAxNCAoc2hpZnQgYW1vdW50KVxyXG4gICAgICAgICAgICAvLyBTSVpFX0MgPT0gOSAob3BlcmFuZCB3aWR0aClcclxuICAgICAgICAgICAgcmV0dXJuIChpbnN0cnVjdGlvbiA+Pj4gMTQpICYgMHgxZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBTRVRBUkdfQyhpLCBjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaSAmIH4oMHgxZmYgPDwgMTQpKSB8ICgoYyAmIDB4MWZmKSA8PCAxNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IG9mIG1hY3JvIEdFVEFSR19CeCAqL1xyXG4gICAgICAgIHN0YXRpYyBBUkdCeChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBQT1NfQnggPSBQT1NfQyA9PSAxNFxyXG4gICAgICAgICAgICAvLyBTSVpFX0J4ID09IFNJWkVfQyArIFNJWkVfQiA9PSAxOFxyXG4gICAgICAgICAgICAvKiBObyBtYXNrIHJlcXVpcmVkIGFzIGZpZWxkIG9jY3VwaWVzIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdHMgb2YgYVxyXG4gICAgICAgICAgICAgICAgKiAzMiBiaXQgaW50LiAqL1xyXG4gICAgICAgICAgICByZXR1cm4gKGluc3RydWN0aW9uID4+PiAxNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBTRVRBUkdfQngoaSwgYngpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpICYgMHgzZmZmKSB8IChieCA8PCAxNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IG9mIG1hY3JvIEdFVEFSR19zQnggKi9cclxuICAgICAgICBzdGF0aWMgQVJHc0J4KGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIEFzIEFSR0J4IGJ1dCB3aXRoICgyKioxNy0xKSBzdWJ0cmFjdGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gKGluc3RydWN0aW9uID4+PiAxNCkgLSBMdWEuTUFYQVJHX3NCeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIFNFVEFSR19zQngoaSwgYngpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpICYgMHgzZmZmKSB8ICgoYnggKyBMdWEuTUFYQVJHX3NCeCkgPDwgMTQpOyAvLyBDSEVDSyBUSElTIElTIFJJR0hUXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBJU0soZmllbGQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIFwiaXMgY29uc3RhbnRcIiBiaXQgcG9zaXRpb24gZGVwZW5kcyBvbiB0aGUgc2l6ZSBvZiB0aGUgQiBhbmQgQ1xyXG4gICAgICAgICAgICAvLyBmaWVsZHMgKHJlcXVpcmVkIHRvIGJlIHRoZSBzYW1lIHdpZHRoKS5cclxuICAgICAgICAgICAgLy8gU0laRV9CID09IDlcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkID49IDB4MTAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIE5lYXIgZXF1aXZhbGVudCBvZiBtYWNyb3MgUktCIGFuZCBSS0MuICBOb3RlOiBub24tc3RhdGljIGFzIGl0XHJcbiAgICAgICAgKiByZXF1aXJlcyBzdGFjayBhbmQgYmFzZSBpbnN0YW5jZSBtZW1iZXJzLiAgU3RhbmRzIGZvciBcIlJlZ2lzdGVyIG9yXHJcbiAgICAgICAgKiBLb25zdGFudFwiIGJ5IHRoZSB3YXksIGl0IGdldHMgdmFsdWUgZnJvbSBlaXRoZXIgdGhlIHJlZ2lzdGVyIGZpbGVcclxuICAgICAgICAqIChzdGFjaykgb3IgdGhlIGNvbnN0YW50IGFycmF5IChrKS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIFJLKGsgLypTbG90W10gKi8sIGZpZWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChMdWEuSVNLKGZpZWxkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtbZmllbGQgJiAweGZmXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBTbG93ZXIgdmVyc2lvbiBvZiBSSyB0aGF0IGRvZXMgbm90IHJlY2VpdmUgdGhlIGNvbnN0YW50IGFycmF5LiAgTm90XHJcbiAgICAgICAgKiByZWNvbW1lbmQgZm9yIHJvdXRpbmUgdXNlLCBidXQgaXMgdXNlZCBieSBzb21lIGVycm9yIGhhbmRsaW5nIGNvZGVcclxuICAgICAgICAqIHRvIGF2b2lkIGhhdmluZyBhIGNvbnN0YW50IGFycmF5IHBhc3NlZCBhcm91bmQgdG9vIG11Y2guXHJcbiAgICAgICAgKi9cclxuICAgICAgICBfX1JLKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIHZhciBfZnVuY3Rpb24gPSB0aGlzLl9zdGFja1t0aGlzLl9fY2koKS5mdW5jXS5yO1xyXG4gICAgICAgICAgICB2YXIgayA9IF9mdW5jdGlvbi5wcm90by5jb25zdGFudDsgLy9TbG90W11cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuUksoaywgZmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDUkVBVEUgZnVuY3Rpb25zIGFyZSByZXF1aXJlZCBieSBGdW5jU3RhdGUsIHNvIGRlZmF1bHQgYWNjZXNzLlxyXG4gICAgICAgIHN0YXRpYyBDUkVBVEVfQUJDKG8sIGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgLy8gUE9TX09QID09IDBcclxuICAgICAgICAgICAgLy8gUE9TX0EgPT0gNlxyXG4gICAgICAgICAgICAvLyBQT1NfQiA9PSAyM1xyXG4gICAgICAgICAgICAvLyBQT1NfQyA9PSAxNFxyXG4gICAgICAgICAgICByZXR1cm4gbyB8IChhIDw8IDYpIHwgKGIgPDwgMjMpIHwgKGMgPDwgMTQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgQ1JFQVRFX0FCeChvLCBhLCBiYykge1xyXG4gICAgICAgICAgICAvLyBQT1NfT1AgPT0gMFxyXG4gICAgICAgICAgICAvLyBQT1NfQSA9PSA2XHJcbiAgICAgICAgICAgIC8vIFBPU19CeCA9PSBQT1NfQyA9PSAxNFxyXG4gICAgICAgICAgICByZXR1cm4gbyB8IChhIDw8IDYpIHwgKGJjIDw8IDE0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXF1aXZhbGVudCBvZiBsdWFEX2NhbGwuXHJcbiAgICAgICAgICogQHBhcmFtIGZ1bmMgIGFic29sdXRlIHN0YWNrIGluZGV4IG9mIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgICAgICogQHBhcmFtIHIgICAgIG51bWJlciBvZiByZXF1aXJlZCByZXN1bHRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZtQ2FsbChmdW5jLCByKSB7XHJcbiAgICAgICAgICAgICsrdGhpcy5fbkNjYWxscztcclxuICAgICAgICAgICAgaWYgKHRoaXMudm1QcmVjYWxsKGZ1bmMsIHIpID09IEx1YS5QQ1JMVUEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudm1FeGVjdXRlKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC0tdGhpcy5fbkNjYWxscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgb2YgbHVhVl9jb25jYXQuICovXHJcbiAgICAgICAgdm1Db25jYXQodG90YWwsIGxhc3QpIHtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuX2Jhc2UgKyBsYXN0ICsgMTtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gMjsgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIGhhbmRsZWQgaW4gdGhpcyBwYXNzIChhdCBsZWFzdCAyKVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvc3RyaW5nKHRvcCAtIDIpIHx8ICF0aGlzLnRvc3RyaW5nKHRvcCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxfYmluVE0odGhpcy5fc3RhY2tbdG9wIC0gMl0sIHRoaXMuX3N0YWNrW3RvcCAtIDFdLCB0aGlzLl9zdGFja1t0b3AgLSAyXSwgXCJfX2NvbmNhdFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdDb25jYXRlcnJvcih0b3AgLSAyLCB0b3AgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGFja1t0b3AgLSAxXS5yLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGwgPSB0aGlzLl9zdGFja1t0b3AgLSAxXS5yLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gPSAxOyBuIDwgdG90YWwgJiYgdGhpcy50b3N0cmluZyh0b3AgLSBuIC0gMSk7ICsrbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bCArPSB0aGlzLl9zdGFja1t0b3AgLSBuIC0gMV0uci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ1J1bmVycm9yKFwic3RyaW5nIGxlbmd0aCBvdmVyZmxvd1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFN0cmluZ0J1ZmZlcl8xLlN0cmluZ0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5pbml0KHRsKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+IDA7IGktLSkgLy8gY29uY2F0IGFsbCBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZFN0cmluZyh0aGlzLl9zdGFja1t0b3AgLSBpXS5yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdG9wIC0gbl0uciA9IGJ1ZmZlci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG90YWwgLT0gbiAtIDE7IC8vIGdvdCBuIHN0cmluZ3MgdG8gY3JlYXRlIDEgbmV3XHJcbiAgICAgICAgICAgICAgICBsYXN0IC09IG4gLSAxO1xyXG4gICAgICAgICAgICB9IHdoaWxlICh0b3RhbCA+IDEpOyAvLyByZXBlYXQgdW50aWwgb25seSAxIHJlc3VsdCBsZWZ0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByaW1pdGl2ZSBmb3IgdGVzdGluZyBMdWEgZXF1YWxpdHkgb2YgdHdvIHZhbHVlcy4gIEVxdWl2YWxlbnQgb2ZcclxuICAgICAgICAgKiBQVUMtUmlvJ3MgPGNvZGU+ZXF1YWxvYmo8L2NvZGU+IG1hY3JvLlxyXG4gICAgICAgICAqIEluIHRoZSBsb29zZXN0IHNlbnNlLCB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mXHJcbiAgICAgICAgICogPGNvZGU+bHVhVl9lcXVhbHZhbDwvY29kZT4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdm1FcXVhbChhLCBiKSB7XHJcbiAgICAgICAgICAgIC8vIERlYWwgd2l0aCBudW1iZXIgY2FzZSBmaXJzdFxyXG4gICAgICAgICAgICBpZiAoTHVhLk5VTUJFUiA9PSBhLnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChMdWEuTlVNQkVSICE9IGIucikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmQgPT0gYi5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdyB3ZSdyZSBvbmx5IGNvbmNlcm5lZCB3aXRoIHRoZSAuciBmaWVsZC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudm1FcXVhbFJlZihhLnIsIGIucik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnQgb2Yge0BsaW5rICN2bUVxdWFsfS4gIENvbXBhcmVzIHRoZSByZWZlcmVuY2UgcGFydCBvZiB0d29cclxuICAgICAgICAgKiBTbG90IGluc3RhbmNlcy4gIFRoYXQgaXMsIGNvbXBhcmVzIHR3byBMdWEgdmFsdWVzLCBhcyBsb25nIGFzXHJcbiAgICAgICAgICogbmVpdGhlciBpcyBhIG51bWJlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2bUVxdWFsUmVmKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKGEgPT09IChiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgICAgICAvL2lmIChhLmdldENsYXNzICE9IGIuZ2V0Q2xhc3MoKSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYSkgIT0gdHlwZW9mIChiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhbWUgY2xhc3MsIGJ1dCBkaWZmZXJlbnQgb2JqZWN0cy5cclxuICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBMdWFKYXZhQ2FsbGJhY2tfMS5MdWFKYXZhQ2FsbGJhY2sgfHxcclxuICAgICAgICAgICAgICAgIGEgaW5zdGFuY2VvZiBMdWFUYWJsZV8xLkx1YVRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNvcnQgdG8gbWV0YW1ldGhvZHMuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG0gPSB0aGlzLmdldF9jb21wVE0odGhpcy5nZXRNZXRhdGFibGUoYSksIHRoaXMuZ2V0TWV0YXRhYmxlKGIpLCBcIl9fZXFcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhLk5JTCA9PSB0bSkgLy8gbm8gVE0/XHJcbiAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FsbFRNcmVzKHMsIHRtLCBhLCBiKTsgLy8gY2FsbCBUTSAgIC8vVE9ETzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc0ZhbHNlKHMucik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgZ2V0T3Bjb2RlTmFtZShjb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJcIjtcclxuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9NT1ZFOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX01PVkVcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0xPQURLOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0xPQURLXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9MT0FEQk9PTDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9MT0FEQk9PTFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTE9BRE5JTDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9MT0FETklMXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9HRVRVUFZBTDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9HRVRVUFZBTFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfR0VUR0xPQkFMOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0dFVEdMT0JBTFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfR0VUVEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfR0VUVEFCTEVcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1NFVEdMT0JBTDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9TRVRHTE9CQUxcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1NFVFVQVkFMOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX1NFVFVQVkFMXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9TRVRUQUJMRTpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9TRVRUQUJMRVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTkVXVEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfTkVXVEFCTEVcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1NFTEY6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfU0VMRlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfQUREOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0FERFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfU1VCOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX1NVQlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTVVMOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX01VTFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfRElWOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0RJVlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTU9EOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX01PRFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfUE9XOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX1BPV1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfVU5NOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX1VOTVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTk9UOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX05PVFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTEVOOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0xFTlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfQ09OQ0FUOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0NPTkNBVFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfSk1QOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0pNUFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfRVE6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfRVFcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0xUOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX0xUXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9MRTpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9MRVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfVEVTVDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9URVNUXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9URVNUU0VUOlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9QX1RFU1RTRVRcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0NBTEw6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfQ0FMTFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfVEFJTENBTEw6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfVEFJTENBTExcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1JFVFVSTjpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9SRVRVUk5cIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0ZPUkxPT1A6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfRk9STE9PUFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfRk9SUFJFUDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9GT1JQUkVQXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9URk9STE9PUDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9URk9STE9PUFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfU0VUTElTVDpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9TRVRMSVNUXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9DTE9TRTpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9DTE9TRVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfQ0xPU1VSRTpcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJPUF9DTE9TVVJFXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9WQVJBUkc6XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiT1BfVkFSQVJHXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBUaGUgY29yZSBWTSBleGVjdXRpb24gZW5naW5lLiAqL1xyXG4gICAgICAgIHZtRXhlY3V0ZShuZXhlY2NhbGxzKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbGFiZWxsZWQgd2hpbGUgbG9vcCBpcyB1c2VkIHRvIHNpbXVsYXRlIHRoZSBlZmZlY3Qgb2YgQydzXHJcbiAgICAgICAgICAgIC8vIGdvdG8uICBUaGUgZW5kIG9mIHRoZSB3aGlsZSBsb29wIGlzIG5ldmVyIHJlYWNoZWQuICBUaGUgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgIC8vIG9mIHRoZSB3aGlsZSBsb29wIGlzIGJyYW5jaGVkIHRvIHVzaW5nIGEgXCJjb250aW51ZSByZWVudHJ5O1wiXHJcbiAgICAgICAgICAgIC8vIHN0YXRlbWVudCAod2hlbiBhIEx1YSBmdW5jdGlvbiBpcyBjYWxsZWQgb3IgcmV0dXJucykuXHJcbiAgICAgICAgICAgIHJlZW50cnk6IHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgc3RhY2tbY2kuZnVuY3Rpb24oKV0uciBpbnN0YW5jZW9mIEx1YUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9mdW5jdGlvbiA9IHRoaXMuX3N0YWNrW3RoaXMuX19jaSgpLmZ1bmNdLnI7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBfZnVuY3Rpb24ucHJvdG87XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHByb3RvLmNvZGU7IC8vaW50W11cclxuICAgICAgICAgICAgICAgIHZhciBrID0gcHJvdG8uY29uc3RhbnQ7IC8vU2xvdFtdIFxyXG4gICAgICAgICAgICAgICAgdmFyIHBjID0gdGhpcy5fc2F2ZWRwYztcclxuICAgICAgICAgICAgICAgIC8vMjAxNzA0MDI6YWRkZWRcclxuICAgICAgICAgICAgICAgIGlmIChMdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdXNhZ2U6bHVhYyAtcCAtbCBjZi5sdWFcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpX3Rlc3QgPSAwOyBpX3Rlc3QgPCBjb2RlLmxlbmd0aDsgaV90ZXN0KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUxID0gTHVhLmdldE9wY29kZU5hbWUoTHVhLk9QQ09ERShjb2RlW2lfdGVzdF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCI+Pj5PUENPREUoY29kZShcIiArIChpX3Rlc3QgKyAxKSArIFwiKSkgPT0gXCIgKyBuYW1lMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIC8vIG1haW4gbG9vcCBvZiBpbnRlcnByZXRlclxyXG4gICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVyZSB0aGUgUFVDLVJpbyBjb2RlIHVzZWQgdGhlIFByb3RlY3QgbWFjcm8sIHRoaXMgaGFzIGJlZW5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlZCB3aXRoIFwic2F2ZWRwYyA9IHBjXCIgYW5kIGEgXCIvLyBQcm90ZWN0XCIgY29tbWVudC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVyZSB0aGUgUFVDLVJpbyBjb2RlIHVzZWQgdGhlIGRvanVtcCBtYWNybywgdGhpcyBoYXMgYmVlblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VkIHdpdGggdGhlIGVxdWl2YWxlbnQgaW5jcmVtZW50IG9mIHRoZSBwYyBhbmQgYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiLy9kb2p1bXBcIiBjb21tZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gY29kZVtwYysrXTsgLy8gVk0gaW5zdHJ1Y3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gOnRvZG86IGxpbmUgaG9va1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5faG9va21hc2sgJiBMdWEuTUFTS0NPVU5UKSAhPSAwICYmIC0tdGhpcy5faG9va2NvdW50ID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZWV4ZWMocGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gTHVhLllJRUxEKSAvLyBkaWQgaG9vayB5aWVsZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkcGMgPSBwYyAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzZSA9IHRoaXMuYmFzZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IEx1YS5BUkdBKGkpOyAvLyBpdHMgQSBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJjO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vMjAxNzA0MDI6YWRkZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTHVhLkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUyID0gTHVhLmdldE9wY29kZU5hbWUoTHVhLk9QQ09ERShpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiPj4+cGMgPT0gXCIgKyBwYyArIFwiLCBuYW1lID09IFwiICsgbmFtZTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKEx1YS5PUENPREUoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTU9WRTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIEx1YS5BUkdCKGkpXS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLmQgPSB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgTHVhLkFSR0IoaSldLmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTE9BREs6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IGtbTHVhLkFSR0J4KGkpXS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLmQgPSBrW0x1YS5BUkdCeChpKV0uZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT1BfTE9BREs6c3RhY2tbXCIgKyAodGhpcy5fYmFzZSArIGEpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJdPWtbXCIgKyBMdWEuQVJHQngoaSkgKyBcIl09XCIgKyBrW0x1YS5BUkdCeChpKV0uZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTE9BREJPT0w6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IEx1YS52YWx1ZU9mQm9vbGVhbihMdWEuQVJHQihpKSAhPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWEuQVJHQyhpKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytwYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9MT0FETklMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5fYmFzZSArIEx1YS5BUkdCKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbYi0tXS5yID0gTHVhLk5JTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChiID49IHRoaXMuX2Jhc2UgKyBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfR0VUVVBWQUw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIyID0gTHVhLkFSR0IoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gOnRvZG86IG9wdGltaXNlIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE9iamVjdEF0KF9mdW5jdGlvbi51cFZhbChiMikudmFsdWUsIHRoaXMuX2Jhc2UgKyBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfR0VUR0xPQkFMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSBrW0x1YS5BUkdCeChpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnQgcmIgaW5zdGFuY2Ugb2YgU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IHBjOyAvLyBQcm90ZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZtR2V0dGFibGUoX2Z1bmN0aW9uLmVudiwgcmIsIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfR0VUVEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IHBjOyAvLyBQcm90ZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgTHVhLkFSR0IoaSldLmFzT2JqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEx1YS5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT1BfR0VUVEFCTEUgaW5kZXggPSBcIiArICh0aGlzLl9iYXNlICsgTHVhLkFSR0IoaSkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCBzaXplID0gXCIgKyB0aGlzLl9zdGFjay5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGggPSBcIiArIGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZtR2V0dGFibGUoaCwgdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSksIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1NFVFVQVkFMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1diA9IF9mdW5jdGlvbi51cFZhbChMdWEuQVJHQihpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYudmFsdWUgPSB0aGlzLm9iamVjdEF0KHRoaXMuX2Jhc2UgKyBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfU0VUR0xPQkFMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IHBjOyAvLyBQcm90ZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA6dG9kbzogY29uc2lkZXIgaW5saW5pbmcgb2JqZWN0QXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudm1TZXR0YWJsZShfZnVuY3Rpb24uZW52LCBrW0x1YS5BUkdCeChpKV0sIHRoaXMub2JqZWN0QXQodGhpcy5fYmFzZSArIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9TRVRUQUJMRTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gcGM7IC8vIFByb3RlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5hc09iamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudm1TZXR0YWJsZSh0LCB0aGlzLlJLKGssIEx1YS5BUkdCKGkpKSwgdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSkuYXNPYmplY3QoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX05FV1RBQkxFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiMyA9IEx1YS5BUkdCKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gTHVhLkFSR0MoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnIgPSBuZXcgTHVhVGFibGVfMS5MdWFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yLmluaXQoTHVhLm9GYjJpbnQoYjMpLCBMdWEub0ZiMmludChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1NFTEY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGI0ID0gTHVhLkFSR0IoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYjRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhICsgMV0uciA9IHJiLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGEgKyAxXS5kID0gcmIuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gcGM7IC8vIFByb3RlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZtR2V0dGFibGUocmIuYXNPYmplY3QoKSwgdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSksIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0FERDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJiID0gdGhpcy5SSyhrLCBMdWEuQVJHQihpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYyA9IHRoaXMuUksoaywgTHVhLkFSR0MoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJiLnIgPT0gTHVhLk5VTUJFUiAmJiByYy5yID09IEx1YS5OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gcmIuZCArIHJjLmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLmQgPSBzdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnIgPSBMdWEuTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoTHVhLnRvTnVtYmVyUGFpcihyYiwgcmMsIEx1YS5OVU1PUCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtMiA9IEx1YS5OVU1PUFswXSArIEx1YS5OVU1PUFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IHN1bTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnIgPSBMdWEuTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY2FsbF9iaW5UTShyYiwgcmMsIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXSwgXCJfX2FkZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ0FyaXRoZXJyb3IocmIsIHJjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9TVUI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYiA9IHRoaXMuUksoaywgTHVhLkFSR0IoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmMgPSB0aGlzLlJLKGssIEx1YS5BUkdDKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYi5yID09IEx1YS5OVU1CRVIgJiYgcmMuciA9PSBMdWEuTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSByYi5kIC0gcmMuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnIgPSBMdWEuTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoTHVhLnRvTnVtYmVyUGFpcihyYiwgcmMsIEx1YS5OVU1PUCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZTIgPSBMdWEuTlVNT1BbMF0gLSBMdWEuTlVNT1BbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLmQgPSBkaWZmZXJlbmNlMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IEx1YS5OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jYWxsX2JpblRNKHJiLCByYywgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLCBcIl9fc3ViXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nQXJpdGhlcnJvcihyYiwgcmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX01VTDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJiID0gdGhpcy5SSyhrLCBMdWEuQVJHQihpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYyA9IHRoaXMuUksoaywgTHVhLkFSR0MoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJiLnIgPT0gTHVhLk5VTUJFUiAmJiByYy5yID09IEx1YS5OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZHVjdCA9IHJiLmQgKiByYy5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5kID0gcHJvZHVjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IEx1YS5OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChMdWEudG9OdW1iZXJQYWlyKHJiLCByYywgTHVhLk5VTU9QKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9kdWN0MiA9IEx1YS5OVU1PUFswXSAqIEx1YS5OVU1PUFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IHByb2R1Y3QyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxfYmluVE0ocmIsIHJjLCB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0sIFwiX19tdWxcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdBcml0aGVycm9yKHJiLCByYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfRElWOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSB0aGlzLlJLKGssIEx1YS5BUkdCKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJjID0gdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmIuciA9PSBMdWEuTlVNQkVSICYmIHJjLnIgPT0gTHVhLk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdW90aWVudCA9IHJiLmQgLyByYy5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5kID0gcXVvdGllbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnIgPSBMdWEuTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoTHVhLnRvTnVtYmVyUGFpcihyYiwgcmMsIEx1YS5OVU1PUCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGllbnQyID0gTHVhLk5VTU9QWzBdIC8gTHVhLk5VTU9QWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5kID0gcXVvdGllbnQyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxfYmluVE0ocmIsIHJjLCB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0sIFwiX19kaXZcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdBcml0aGVycm9yKHJiLCByYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTU9EOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSB0aGlzLlJLKGssIEx1YS5BUkdCKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJjID0gdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmIuciA9PSBMdWEuTlVNQkVSICYmIHJjLnIgPT0gTHVhLk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bHVzID0gTHVhLl9fbW9kdWx1cyhyYi5kLCByYy5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IG1vZHVsdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnIgPSBMdWEuTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoTHVhLnRvTnVtYmVyUGFpcihyYiwgcmMsIEx1YS5OVU1PUCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWx1czIgPSBMdWEuX19tb2R1bHVzKEx1YS5OVU1PUFswXSwgTHVhLk5VTU9QWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IG1vZHVsdXMyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxfYmluVE0ocmIsIHJjLCB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0sIFwiX19tb2RcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdBcml0aGVycm9yKHJiLCByYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfUE9XOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSB0aGlzLlJLKGssIEx1YS5BUkdCKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJjID0gdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmIuciA9PSBMdWEuTlVNQkVSICYmIHJjLnIgPT0gTHVhLk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBMdWEuaU51bXBvdyhyYi5kLCByYy5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IEx1YS5OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChMdWEudG9OdW1iZXJQYWlyKHJiLCByYywgTHVhLk5VTU9QKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQyID0gTHVhLmlOdW1wb3coTHVhLk5VTU9QWzBdLCBMdWEuTlVNT1BbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5kID0gcmVzdWx0MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IEx1YS5OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jYWxsX2JpblRNKHJiLCByYywgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLCBcIl9fcG93XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nQXJpdGhlcnJvcihyYiwgcmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1VOTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJiID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIEx1YS5BUkdCKGkpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYi5yID09IEx1YS5OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IC1yYi5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEx1YS50b251bWJlcihyYiwgTHVhLk5VTU9QKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5kID0gLUx1YS5OVU1PUFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IEx1YS5OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jYWxsX2JpblRNKHJiLCByYiwgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLCBcIl9fdW5tXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nQXJpdGhlcnJvcihyYiwgcmIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX05PVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbnVtYmVycyBhcmUgdHJlYXRlZCBhcyB0cnVlLCBzbyBubyBuZWVkIHRvIGV4YW1pbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgLmQgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIEx1YS5BUkdCKGkpXS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gTHVhLnZhbHVlT2ZCb29sZWFuKHRoaXMuaXNGYWxzZShyYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9MRU46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYiA9IHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBMdWEuQVJHQihpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmIuciBpbnN0YW5jZW9mIEx1YVRhYmxlXzEuTHVhVGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDIgPSByYi5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5kID0gdDIuZ2V0bigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJiLnIgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIChyYi5yKSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gcmIucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkcGMgPSBwYzsgLy8gUHJvdGVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxfYmluVE0ocmIsIHJiLCB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0sIFwiX19sZW5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdUeXBlZXJyb3IocmIsIFwiZ2V0IGxlbmd0aCBvZlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9DT05DQVQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJfQ09OQ0FUID0gTHVhLkFSR0IoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNfQ09OQ0FUID0gTHVhLkFSR0MoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IHBjOyAvLyBQcm90ZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gOnRvZG86IFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhY2sgbG9jYXRpb25zIF9hYm92ZV8gYiBlbmQgdXAgd2l0aCBqdW5rIGluIHRoZW0uICBJblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGNhc2Ugd2UgY2FuIGltcHJvdmUgdGhlIHNwZWVkIG9mIHZtQ29uY2F0IChieSBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0aW5nIGVhY2ggc3RhY2sgc2xvdCwgYnV0IHNpbXBseSB1c2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZ0J1ZmZlci5hcHBlbmQgb24gd2hhdGV2ZXIgaXMgdGhlcmUpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudm1Db25jYXQoY19DT05DQVQgLSBiX0NPTkNBVCArIDEsIGNfQ09OQ0FUKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBiX0NPTkNBVF0ucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCA9IHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBiX0NPTkNBVF0uZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfSk1QOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9qdW1wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYyArPSBMdWEuQVJHc0J4KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0VROlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSB0aGlzLlJLKGssIEx1YS5BUkdCKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJjID0gdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52bUVxdWFsKHJiLCByYykgPT0gKGEgIT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb2p1bXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYyArPSBMdWEuQVJHc0J4KGNvZGVbcGNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrcGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfTFQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYiA9IHRoaXMuUksoaywgTHVhLkFSR0IoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmMgPSB0aGlzLlJLKGssIEx1YS5BUkdDKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkcGMgPSBwYzsgLy8gUHJvdGVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudm1MZXNzdGhhbihyYiwgcmMpID09IChhICE9IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9qdW1wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGMgKz0gTHVhLkFSR3NCeChjb2RlW3BjXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3BjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0xFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSB0aGlzLlJLKGssIEx1YS5BUkdCKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJjID0gdGhpcy5SSyhrLCBMdWEuQVJHQyhpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gcGM7IC8vIFByb3RlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZtTGVzc2VxdWFsKHJiLCByYykgPT0gKGEgIT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb2p1bXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYyArPSBMdWEuQVJHc0J4KGNvZGVbcGNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrcGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMdWEuT1BfVEVTVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmFsc2UodGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnIpICE9IChMdWEuQVJHQyhpKSAhPSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvanVtcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjICs9IEx1YS5BUkdzQngoY29kZVtwY10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytwYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9URVNUU0VUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmIgPSB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgTHVhLkFSR0IoaSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGYWxzZShyYi5yKSAhPSAoTHVhLkFSR0MoaSkgIT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IHJiLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLmQgPSByYi5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvanVtcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjICs9IEx1YS5BUkdzQngoY29kZVtwY10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytwYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9DQUxMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiX0NBTEwgPSBMdWEuQVJHQihpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnJlc3VsdHMgPSBMdWEuQVJHQyhpKSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJfQ0FMTCAhPSAwKSAvL0ZJWE1FOmJ1ZzogYi0+Yl9DQUxMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUodGhpcy5fYmFzZSArIGEgKyBiX0NBTEwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gcGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnZtUHJlY2FsbCh0aGlzLl9iYXNlICsgYSwgbnJlc3VsdHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLlBDUkxVQTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leGVjY2FsbHMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHJlZW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLlBDUko6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXMgSmF2YSBmdW5jdGlvbiBjYWxsZWQgYnkgcHJlY2FsbCwgYWRqdXN0IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5yZXN1bHRzID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZSh0aGlzLl9fY2koKS50b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHlpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9UQUlMQ0FMTDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYl9UQUlMQ0FMTCA9IEx1YS5BUkdCKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiX1RBSUxDQUxMICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUodGhpcy5fYmFzZSArIGEgKyBiX1RBSUxDQUxMKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IHBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2VydCBBUkdDKGkpIC0gMSA9PSBNVUxUUkVUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnZtUHJlY2FsbCh0aGlzLl9iYXNlICsgYSwgTHVhLk1VTFRSRVQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLlBDUkxVQTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWlsIGNhbGw6IHB1dCBuZXcgZnJhbWUgaW4gcGxhY2Ugb2YgcHJldmlvdXMgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaSA9IHRoaXMuX2Npdi5lbGVtZW50QXQodGhpcy5fY2l2LnNpemUgLSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IGNpLmZ1bmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZjaSA9IHRoaXMuX19jaSgpOyAvLyBGcmVzaCBDYWxsSW5mb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZnVuYyA9IGZjaS5mdW5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZkNsb3NlKGNpLmJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2UgPSBmdW5jICsgKGZjaS5iYXNlIC0gcGZ1bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdXg7IC8vIGxvb3AgaW5kZXggaXMgdXNlZCBhZnRlciBsb29wIGVuZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGF1eCA9IDA7IHBmdW5jICsgYXV4IDwgdGhpcy5fc3RhY2tTaXplOyArK2F1eCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGZyYW1lIGRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbZnVuYyArIGF1eF0uciA9IHRoaXMuX3N0YWNrW3BmdW5jICsgYXV4XS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tmdW5jICsgYXV4XS5kID0gdGhpcy5fc3RhY2tbcGZ1bmMgKyBhdXhdLmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tzZXRzaXplKGZ1bmMgKyBhdXgpOyAvLyBjb3JyZWN0IHRvcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2VydCBzdGFja1NpemUgPT0gYmFzZSArICgoTHVhRnVuY3Rpb24pc3RhY2tbZnVuY10pLnByb3RvKCkubWF4c3RhY2tzaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2kudGFpbGNhbGwodGhpcy5fYmFzZSwgdGhpcy5fc3RhY2tTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY19jaSgpOyAvLyByZW1vdmUgbmV3IGZyYW1lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHJlZW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLlBDUko6IC8vIEl0IHdhcyBhIEphdmEgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHlpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9SRVRVUk46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mQ2xvc2UodGhpcy5fYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJfUkVUVVJOID0gTHVhLkFSR0IoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJfUkVUVVJOICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9IGEgKyBiX1JFVFVSTiAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tzZXRzaXplKHRoaXMuX2Jhc2UgKyB0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gcGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2FkanVzdCcgcmVwbGFjZXMgYWxpYXNlZCAnYicgaW4gUFVDLVJpbyBjb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3QgPSB0aGlzLnZtUG9zY2FsbCh0aGlzLl9iYXNlICsgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbmV4ZWNjYWxscyA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZSh0aGlzLl9fY2koKS50b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSByZWVudHJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9GT1JMT09QOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGVwID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGEgKyAyXS5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZCArIHN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGEgKyAxXS5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCA8IHN0ZXAgJiYgaWR4IDw9IGxpbWl0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RlcCA8PSAwICYmIGxpbWl0IDw9IGlkeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9qdW1wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjICs9IEx1YS5BUkdzQngoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5kID0gaWR4OyAvLyBpbnRlcm5hbCBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uciA9IEx1YS5OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhICsgM10uZCA9IGlkeDsgLy8gZXh0ZXJuYWwgaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGEgKyAzXS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0ZPUlBSRVA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLl9iYXNlICsgYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxpbWl0ID0gdGhpcy5fYmFzZSArIGEgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc3RlcCA9IHRoaXMuX2Jhc2UgKyBhICsgMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlZHBjID0gcGM7IC8vIG5leHQgc3RlcHMgbWF5IHRocm93IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50b251bWJlcihpbml0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdSdW5lcnJvcihcIidmb3InIGluaXRpYWwgdmFsdWUgbXVzdCBiZSBhIG51bWJlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMudG9udW1iZXIocGxpbWl0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdSdW5lcnJvcihcIidmb3InIGxpbWl0IG11c3QgYmUgYSBudW1iZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnRvbnVtYmVyKHBzdGVwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdSdW5lcnJvcihcIidmb3InIHN0ZXAgbXVzdCBiZSBhIG51bWJlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXBfRk9SUFJFUCA9IHRoaXMuX3N0YWNrW3BzdGVwXS5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHhfRk9SUFJFUCA9IHRoaXMuX3N0YWNrW2luaXRdLmQgLSBzdGVwX0ZPUlBSRVA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbaW5pdF0uZCA9IGlkeF9GT1JQUkVQO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW2luaXRdLnIgPSBMdWEuTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvanVtcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjICs9IEx1YS5BUkdzQngoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1RGT1JMT09QOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IHRoaXMuX2Jhc2UgKyBhICsgMzsgLy8gY2FsbCBiYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbY2IgKyAyXS5yID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGEgKyAyXS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW2NiICsgMl0uZCA9IHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhICsgMl0uZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tjYiArIDFdLnIgPSB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYSArIDFdLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbY2IgKyAxXS5kID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGEgKyAxXS5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW2NiXS5yID0gdGhpcy5fc3RhY2tbdGhpcy5fYmFzZSArIGFdLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbY2JdLmQgPSB0aGlzLl9zdGFja1t0aGlzLl9iYXNlICsgYV0uZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZShjYiArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkcGMgPSBwYzsgLy8gUHJvdGVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudm1DYWxsKGNiLCBMdWEuQVJHQyhpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUodGhpcy5fX2NpKCkudG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTHVhLk5JTCAhPSB0aGlzLl9zdGFja1tjYl0ucikgLy8gY29udGludWUgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW2NiIC0gMV0uciA9IHRoaXMuX3N0YWNrW2NiXS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tjYiAtIDFdLmQgPSB0aGlzLl9zdGFja1tjYl0uZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9qdW1wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjICs9IEx1YS5BUkdzQngoY29kZVtwY10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3BjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEx1YS5PUF9TRVRMSVNUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gTHVhLkFSR0IoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNfU0VUTElTVCA9IEx1YS5BUkdDKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRzdGFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09IG4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9ICh0aGlzLl9zdGFja1NpemUgLSAodGhpcy5fYmFzZSArIGEpKSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHN0YWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT0gY19TRVRMSVNUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNfU0VUTElTVCA9IGNvZGVbcGMrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0MyA9IHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gKChjX1NFVExJU1QgLSAxKSAqIEx1YS5MRklFTERTX1BFUl9GTFVTSCkgKyBuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBjb25zaWRlciBleHBhbmRpbmcgc3BhY2UgaW4gdGFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbiA+IDA7IG4tLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5vYmplY3RBdCh0aGlzLl9iYXNlICsgYSArIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0My5wdXRudW0obGFzdC0tLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0c3RhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUodGhpcy5fX2NpKCkudG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0NMT1NFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mQ2xvc2UodGhpcy5fYmFzZSArIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX0NMT1NVUkU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfZnVuY3Rpb24ucHJvdG8ucHJvdG9bTHVhLkFSR0J4KGkpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVwID0gcC5udXBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cCA9IG5ldyBBcnJheShudXApOyAvL1VwVmFsW10gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudXA7IGorKywgcGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2luID0gY29kZVtwY107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWEuT1BDT0RFKF9pbikgPT0gTHVhLk9QX0dFVFVQVkFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cFtqXSA9IF9mdW5jdGlvbi51cFZhbChMdWEuQVJHQihfaW4pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2VydCBPUENPREUoaW4pID09IE9QX01PVkU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cFtqXSA9IHRoaXMuZkZpbmR1cHZhbCh0aGlzLl9iYXNlICsgTHVhLkFSR0IoX2luKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5mID0gbmV3IEx1YUZ1bmN0aW9uXzEuTHVhRnVuY3Rpb24ocCwgdXAsIF9mdW5jdGlvbi5lbnYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXAgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhXS5yID0gbmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTHVhLk9QX1ZBUkFSRzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYl9WQVJBUkcgPSBMdWEuQVJHQihpKSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5fVkFSQVJHID0gKHRoaXMuX2Jhc2UgLSB0aGlzLl9fY2koKS5mdW5jKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mdW5jdGlvbi5wcm90by5udW1wYXJhbXMgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiX1ZBUkFSRyA9PSBMdWEuTVVMVFJFVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA6dG9kbzogUHJvdGVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA6dG9kbzogY2hlY2sgc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYl9WQVJBUkcgPSBuX1ZBUkFSRztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUodGhpcy5fYmFzZSArIGEgKyBuX1ZBUkFSRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGpfVkFSQVJHID0gMDsgal9WQVJBUkcgPCBiX1ZBUkFSRzsgKytqX1ZBUkFSRykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoal9WQVJBUkcgPCBuX1ZBUkFSRykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgLSBuX1ZBUkFSRyArIGpfVkFSQVJHXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhICsgal9WQVJBUkddLnIgPSBzcmMucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhICsgal9WQVJBUkddLmQgPSBzcmMuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3RoaXMuX2Jhc2UgKyBhICsgal9WQVJBUkddLnIgPSBMdWEuTklMO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gLyogc3dpdGNoICovXHJcbiAgICAgICAgICAgICAgICB9IC8qIHdoaWxlICovXHJcbiAgICAgICAgICAgIH0gLyogcmVlbnRyeTogd2hpbGUgKi9cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGlOdW1wb3coYSwgYikge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogdGhpcyBuZWVkcyBwcm9wZXIgY2hlY2tpbmcgZm9yIGJvdW5kYXJ5IGNhc2VzXHJcbiAgICAgICAgICAgIC8vIEVHLCBpcyBjdXJyZW50bHkgd3JvbmcgZm9yICgtMCleMi5cclxuICAgICAgICAgICAgdmFyIGludmVydCA9IGIgPCAwLjA7XHJcbiAgICAgICAgICAgIGlmIChpbnZlcnQpXHJcbiAgICAgICAgICAgICAgICBiID0gLWI7XHJcbiAgICAgICAgICAgIGlmIChhID09IDAuMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnZlcnQgPyBOYU4gOiBhO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMS4wO1xyXG4gICAgICAgICAgICB2YXIgaXBvdyA9IGI7XHJcbiAgICAgICAgICAgIGIgLT0gaXBvdztcclxuICAgICAgICAgICAgdmFyIHQgPSBhO1xyXG4gICAgICAgICAgICB3aGlsZSAoaXBvdyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICgoaXBvdyAmIDEpICE9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICo9IHQ7XHJcbiAgICAgICAgICAgICAgICBpcG93ID4+PSAxO1xyXG4gICAgICAgICAgICAgICAgdCA9IHQgKiB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiICE9IDAuMCkgLy8gaW50ZWdlciBvbmx5IGNhc2UsIHNhdmUgZG9pbmcgdW5uZWNlc3Nhcnkgd29ya1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPCAwLjApIC8vIGRvZXNuJ3Qgd29yayBpZiBhIG5lZ2F0aXZlIChjb21wbGV4IHJlc3VsdCEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICAgICAgICAgIHQgPSBNYXRoLnNxcnQoYSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZiA9IDAuNTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChiID4gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgPj0gaGFsZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKiB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiIC09IGhhbGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBiICsgYjtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gTWF0aC5zcXJ0KHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IDEuMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGludmVydCA/IDEuMCAvIHJlc3VsdCA6IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgb2YgbHVhVl9nZXR0YWJsZS4gKi9cclxuICAgICAgICB2bUdldHRhYmxlKHQsIGtleSwgdmFsKSB7XHJcbiAgICAgICAgICAgIHZhciB0bTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbG9vcCA9IDA7IGxvb3AgPCBMdWEuTUFYVEFHTE9PUDsgKytsb29wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIEx1YVRhYmxlXzEuTHVhVGFibGUpIC8vICd0JyBpcyBhIHRhYmxlP1xyXG4gICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaC5fX2dldGx1YShrZXksIEx1YS5TUEFSRV9TTE9UKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTHVhLlNQQVJFX1NMT1QuciAhPSBMdWEuTklMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5yID0gTHVhLlNQQVJFX1NMT1QucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsLmQgPSBMdWEuU1BBUkVfU0xPVC5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRtID0gdGhpcy50YWdtZXRob2QoaCwgXCJfX2luZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bSA9PSBMdWEuTklMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5yID0gTHVhLk5JTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHdpbGwgdHJ5IHRoZSB0YWcgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0bSA9IHRoaXMudGFnbWV0aG9kKHQsIFwiX19pbmRleFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG0gPT0gTHVhLk5JTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nVHlwZWVycm9yKHQsIFwiaW5kZXhcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhLmlzRnVuY3Rpb24odG0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTHVhLlNQQVJFX1NMT1Quc2V0T2JqZWN0KHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRNcmVzKHZhbCwgdG0sIEx1YS5TUEFSRV9TTE9ULCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHQgPSB0bTsgLy8gZWxzZSByZXBlYXQgd2l0aCAndG0nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5nUnVuZXJyb3IoXCJsb29wIGluIGdldHRhYmxlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCBvZiBsdWFWX2xlc3N0aGFuLiAqL1xyXG4gICAgICAgIHZtTGVzc3RoYW4obCwgcikge1xyXG4gICAgICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgICAgIC8vaWYgKGwuci5nZXRDbGFzcygpICE9IHIuci5nZXRDbGFzcygpKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChsLnIpICE9IHR5cGVvZiAoci5yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nT3JkZXJlcnJvcihsLCByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsLnIgPT0gTHVhLk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwuZCA8IHIuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsLnIgaW5zdGFuY2VvZiBTdHJpbmcgfHwgKHR5cGVvZiAobC5yKSA9PSAnc3RyaW5nJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBQVUMtUmlvIHVzZSBzdHJjb2xsLCBtYXliZSB3ZSBzaG91bGQgdXNlIHNvbWV0aGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gZXF1aXZhbGVudC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBsLnIgPCByLnI7IC8vVE9ETzpjb21wYXJlVG9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5jYWxsX29yZGVyVE0obCwgciwgXCJfX2x0XCIpO1xyXG4gICAgICAgICAgICBpZiAocmVzID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMgIT0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nT3JkZXJlcnJvcihsLCByKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgb2YgbHVhVl9sZXNzZXF1YWwuICovXHJcbiAgICAgICAgdm1MZXNzZXF1YWwobCwgcikge1xyXG4gICAgICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgICAgIC8vaWYgKGwuci5nZXRDbGFzcygpICE9IHIuci5nZXRDbGFzcygpKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChsLnIpICE9IHR5cGVvZiAoci5yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nT3JkZXJlcnJvcihsLCByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsLnIgPT0gTHVhLk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwuZCA8PSByLmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobC5yIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiAobC5yKSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwuciA8PSByLnI7IC8vVE9ETzogQ29tcGFyZVRvXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuY2FsbF9vcmRlclRNKGwsIHIsIFwiX19sZVwiKTsgLy8gZmlyc3QgdHJ5ICdsZSdcclxuICAgICAgICAgICAgaWYgKHJlcyA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzICE9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzID0gdGhpcy5jYWxsX29yZGVyVE0ociwgbCwgXCJfX2x0XCIpOyAvLyBlbHNlIHRyeSAnbHQnXHJcbiAgICAgICAgICAgIGlmIChyZXMgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyA9PSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdPcmRlcmVycm9yKGwsIHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcXVpdmFsZW50IG9mIGx1YURfcG9zY2FsbC5cclxuICAgICAgICAgKiBAcGFyYW0gZmlyc3RSZXN1bHQgIHN0YWNrIGluZGV4IChhYnNvbHV0ZSkgb2YgdGhlIGZpcnN0IHJlc3VsdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZtUG9zY2FsbChmaXJzdFJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogY2FsbCBob29rXHJcbiAgICAgICAgICAgIHZhciBsY2k7IC8vIGxvY2FsIGNvcHksIGZvciBmYXN0ZXIgYWNjZXNzXHJcbiAgICAgICAgICAgIGxjaSA9IHRoaXMuZGVjX2NpKCk7XHJcbiAgICAgICAgICAgIC8vIE5vdyAoYXMgYSByZXN1bHQgb2YgdGhlIGRlY19jaSBjYWxsKSwgbGNpIGlzIHRoZSBDYWxsSW5mbyByZWNvcmRcclxuICAgICAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IGZ1bmN0aW9uICh0aGUgZnVuY3Rpb24gZXhlY3V0aW5nIGFuIE9QX1JFVFVSTlxyXG4gICAgICAgICAgICAvLyBpbnN0cnVjdGlvbiksIGFuZCB0aGlzLmNpIGlzIHRoZSBDYWxsSW5mbyByZWNvcmQgZm9yIHRoZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgcmV0dXJuaW5nIHRvLlxyXG4gICAgICAgICAgICB2YXIgcmVzID0gbGNpLnJlcygpO1xyXG4gICAgICAgICAgICB2YXIgd2FudGVkID0gbGNpLm5yZXN1bHRzOyAvLyBDYXV0aW9uOiB3YW50ZWQgY291bGQgYmUgPT0gTVVMVFJFVFxyXG4gICAgICAgICAgICB2YXIgY2NpID0gdGhpcy5fX2NpKCk7IC8vIENvbnRpbnVhdGlvbiBDYWxsSW5mb1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlID0gY2NpLmJhc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkcGMgPSBjY2kuc2F2ZWRwYztcclxuICAgICAgICAgICAgLy8gTW92ZSByZXN1bHRzIChhbmQgcGFkIHdpdGggbmlscyB0byByZXF1aXJlZCBudW1iZXIgaWYgbmVjZXNzYXJ5KVxyXG4gICAgICAgICAgICB2YXIgaSA9IHdhbnRlZDtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuX3N0YWNrU2l6ZTtcclxuICAgICAgICAgICAgLy8gVGhlIG1vdmVtZW50IGlzIGFsd2F5cyBkb3dud2FyZHMsIHNvIGNvcHlpbmcgZnJvbSB0aGUgdG9wLW1vc3RcclxuICAgICAgICAgICAgLy8gcmVzdWx0IGZpcnN0IGlzIGFsd2F5cyBjb3JyZWN0LlxyXG4gICAgICAgICAgICB3aGlsZSAoaSAhPSAwICYmIGZpcnN0UmVzdWx0IDwgdG9wKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tyZXNdLnIgPSB0aGlzLl9zdGFja1tmaXJzdFJlc3VsdF0ucjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3Jlc10uZCA9IHRoaXMuX3N0YWNrW2ZpcnN0UmVzdWx0XS5kO1xyXG4gICAgICAgICAgICAgICAgKytyZXM7XHJcbiAgICAgICAgICAgICAgICArK2ZpcnN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUocmVzICsgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gOnRvZG86IGNvbnNpZGVyIHVzaW5nIHR3byBzdGFja3NldHNpemUgY2FsbHMgdG8gbmlsIG91dFxyXG4gICAgICAgICAgICAvLyByZW1haW5pbmcgcmVxdWlyZWQgcmVzdWx0cy5cclxuICAgICAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW3JlcysrXS5yID0gTHVhLk5JTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZShyZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gd2FudGVkICE9IEx1YS5NVUxUUkVUO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEVxdWl2YWxlbnQgb2YgTHVhRF9wcmVjYWxsLiAgVGhpcyBtZXRob2QgZXhwZWN0cyB0aGF0IHRoZSBhcmd1bWVudHNcclxuICAgICAgICAqIHRvIHRoZSBmdW5jdGlvbiBhcmUgcGxhY2VkIGFib3ZlIHRoZSBmdW5jdGlvbiBvbiB0aGUgc3RhY2suXHJcbiAgICAgICAgKiBAcGFyYW0gZnVuYyAgYWJzb2x1dGUgc3RhY2sgaW5kZXggb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgICAgKiBAcGFyYW0gciAgICAgbnVtYmVyIG9mIHJlc3VsdHMgZXhwZWN0ZWQuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB2bVByZWNhbGwoZnVuYywgcikge1xyXG4gICAgICAgICAgICB2YXIgZmFzbzsgLy8gRnVuY3Rpb24gQVMgT2JqZWN0XHJcbiAgICAgICAgICAgIGZhc28gPSB0aGlzLl9zdGFja1tmdW5jXS5yO1xyXG4gICAgICAgICAgICBpZiAoIUx1YS5pc0Z1bmN0aW9uKGZhc28pKSB7XHJcbiAgICAgICAgICAgICAgICBmYXNvID0gdGhpcy50cnlmdW5jVE0oZnVuYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fX2NpKCkuc2F2ZWRwYyA9IHRoaXMuX3NhdmVkcGM7XHJcbiAgICAgICAgICAgIGlmIChmYXNvIGluc3RhbmNlb2YgTHVhRnVuY3Rpb25fMS5MdWFGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmYXNvO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBmLnByb3RvO1xyXG4gICAgICAgICAgICAgICAgLy8gOnRvZG86IGVuc3VyZSBlbm91Z2ggc3RhY2tcclxuICAgICAgICAgICAgICAgIGlmICghcC5pc1ZhcmFyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2UgPSBmdW5jICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhY2tTaXplID4gdGhpcy5fYmFzZSArIHAubnVtcGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaW0gc3RhY2sgdG8gdGhlIGFyZ3VtZW50IGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja3NldHNpemUodGhpcy5fYmFzZSArIHAubnVtcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFyZ3MgPSAodGhpcy5fc3RhY2tTaXplIC0gZnVuYykgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2UgPSB0aGlzLmFkanVzdF92YXJhcmdzKHAsIG5hcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLl9iYXNlICsgcC5tYXhzdGFja3NpemU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY19jaShmdW5jLCB0aGlzLl9iYXNlLCB0b3AsIHIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRwYyA9IDA7XHJcbiAgICAgICAgICAgICAgICAvLyBleHBhbmQgc3RhY2sgdG8gdGhlIGZ1bmN0aW9uJ3MgbWF4IHN0YWNrIHNpemUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZSh0b3ApO1xyXG4gICAgICAgICAgICAgICAgLy8gOnRvZG86IGltcGxlbWVudCBjYWxsIGhvb2suXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTHVhLlBDUkxVQTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmYXNvIGluc3RhbmNlb2YgTHVhSmF2YUNhbGxiYWNrXzEuTHVhSmF2YUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmogPSBmYXNvO1xyXG4gICAgICAgICAgICAgICAgLy8gOnRvZG86IGNoZWNrc3RhY2sgKG5vdCBzdXJlIGl0J3MgbmVjZXNzYXJ5KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFzZSA9IGZ1bmMgKyAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNfY2koZnVuYywgdGhpcy5fYmFzZSwgdGhpcy5fc3RhY2tTaXplICsgTHVhLk1JTlNUQUNLLCByKTtcclxuICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBjYWxsIGhvb2tcclxuICAgICAgICAgICAgICAgIHZhciBuID0gOTk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBmai5sdWFGdW5jdGlvbih0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlMSBpbnN0YW5jZW9mIEx1YUVycm9yXzEuTHVhRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZTEuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZTEgaW5zdGFuY2VvZiBSdW50aW1lRXhjZXB0aW9uXzEuUnVudGltZUV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlMS5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWllbGQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGUxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuIDwgMCkgLy8geWllbGRpbmc/XHJcbiAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMdWEuUENSWUlFTEQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZtUG9zY2FsbCh0aGlzLl9zdGFja1NpemUgLSBuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTHVhLlBDUko7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLklsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCBvZiBsdWFWX3NldHRhYmxlLiAqL1xyXG4gICAgICAgIHZtU2V0dGFibGUodCwga2V5LCB2YWwpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbG9vcCA9IDA7IGxvb3AgPCBMdWEuTUFYVEFHTE9PUDsgKytsb29wKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG07XHJcbiAgICAgICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIEx1YVRhYmxlXzEuTHVhVGFibGUpIC8vICd0JyBpcyBhIHRhYmxlXHJcbiAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gdDtcclxuICAgICAgICAgICAgICAgICAgICBoLl9fZ2V0bHVhKGtleSwgTHVhLlNQQVJFX1NMT1QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChMdWEuU1BBUkVfU0xPVC5yICE9IEx1YS5OSUwpIC8vIHJlc3VsdCBpcyBub3QgbmlsP1xyXG4gICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgucHV0bHVhU2xvdCh0aGlzLCBrZXksIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG0gPSB0aGlzLnRhZ21ldGhvZChoLCBcIl9fbmV3aW5kZXhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtID09IEx1YS5OSUwpIC8vIG9yIG5vIFRNP1xyXG4gICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgucHV0bHVhU2xvdCh0aGlzLCBrZXksIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB3aWxsIHRyeSB0aGUgdGFnIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG0gPSB0aGlzLnRhZ21ldGhvZCh0LCBcIl9fbmV3aW5kZXhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtID09IEx1YS5OSUwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ1R5cGVlcnJvcih0LCBcImluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKEx1YS5pc0Z1bmN0aW9uKHRtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRNKHRtLCB0LCBrZXksIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdCA9IHRtOyAvLyBlbHNlIHJlcGVhdCB3aXRoICd0bSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdSdW5lcnJvcihcImxvb3AgaW4gc2V0dGFibGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyB2bVRvc3RyaW5nKG8pIHtcclxuICAgICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIChvKSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIE51bWJlcikgfHwgdHlwZW9mIChvKSA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29udmVydCBudW1iZXIgdG8gc3RyaW5nLiAgUFVDLVJpbyBhYnN0cmFjdHMgdGhpcyBvcGVyYXRpb24gaW50b1xyXG4gICAgICAgICAgICAvLyBhIG1hY3JvLCBsdWFfbnVtYmVyMnN0ci4gIFRoZSBtYWNybyBpcyBvbmx5IGludm9rZWQgZnJvbSB0aGVpclxyXG4gICAgICAgICAgICAvLyBlcXVpdmFsZW50IG9mIHRoaXMgY29kZS5cclxuICAgICAgICAgICAgLy8gRm9ybWVybHkgdGhpcyBjb2RlIHVzZWQgRG91YmxlLnRvU3RyaW5nIChhbmQgcmVtb3ZlIGFueSB0cmFpbGluZ1xyXG4gICAgICAgICAgICAvLyBcIi4wXCIpIGJ1dCB0aGlzIGRvZXMgbm90IGdpdmUgYW4gYWNjdXJhdGUgZW11bGF0aW9uIG9mIHRoZSBQVUMtUmlvXHJcbiAgICAgICAgICAgIC8vIGJlaGF2aW91ciB3aGljaCBJbnR1d2F2ZSByZXF1aXJlLiAgU28gbm93IHdlIHVzZSBcIiUuMTRnXCIgbGlrZVxyXG4gICAgICAgICAgICAvLyBQVUMtUmlvLlxyXG4gICAgICAgICAgICAvLyA6dG9kbzogY29uc2lkZXIgb3B0aW1pc2F0aW9uIG9mIG1ha2luZyBGb3JtYXRJdGVtIGFuIGltbXV0YWJsZVxyXG4gICAgICAgICAgICAvLyBjbGFzcyBhbmQga2VlcGluZyBhIHN0YXRpYyByZWZlcmVuY2UgdG8gdGhlIHJlcXVpcmVkIGluc3RhbmNlXHJcbiAgICAgICAgICAgIC8vICh3aGljaCBuZXZlciBjaGFuZ2VzKS4gIEEgcG9zc2libGUgaGFsZi13YXkgaG91c2Ugd291bGQgYmUgdG9cclxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29waWVkIGluc3RhbmNlIGZyb20gYW4gYWxyZWFkeSBjcmVhdGUgcHJvdG90eXBlXHJcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIHdoaWNoIHdvdWxkIGJlIGZhc3RlciB0aGFuIHBhcnNpbmcgdGhlIGZvcm1hdCBzdHJpbmdcclxuICAgICAgICAgICAgLy8gZWFjaCB0aW1lLlxyXG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBGb3JtYXRJdGVtXzEuRm9ybWF0SXRlbShudWxsLCBMdWEuTlVNQkVSX0ZNVCk7XHJcbiAgICAgICAgICAgIHZhciBiID0gbmV3IFN0cmluZ0J1ZmZlcl8xLlN0cmluZ0J1ZmZlcigpO1xyXG4gICAgICAgICAgICB2YXIgZCA9IG87XHJcbiAgICAgICAgICAgIGYuZm9ybWF0RmxvYXQoYiwgZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBiLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IG9mIGFkanVzdF92YXJhcmdzIGluIFwibGRvLmNcIi4gKi9cclxuICAgICAgICBhZGp1c3RfdmFyYXJncyhwLCBhY3R1YWwpIHtcclxuICAgICAgICAgICAgdmFyIG5maXhhcmdzID0gcC5udW1wYXJhbXM7XHJcbiAgICAgICAgICAgIGZvciAoOyBhY3R1YWwgPCBuZml4YXJnczsgKythY3R1YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tBZGQoTHVhLk5JTCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUFVDLVJpbydzIExVQV9DT01QQVRfVkFSQVJHIGlzIG5vdCBzdXBwb3J0ZWQgaGVyZS5cclxuICAgICAgICAgICAgLy8gTW92ZSBmaXhlZCBwYXJhbWV0ZXJzIHRvIGZpbmFsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIHZhciBmaXhlZCA9IHRoaXMuX3N0YWNrU2l6ZSAtIGFjdHVhbDsgLy8gZmlyc3QgZml4ZWQgYXJndW1lbnRcclxuICAgICAgICAgICAgdmFyIG5ld2Jhc2UgPSB0aGlzLl9zdGFja1NpemU7IC8vIGZpbmFsIHBvc2l0aW9uIG9mIGZpcnN0IGFyZ3VtZW50XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmZpeGFyZ3M7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgLy8gOnRvZG86IGFycmF5Y29weT9cclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNsb3QodGhpcy5fc3RhY2tbZml4ZWQgKyBpXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tmaXhlZCArIGldLnIgPSBMdWEuTklMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdiYXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEb2VzIG5vdCBtb2RpZnkgY29udGVudHMgb2YgcDEgb3IgcDIuICBNb2RpZmllcyBjb250ZW50cyBvZiByZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHAxICBsZWZ0IGhhbmQgb3BlcmFuZC5cclxuICAgICAgICAgKiBAcGFyYW0gcDIgIHJpZ2h0IGhhbmQgb3BlcmFuZC5cclxuICAgICAgICAgKiBAcGFyYW0gcmVzIGFic29sdXRlIHN0YWNrIGluZGV4IG9mIHJlc3VsdC5cclxuICAgICAgICAgKiBAcmV0dXJuIGZhbHNlIGlmIG5vIHRhZ21ldGhvZCwgdHJ1ZSBvdGhlcndpc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBjYWxsX2JpblRNKHAxLCBwMiwgcmVzLCBldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdG0gPSB0aGlzLnRhZ21ldGhvZChwMS5hc09iamVjdCgpLCBldmVudCk7IC8vIHRyeSBmaXJzdCBvcGVyYW5kXHJcbiAgICAgICAgICAgIGlmIChMdWEuaXNOaWwodG0pKSB7XHJcbiAgICAgICAgICAgICAgICB0bSA9IHRoaXMudGFnbWV0aG9kKHAyLmFzT2JqZWN0KCksIGV2ZW50KTsgLy8gdHJ5IHNlY29uZCBvcGVyYW5kXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFMdWEuaXNGdW5jdGlvbih0bSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNhbGxUTXJlcyhyZXMsIHRtLCBwMSwgcDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJuIC0xIGlmIG5vIHRhZ21ldGhvZCwgMCBmYWxzZSwgMSB0cnVlXHJcbiAgICAgICAgKi9cclxuICAgICAgICBjYWxsX29yZGVyVE0ocDEsIHAyLCBldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdG0xID0gdGhpcy50YWdtZXRob2QocDEuYXNPYmplY3QoKSwgZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAodG0xID09IEx1YS5OSUwpIC8vIG5vdCBtZXRhbWV0aG9kXHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRtMiA9IHRoaXMudGFnbWV0aG9kKHAyLmFzT2JqZWN0KCksIGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFMdWEub1Jhd2VxdWFsKHRtMSwgdG0yKSkgLy8gZGlmZmVyZW50IG1ldGFtZXRob2RzP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbFRNcmVzKHMsIHRtMSwgcDEsIHAyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNGYWxzZShzLnIpID8gMCA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxUTShmLCBwMSwgcDIsIHAzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChmKTtcclxuICAgICAgICAgICAgdGhpcy5wdXNoT2JqZWN0KHAxKTtcclxuICAgICAgICAgICAgdGhpcy5wdXNoU2xvdChwMik7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaE9iamVjdChwMyk7XHJcbiAgICAgICAgICAgIHRoaXMudm1DYWxsKHRoaXMuX3N0YWNrU2l6ZSAtIDQsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsVE1yZXMocmVzLCBmLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoT2JqZWN0KGYpO1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hTbG90KHAxKTtcclxuICAgICAgICAgICAgdGhpcy5wdXNoU2xvdChwMik7XHJcbiAgICAgICAgICAgIHRoaXMudm1DYWxsKHRoaXMuX3N0YWNrU2l6ZSAtIDMsIDEpO1xyXG4gICAgICAgICAgICByZXMuciA9IHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrU2l6ZSAtIDFdLnI7XHJcbiAgICAgICAgICAgIHJlcy5kID0gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2tTaXplIC0gMV0uZDtcclxuICAgICAgICAgICAgdGhpcy5wb3AoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE92ZXJsb2FkZWQgdmVyc2lvbiBvZiBjYWxsVE1yZXMgdXNlZCBieSB7QGxpbmsgI3ZtRXF1YWxSZWZ9LlxyXG4gICAgICAgICAqIFRleHR1YWxsIGlkZW50aWNhbCwgYnV0IGEgZGlmZmVyZW50IChvdmVybG9hZGVkKSBwdXNoIG1ldGhvZCBpc1xyXG4gICAgICAgICAqIGludm9rZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19jYWxsVE1yZXMocmVzLCBmLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoT2JqZWN0KGYpO1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hPYmplY3QocDEpO1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hPYmplY3QocDIpO1xyXG4gICAgICAgICAgICB0aGlzLnZtQ2FsbCh0aGlzLl9zdGFja1NpemUgLSAzLCAxKTtcclxuICAgICAgICAgICAgcmVzLnIgPSB0aGlzLl9zdGFja1t0aGlzLl9zdGFja1NpemUgLSAxXS5yO1xyXG4gICAgICAgICAgICByZXMuZCA9IHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrU2l6ZSAtIDFdLmQ7XHJcbiAgICAgICAgICAgIHRoaXMucG9wKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRfY29tcFRNKG10MSwgbXQyLCBldmVudCkge1xyXG4gICAgICAgICAgICBpZiAobXQxID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMdWEuTklMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0bTEgPSBtdDEuZ2V0bHVhKGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKEx1YS5pc05pbCh0bTEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTHVhLk5JTDsgLy8gbm8gbWV0YW1ldGhvZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtdDEgPT0gbXQyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG0xOyAvLyBzYW1lIG1ldGF0YWJsZXMgPT4gc2FtZSBtZXRhbWV0aG9kc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtdDIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEx1YS5OSUw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRtMiA9IG10Mi5nZXRsdWEoZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoTHVhLmlzTmlsKHRtMikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMdWEuTklMOyAvLyBubyBtZXRhbWV0aG9kXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEx1YS5vUmF3ZXF1YWwodG0xLCB0bTIpKSAvLyBzYW1lIG1ldGFtZXRob2RzP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTHVhLk5JTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBHZXRzIHRhZ21ldGhvZCBmb3Igb2JqZWN0LlxyXG4gICAgICAgICogQHJldHVybiBtZXRob2Qgb3IgbmlsLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGFnbWV0aG9kKG8sIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFmaWVsZChvLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCBETyBOT1QgQ0FMTCAqL1xyXG4gICAgICAgIF9fdGFnbWV0aG9kKG8sIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJ0YWdtZXRob2QgY2FsbGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIENvbXB1dGVzIHRoZSByZXN1bHQgb2YgTHVhJ3MgbW9kdWxlcyBvcGVyYXRvciAoJSkuICBOb3RlIHRoYXQgdGhpc1xyXG4gICAgICAgICogbW9kdWx1cyBvcGVyYXRvciBkb2VzIG5vdCBtYXRjaCBKYXZhJ3MgJS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBfX21vZHVsdXMoeCwgeSkge1xyXG4gICAgICAgICAgICByZXR1cm4geCAtIE1hdGguZmxvb3IoeCAvIHkpICogeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBDaGFuZ2VzIHRoZSBzdGFjayBzaXplLCBwYWRkaW5nIHdpdGggTklMIHdoZXJlIG5lY2Vzc2FyeSwgYW5kXHJcbiAgICAgICAgKiBhbGxvY2F0ZSBhIG5ldyBzdGFjayBhcnJheSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBzdGFja3NldHNpemUobikge1xyXG4gICAgICAgICAgICBpZiAobiA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhLkQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN0YWNrc2V0c2l6ZTpcIiArIG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vMjAxNzA0MDI6YWRkZWRcclxuICAgICAgICAgICAgaWYgKG4gPT0gNykge1xyXG4gICAgICAgICAgICAgICAgaWYgKEx1YS5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCI+Pj5zdGFja3NldHNpemU6XCIgKyBuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJdCBpcyBhYnNvbHV0ZWx5IGNyaXRpY2FsIHRoYXQgd2hlbiB0aGUgc3RhY2sgY2hhbmdlcyBzaXplcyB0aG9zZVxyXG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBjb21tb24gdG8gYm90aCBvbGQgYW5kIG5ldyBzdGFjayBhcmUgdW5jaGFuZ2VkLlxyXG4gICAgICAgICAgICAvLyBGaXJzdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHNpbXBseSBlbnN1cmVzIHRoYXQgdGhlIHN0YWNrIGFycmF5XHJcbiAgICAgICAgICAgIC8vIGhhcyBhdCBsZWFzdCB0aGUgcmVxdWlyZWQgc2l6ZSBudW1iZXIgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBjb25zaWRlciBwb2xpY2llcyB3aGVyZSB0aGUgc3RhY2sgbWF5IGFsc28gc2hyaW5rLlxyXG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5fc3RhY2tTaXplO1xyXG4gICAgICAgICAgICBpZiAobiA+IHRoaXMuX3N0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy/ku6Uy5YCN6YCf5bqm5aKe5Yqg5aCG5qCI55qE5rex5bqmXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3TGVuZ3RoID0gTWF0aC5tYXgobiwgMiAqIHRoaXMuX3N0YWNrLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3RhY2sgPSBuZXcgQXJyYXkobmV3TGVuZ3RoKTsgLy9TbG90W10gXHJcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgdGhlIHN0YWNrIG9ubHkgZXZlciBncm93cywgc28gdGhlIG51bWJlciBvZiBpdGVtcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8gY29weSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBvbGQgc3RhY2suXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9Db3B5ID0gdGhpcy5fc3RhY2subGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuYXJyYXljb3B5KHRoaXMuX3N0YWNrLCAwLCBuZXdTdGFjaywgMCwgdG9Db3B5KTtcclxuICAgICAgICAgICAgICAgIC8vdHJhY2UobmV3U3RhY2tbMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2sgPSBuZXdTdGFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zdGFja1NpemUgPSBuO1xyXG4gICAgICAgICAgICAvLyBOaWxsaW5nIG91dC4gIFRoZSBWTSByZXF1aXJlcyB0aGF0IGZyZXNoIHN0YWNrIHNsb3RzIGFsbG9jYXRlZFxyXG4gICAgICAgICAgICAvLyBmb3IgYSBuZXcgZnVuY3Rpb24gYWN0aXZhdGlvbiBhcmUgaW5pdGlhbGlzZWQgdG8gbmlsICh3aGljaCBpc1xyXG4gICAgICAgICAgICAvLyBMdWEuTklMLCB3aGljaCBpcyBub3QgSmF2YSBudWxsKS5cclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIGJhc2ljYWxseSB0d28gYXBwcm9hY2hlczogbmlsIG91dCB3aGVuIHRoZSBzdGFjayBncm93cyxcclxuICAgICAgICAgICAgLy8gb3IgbmlsIG91dCB3aGVuIGl0IHNocmlua3MuICBOaWxsaW5nIG91dCB3aGVuIHRoZSBzdGFjayBncm93cyBpc1xyXG4gICAgICAgICAgICAvLyBzbGlnaHRseSBzaW1wbGVyLCBidXQgbmlsbGluZyBvdXQgd2hlbiB0aGUgc3RhY2sgc2hyaW5rcyBtZWFuc1xyXG4gICAgICAgICAgICAvLyB0aGF0IHNlbWFudGljIGdhcmJhZ2UgaXMgbm90IHJldGFpbmVkIGJ5IHRoZSBHQy5cclxuICAgICAgICAgICAgLy8gV2UgbmlsIG91dCBzbG90cyB3aGVuIHRoZSBzdGFjayBzaHJpbmtzLCBidXQgd2UgYWxzbyBuZWVkIHRvIG1ha2VcclxuICAgICAgICAgICAgLy8gc3VyZSB0aGV5IGFyZSBuaWwgaW5pdGlhbGx5LlxyXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBhdm9pZCBuaWxsaW5nIHRoZSBlbnRpcmUgYXJyYXkgd2hlbiB3ZSBhbGxvY2F0ZSBvbmVcclxuICAgICAgICAgICAgLy8gd2UgbWFpbnRhaW4gYSBzdGFja2hpZ2h3YXRlciB3aGljaCBpcyAxIG1vcmUgdGhhbiB0aGF0IGxhcmdlc3RcclxuICAgICAgICAgICAgLy8gc3RhY2sgc2xvdCB0aGF0IGhhcyBiZWVuIG5pbGxlZC4gIFdlIHVzZSB0aGlzIHRvIG5pbCBvdXQgc3RhY2tzXHJcbiAgICAgICAgICAgIC8vIHNsb3cgd2hlbiB3ZSBncm93LlxyXG4gICAgICAgICAgICBpZiAobiA8PSBvbGQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gc2hyaW5raW5nXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA8IG9sZDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbaV0uciA9IEx1YS5OSUw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG4gPiB0aGlzLl9zdGFja2hpZ2h3YXRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBncm93aW5nIGFib3ZlIHN0YWNraGlnaHdhdGVyIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gdGhpcy5fc3RhY2toaWdod2F0ZXI7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tpXSA9IG5ldyBTbG90XzEuU2xvdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW2ldLnIgPSBMdWEuTklMO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2toaWdod2F0ZXIgPSBuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFB1c2hlcyBhIEx1YSB2YWx1ZSBvbnRvIHRoZSBzdGFjay5cclxuICAgICAgICAgKiDljovlhaXkuIDkuKpMdWHlgLzov5vloIbmoIhcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGFja0FkZChvKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fc3RhY2tTaXplO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZShpICsgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrW2ldLnNldE9iamVjdChvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29waWVzIGEgc2xvdCBpbnRvIGEgbmV3IHNwYWNlIGluIHRoZSBzdGFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXNoU2xvdChwKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fc3RhY2tTaXplO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrc2V0c2l6ZShpICsgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrW2ldLnIgPSBwLnI7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrW2ldLmQgPSBwLmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YWNrSW5zZXJ0QXQobywgaSkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX3N0YWNrU2l6ZSAtIGk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tzZXRzaXplKHRoaXMuX3N0YWNrU2l6ZSArIDEpO1xyXG4gICAgICAgICAgICAvLyBDb3B5IGVhY2ggc2xvdCBOIGludG8gaXRzIG5laWdoYm91ciBOKzEuICBMb29wIHByb2NlZWRzIGZyb20gaGlnaFxyXG4gICAgICAgICAgICAvLyBpbmRleCBzbG90cyB0byBsb3dlciBpbmRleCBzbG90cy5cclxuICAgICAgICAgICAgLy8gQSBsb29wIGZyb20gbiB0byAxIGNvcGllcyBuIHNsb3RzLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gbjsgaiA+PSAxOyAtLWopIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrW2kgKyBqXS5yID0gdGhpcy5fc3RhY2tbaSArIGogLSAxXS5yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbaSArIGpdLmQgPSB0aGlzLl9zdGFja1tpICsgaiAtIDFdLmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tbaV0uc2V0T2JqZWN0KG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEVxdWl2YWxlbnQgb2YgbWFjcm8gaW4gbGRlYnVnLmguXHJcbiAgICAgICAgKi9cclxuICAgICAgICByZXNldGhvb2tjb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy5faG9va2NvdW50ID0gdGhpcy5fYmFzZWhvb2tjb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXF1aXZhbGVudCBvZiB0cmFjZWV4ZWMgaW4gbHZtLmMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJhY2VleGVjKHBjKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXNrID0gdGhpcy5faG9va21hc2s7XHJcbiAgICAgICAgICAgIHZhciBvbGRwYyA9IHRoaXMuX3NhdmVkcGM7XHJcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkcGMgPSBwYztcclxuICAgICAgICAgICAgaWYgKG1hc2sgPiBMdWEuTUFTS0xJTkUpIC8vIGluc3RydWN0aW9uLWhvb2sgc2V0P1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvb2tjb3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldGhvb2tjb3VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZENhbGxob29rKEx1YS5IT09LQ09VTlQsIC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA6dG9kbzogbGluZSBob29rLlxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIENvbnZlcnQgdG8gbnVtYmVyLiAgUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCA8dmFyPm88L3Zhcj4gd2FzXHJcbiAgICAgICAgKiBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuICBDb252ZXJ0ZWQgbnVtYmVyIGlzIHBsYWNlZCBpbiA8dmFyPm91dFswXTwvdmFyPi5cclxuICAgICAgICAqIFJldHVybnNcclxuICAgICAgICAqIGZhbHNlIGlmIHRoZSBhcmd1bWVudCA8dmFyPm88L3Zhcj4gY291bGQgbm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlci5cclxuICAgICAgICAqIE92ZXJsb2FkZWQuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgdG9udW1iZXIobywgb3V0IC8qZG91YmxlW10gKi8pIHtcclxuICAgICAgICAgICAgaWYgKG8uciA9PSBMdWEuTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSBvLmQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShvLnIgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIChvLnIpID09ICdzdHJpbmcnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChMdWEub1N0cjJkKG8uciwgb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHN0YWNrIHNsb3QgdG8gbnVtYmVyLiAgUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGF0XHJcbiAgICAgICAgICogdGhlIHNwZWNpZmllZCBzdGFjayBzbG90IHdhcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuICBGYWxzZVxyXG4gICAgICAgICAqIG90aGVyd2lzZS4gIE5vdGUgdGhhdCB0aGlzIGFjdHVhbGx5IG1vZGlmaWVzIHRoZSBlbGVtZW50IHN0b3JlZCBhdFxyXG4gICAgICAgICAqIDx2YXI+aWR4PC92YXI+IGluIHRoZSBzdGFjayAoaW4gZmFpdGhmdWwgZW11bGF0aW9uIG9mIHRoZSBQVUMtUmlvXHJcbiAgICAgICAgICogY29kZSkuICBDb3JydXB0cyA8Y29kZT5OVU1PUFswXTwvY29kZT4uICBPdmVybG9hZGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBpZHggIGFic29sdXRlIHN0YWNrIHNsb3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9udW1iZXIoaWR4KSB7XHJcbiAgICAgICAgICAgIGlmIChMdWEudG9udW1iZXIodGhpcy5fc3RhY2tbaWR4XSwgTHVhLk5VTU9QKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbaWR4XS5kID0gTHVhLk5VTU9QWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbaWR4XS5yID0gTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydCBhIHBhaXIgb2Ygb3BlcmFuZHMgZm9yIGFuIGFyaXRobWV0aWMgb3Bjb2RlLiAgU3RvcmVzXHJcbiAgICAgICAgICogY29udmVydGVkIHJlc3VsdHMgaW4gPGNvZGU+b3V0WzBdPC9jb2RlPiBhbmQgPGNvZGU+b3V0WzFdPC9jb2RlPi5cclxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYW5kIG9ubHkgaWYgYm90aCB2YWx1ZXMgY29udmVydGVkIHRvIG51bWJlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgdG9OdW1iZXJQYWlyKHgsIHksIG91dCAvKmRvdWJsZVtdICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRvbnVtYmVyKHksIG91dCkpIHtcclxuICAgICAgICAgICAgICAgIG91dFsxXSA9IG91dFswXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvbnVtYmVyKHgsIG91dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnQgdG8gc3RyaW5nLiAgUmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgd2FzIG51bWJlciBvciBzdHJpbmdcclxuICAgICAgICAgKiAodGhlIG51bWJlciB3aWxsIGhhdmUgYmVlbiBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcpLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICogTm90ZSB0aGlzIGFjdHVhbGx5IG1vZGlmaWVzIHRoZSBlbGVtZW50IHN0b3JlZCBhdCA8dmFyPmlkeDwvdmFyPiBpblxyXG4gICAgICAgICAqIHRoZSBzdGFjayAoaW4gZmFpdGhmdWwgZW11bGF0aW9uIG9mIHRoZSBQVUMtUmlvIGNvZGUpLCBhbmQgd2hlbiBpdFxyXG4gICAgICAgICAqIHJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4sIDxjb2RlPnN0YWNrW2lkeF0uciBpbnN0YW5jZW9mIFN0cmluZzwvY29kZT5cclxuICAgICAgICAgKiBpcyB0cnVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvc3RyaW5nKGlkeCkge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogb3B0aW1pc2VcclxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9iamVjdEF0KGlkeCk7XHJcbiAgICAgICAgICAgIHZhciBzID0gTHVhLnZtVG9zdHJpbmcobyk7XHJcbiAgICAgICAgICAgIGlmIChzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zdGFja1tpZHhdLnIgPSBzO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXF1aXZhbGVudCB0byB0cnlmdW5jVE0gZnJvbSBsZG8uYy5cclxuICAgICAgICAgKiBAcGFyYW0gZnVuYyAgYWJzb2x1dGUgc3RhY2sgaW5kZXggb2YgdGhlIGZ1bmN0aW9uIG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0cnlmdW5jVE0oZnVuYykge1xyXG4gICAgICAgICAgICB2YXIgdG0gPSB0aGlzLnRhZ21ldGhvZCh0aGlzLl9zdGFja1tmdW5jXS5hc09iamVjdCgpLCBcIl9fY2FsbFwiKTtcclxuICAgICAgICAgICAgaWYgKCFMdWEuaXNGdW5jdGlvbih0bSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ1R5cGVlcnJvcih0aGlzLl9zdGFja1tmdW5jXSwgXCJjYWxsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tJbnNlcnRBdCh0bSwgZnVuYyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEx1YSdzIGlzIEZhbHNlIHByZWRpY2F0ZS4gKi9cclxuICAgICAgICBpc0ZhbHNlKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8gPT0gTHVhLk5JTCB8fCBvID09IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgRE8gTk9UIENBTEwuICovXHJcbiAgICAgICAgX19pc0ZhbHNlKG8pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLklsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcImlzRmFsc2UgY2FsbGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogTWFrZSBuZXcgQ2FsbEluZm8gcmVjb3JkLiAqL1xyXG4gICAgICAgIGluY19jaShmdW5jLCBiYXNlQXJnLCB0b3AsIG5yZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHZhciBjaSA9IG5ldyBDYWxsSW5mb18xLkNhbGxJbmZvKCk7XHJcbiAgICAgICAgICAgIGNpLmluaXQoZnVuYywgYmFzZUFyZywgdG9wLCBucmVzdWx0cyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Npdi5hZGRFbGVtZW50KGNpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogUG9wIHRvcG1vc3QgQ2FsbEluZm8gcmVjb3JkIGFuZCByZXR1cm4gaXQuICovXHJcbiAgICAgICAgZGVjX2NpKCkge1xyXG4gICAgICAgICAgICB2YXIgY2kgPSB0aGlzLl9jaXYucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEVxdWl2YWxlbnQgdG8gcmVzdW1lX2Vycm9yIGZyb20gbGRvLmMgKi9cclxuICAgICAgICByZXN1bWVfZXJyb3IobXNnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tzZXRzaXplKHRoaXMuX19jaSgpLmJhc2UpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrQWRkKG1zZyk7XHJcbiAgICAgICAgICAgIHJldHVybiBMdWEuRVJSUlVOO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIHN0YWNrIGVsZW1lbnQgYXMgYW4gT2JqZWN0LiAgQ29udmVydHMgZG91YmxlIHZhbHVlcyBpbnRvXHJcbiAgICAgICAgICogRG91YmxlIG9iamVjdHMuXHJcbiAgICAgICAgICogQHBhcmFtIGlkeCAgYWJzb2x1dGUgaW5kZXggaW50byBzdGFjayAoMCA8PSBpZHggPCBzdGFja1NpemUpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iamVjdEF0KGlkeCkge1xyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuX3N0YWNrW2lkeF0ucjtcclxuICAgICAgICAgICAgaWYgKHIgIT0gTHVhLk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXIodGhpcy5fc3RhY2tbaWR4XS5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgc3RhY2sgZWxlbWVudC4gIERvdWJsZSBpbnN0YW5jZXMgYXJlIGNvbnZlcnRlZCB0byBkb3VibGUuXHJcbiAgICAgICAgICogQHBhcmFtIG8gIE9iamVjdCB0byBzdG9yZS5cclxuICAgICAgICAgKiBAcGFyYW0gaWR4ICBhYnNvbHV0ZSBpbmRleCBpbnRvIHN0YWNrICgwIDw9IGlkeCA8IHN0YWNrU2l6ZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0T2JqZWN0QXQobywgaWR4KSB7XHJcbiAgICAgICAgICAgIGlmIChvIGluc3RhbmNlb2YgTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFja1tpZHhdLnIgPSBMdWEuTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbaWR4XS5kID0gbztcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTHVhLkQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2V0T2JqZWN0QXQobywgXCIgKyBpZHggKyBcIikgZnJvbSBcIiArIHRoaXMuX3N0YWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zdGFja1tpZHhdLnIgPSBvO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3JyZXNwb25kcyB0byBsZHVtcCdzIGx1YVVfZHVtcCBtZXRob2QsIGJ1dCB3aXRoIGRhdGEgZ29uZSBhbmQgd3JpdGVyXHJcbiAgICAgICAgICogcmVwbGFjZWQgYnkgT3V0cHV0U3RyZWFtLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyB1RHVtcChmLCB3cml0ZXIsIHN0cmlwKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gbmV3IER1bXBTdGF0ZV8xLkR1bXBTdGF0ZShuZXcgRGF0YU91dHB1dFN0cmVhbV8xLkRhdGFPdXRwdXRTdHJlYW0od3JpdGVyKSwgc3RyaXApO1xyXG4gICAgICAgICAgICBkLkR1bXBIZWFkZXIoKTtcclxuICAgICAgICAgICAgZC5EdW1wRnVuY3Rpb24oZiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGQud3JpdGVyLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBBbnkgZXJyb3JzIHJlc3VsdCBpbiB0aHJvd24gZXhjZXB0aW9ucy5cclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGdsb2JhbCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsb2JhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGdsb2JhbChnbG9iYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsID0gZ2xvYmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCBuQ2NhbGxzKG5DY2FsbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fbkNjYWxscyA9IG5DY2FsbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IG5DY2FsbHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uQ2NhbGxzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTHVhID0gTHVhO1xyXG4gICAgTHVhLkQgPSBmYWxzZTtcclxuICAgIC8qKiBWZXJzaW9uIHN0cmluZy4gKi9cclxuICAgIEx1YS5WRVJTSU9OID0gXCJMdWEgNS4xIChKaWxsIDEuMC4xKVwiO1xyXG4gICAgTHVhLlJFTEVBU0UgPSBcIkx1YSA1LjEuNCAoSmlsbCAxLjAuMSlcIjtcclxuICAgIEx1YS5WRVJTSU9OX05VTSA9IDUwMTtcclxuICAgIEx1YS5DT1BZUklHSFQgPSBcIkNvcHlyaWdodCAoQykgMTk5NC0yMDA4IEx1YS5vcmcsIFBVQy1SaW8gKENvcHlyaWdodCAoQykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykpXCI7XHJcbiAgICAvKiogaHR0cDovL3d3dy5yYXZlbmJyb29rLmNvbSAqL1xyXG4gICAgTHVhLkFVVEhPUlMgPSBcIlIuIEllcnVzYWxpbXNjaHksIEwuIEguIGRlIEZpZ3VlaXJlZG8gJiBXLiBDZWxlcyAoUmF2ZW5icm9vayBMaW1pdGVkKVwiO1xyXG4gICAgLyoqIE51bWJlciBvZiBsaXN0IGl0ZW1zIHRvIGFjY3VtdWxhdGUgYmVmb3JlIGEgU0VUTElTVCBpbnN0cnVjdGlvbi4gKi9cclxuICAgIEx1YS5MRklFTERTX1BFUl9GTFVTSCA9IDUwO1xyXG4gICAgLyoqIExpbWl0IGZvciB0YWJsZSB0YWctbWV0aG9kIGNoYWlucyAodG8gYXZvaWQgbG9vcHMpICovXHJcbiAgICBMdWEuTUFYVEFHTE9PUCA9IDEwMDtcclxuICAgIC8qKiBOb25jZSBvYmplY3QgdXNlZCBieSBwY2FsbCBhbmQgZnJpZW5kcyAodG8gZGV0ZWN0IHdoZW4gYW5cclxuICAgICogZXhjZXB0aW9uIGlzIGEgTHVhIGVycm9yKS4gKi9cclxuICAgIEx1YS5MVUFfRVJST1IgPSBcIlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBsb2NhbCB2YXJpYWJsZXMgcGVyIGZ1bmN0aW9uLiAgQXMgcGVyXHJcbiAgICAgKiBMVUFJX01BWFZBUlMgZnJvbSBcImx1YWNvbmYuaFwiLiAgRGVmYXVsdCBhY2Nlc3Mgc28gdGhhdCB7QGxpbmtcclxuICAgICAqIEZ1bmNTdGF0ZX0gY2FuIHNlZSBpdC5cclxuICAgICAqL1xyXG4gICAgTHVhLk1BWFZBUlMgPSAyMDA7XHJcbiAgICBMdWEuTUFYU1RBQ0sgPSAyNTA7XHJcbiAgICBMdWEuTUFYVVBWQUxVRVMgPSA2MDtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcmVkIGluIFNsb3QuciB0byBkZW5vdGUgYSBudW1lcmljIHZhbHVlICh3aGljaCBpcyBzdG9yZWQgYXRcclxuICAgICAqIFNsb3QuZCkuXHJcbiAgICAgKi9cclxuICAgIEx1YS5OVU1CRVIgPSBuZXcgT2JqZWN0KCk7XHJcbiAgICAvKipcclxuICAgICAqIFNwYXJlIFNsb3QgdXNlZCBmb3IgYSB0ZW1wb3JhcnkuXHJcbiAgICAgKi9cclxuICAgIEx1YS5TUEFSRV9TTE9UID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAvKipcclxuICAgICogUmVnaXN0cnkga2V5IGZvciBsb2FkZWQgbW9kdWxlcy5cclxuICAgICovXHJcbiAgICBMdWEuTE9BREVEID0gXCJfTE9BREVEXCI7XHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBQdWJsaWMgQVBJXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmcmVzaCBMdWEgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIC8qXHJcbiAgICBwdWJsaWMgZnVuY3Rpb24gTHVhKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9nbG9iYWwgPSBuZXcgTHVhVGFibGUoKTtcclxuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IG5ldyBMdWFUYWJsZSgpO1xyXG4gICAgICAgIHRoaXMuX21ldGF0YWJsZSA9IG5ldyBBcnJheShOVU1fVEFHUyk7IC8vTHVhVGFibGVbXVxyXG4gICAgICAgIHRoaXMuX21haW4gPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIC8qKlxyXG4gICAgKiBFcXVpdmFsZW50IG9mIExVQV9NVUxUUkVULlxyXG4gICAgKi9cclxuICAgIC8vIFJlcXVpcmVkLCBieSB2bVBvc2NhbGwsIHRvIGJlIG5lZ2F0aXZlLlxyXG4gICAgTHVhLk1VTFRSRVQgPSAtMTtcclxuICAgIC8qKlxyXG4gICAgKiBUaGUgTHVhIDxjb2RlPm5pbDwvY29kZT4gdmFsdWUuXHJcbiAgICAqL1xyXG4gICAgTHVhLk5JTCA9IG5ldyBPYmplY3QoKTtcclxuICAgIC8vIEx1YSB0eXBlIHRhZ3MsIGZyb20gbHVhLmhcclxuICAgIC8qKiBMdWEgdHlwZSB0YWcsIHJlcHJlc2VudGluZyBubyBzdGFjayB2YWx1ZS4gKi9cclxuICAgIEx1YS5UTk9ORSA9IC0xO1xyXG4gICAgLyoqIEx1YSB0eXBlIHRhZywgcmVwcmVzZW50aW5nIDxjb2RlPm5pbDwvY29kZT4uICovXHJcbiAgICBMdWEuVE5JTCA9IDA7XHJcbiAgICAvKiogTHVhIHR5cGUgdGFnLCByZXByZXNlbnRpbmcgYm9vbGVhbi4gKi9cclxuICAgIEx1YS5UQk9PTEVBTiA9IDE7XHJcbiAgICAvLyBUTElHSFRVU0VSREFUQSBub3QgYXZhaWxhYmxlLiAgOnRvZG86IG1ha2UgYXZhaWxhYmxlP1xyXG4gICAgLyoqIEx1YSB0eXBlIHRhZywgcmVwcmVzZW50aW5nIG51bWJlcnMuICovXHJcbiAgICBMdWEuVE5VTUJFUiA9IDM7XHJcbiAgICAvKiogTHVhIHR5cGUgdGFnLCByZXByZXNlbnRpbmcgc3RyaW5ncy4gKi9cclxuICAgIEx1YS5UU1RSSU5HID0gNDtcclxuICAgIC8qKiBMdWEgdHlwZSB0YWcsIHJlcHJlc2VudGluZyB0YWJsZXMuICovXHJcbiAgICBMdWEuVFRBQkxFID0gNTtcclxuICAgIC8qKiBMdWEgdHlwZSB0YWcsIHJlcHJlc2VudGluZyBmdW5jdGlvbnMuICovXHJcbiAgICBMdWEuVEZVTkNUSU9OID0gNjtcclxuICAgIC8qKiBMdWEgdHlwZSB0YWcsIHJlcHJlc2VudGluZyB1c2VyZGF0YS4gKi9cclxuICAgIEx1YS5UVVNFUkRBVEEgPSA3O1xyXG4gICAgLyoqIEx1YSB0eXBlIHRhZywgcmVwcmVzZW50aW5nIHRocmVhZHMuICovXHJcbiAgICBMdWEuVFRIUkVBRCA9IDg7XHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiB0eXBlIHRhZ3MuICBTaG91bGQgYmUgb25lIG1vcmUgdGhhbiB0aGVcclxuICAgICAqIGxhc3QgZW50cnkgaW4gdGhlIGxpc3Qgb2YgdGFncy5cclxuICAgICAqIOexu+Wei+agh+etvuS4quaVsFxyXG4gICAgICovXHJcbiAgICBMdWEuTlVNX1RBR1MgPSA5O1xyXG4gICAgLyoqIE5hbWVzIGZvciBhYm92ZSB0eXBlIHRhZ3MsIHN0YXJ0aW5nIGZyb20ge0BsaW5rICNUTklMfS5cclxuICAgICogRXF1aXZhbGVudCB0byBsdWFUX3R5cGVuYW1lcy5cclxuICAgICovXHJcbiAgICBMdWEuVFlQRU5BTUUgPSBbXHJcbiAgICAgICAgXCJuaWxcIiwgXCJib29sZWFuXCIsIFwidXNlcmRhdGFcIiwgXCJudW1iZXJcIixcclxuICAgICAgICBcInN0cmluZ1wiLCBcInRhYmxlXCIsIFwiZnVuY3Rpb25cIiwgXCJ1c2VyZGF0YVwiLCBcInRocmVhZFwiXHJcbiAgICBdO1xyXG4gICAgLyoqXHJcbiAgICAqIE1pbmltdW0gc3RhY2sgc2l6ZSB0aGF0IEx1YSBKYXZhIGZ1bmN0aW9ucyBnZXRzLiAgTWF5IHR1cm4gb3V0IHRvXHJcbiAgICAqIGJlIHNpbGx5IC8gcmVkdW5kYW50LlxyXG4gICAgKi9cclxuICAgIEx1YS5NSU5TVEFDSyA9IDIwO1xyXG4gICAgLyoqIFN0YXR1cyBjb2RlLCByZXR1cm5lZCBmcm9tIHBjYWxsIGFuZCBmcmllbmRzLCB0aGF0IGluZGljYXRlcyB0aGVcclxuICAgICogdGhyZWFkIGhhcyB5aWVsZGVkLlxyXG4gICAgKi9cclxuICAgIEx1YS5ZSUVMRCA9IDE7XHJcbiAgICAvKiogU3RhdHVzIGNvZGUsIHJldHVybmVkIGZyb20gcGNhbGwgYW5kIGZyaWVuZHMsIHRoYXQgaW5kaWNhdGVzXHJcbiAgICAqIGEgcnVudGltZSBlcnJvci5cclxuICAgICovXHJcbiAgICBMdWEuRVJSUlVOID0gMjtcclxuICAgIC8qKiBTdGF0dXMgY29kZSwgcmV0dXJuZWQgZnJvbSBwY2FsbCBhbmQgZnJpZW5kcywgdGhhdCBpbmRpY2F0ZXNcclxuICAgICogYSBzeW50YXggZXJyb3IuXHJcbiAgICAqL1xyXG4gICAgTHVhLkVSUlNZTlRBWCA9IDM7XHJcbiAgICAvKiogU3RhdHVzIGNvZGUsIHJldHVybmVkIGZyb20gcGNhbGwgYW5kIGZyaWVuZHMsIHRoYXQgaW5kaWNhdGVzXHJcbiAgICAqIGEgbWVtb3J5IGFsbG9jYXRpb24gZXJyb3IuXHJcbiAgICAqL1xyXG4gICAgTHVhLkVSUk1FTSA9IDQ7XHJcbiAgICAvKiogU3RhdHVzIGNvZGUsIHJldHVybmVkIGZyb20gcGNhbGwgYW5kIGZyaWVuZHMsIHRoYXQgaW5kaWNhdGVzXHJcbiAgICAqIGFuIGVycm9yIHdoaWxzdCBydW5uaW5nIHRoZSBlcnJvciBoYW5kbGVyIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEx1YS5FUlJFUlIgPSA1O1xyXG4gICAgLyoqIFN0YXR1cyBjb2RlLCByZXR1cm5lZCBmcm9tIGxvYWRGaWxlIGFuZCBmcmllbmRzLCB0aGF0IGluZGljYXRlc1xyXG4gICAgKiBhbiBJTyBlcnJvci5cclxuICAgICovXHJcbiAgICBMdWEuRVJSRklMRSA9IDY7XHJcbiAgICAvLyBFbnVtcyBmb3IgZ2MoKS5cclxuICAgIC8qKiBBY3Rpb24sIHBhc3NlZCB0byB7QGxpbmsgI2djfSwgdGhhdCByZXF1ZXN0cyB0aGUgR0MgdG8gc3RvcC4gKi9cclxuICAgIEx1YS5HQ1NUT1AgPSAwO1xyXG4gICAgLyoqIEFjdGlvbiwgcGFzc2VkIHRvIHtAbGluayAjZ2N9LCB0aGF0IHJlcXVlc3RzIHRoZSBHQyB0byByZXN0YXJ0LiAqL1xyXG4gICAgTHVhLkdDUkVTVEFSVCA9IDE7XHJcbiAgICAvKiogQWN0aW9uLCBwYXNzZWQgdG8ge0BsaW5rICNnY30sIHRoYXQgcmVxdWVzdHMgYSBmdWxsIGNvbGxlY3Rpb24uICovXHJcbiAgICBMdWEuR0NDT0xMRUNUID0gMjtcclxuICAgIC8qKiBBY3Rpb24sIHBhc3NlZCB0byB7QGxpbmsgI2djfSwgdGhhdCByZXR1cm5zIGFtb3VudCBvZiBtZW1vcnlcclxuICAgICAqIChpbiBLaWJpYnl0ZXMpIGluIHVzZSAoYnkgdGhlIGVudGlyZSBKYXZhIHJ1bnRpbWUpLlxyXG4gICAgICovXHJcbiAgICBMdWEuR0NDT1VOVCA9IDM7XHJcbiAgICAvKiogQWN0aW9uLCBwYXNzZWQgdG8ge0BsaW5rICNnY30sIHRoYXQgcmV0dXJucyB0aGUgcmVtYWluZGVyIG9mXHJcbiAgICAgKiBkaXZpZGluZyB0aGUgYW1vdW50IG9mIG1lbW9yeSBpbiB1c2UgYnkgMTAyNC5cclxuICAgICAqL1xyXG4gICAgTHVhLkdDQ09VTlRCID0gNDtcclxuICAgIC8qKiBBY3Rpb24sIHBhc3NlZCB0byB7QGxpbmsgI2djfSwgdGhhdCByZXF1ZXN0cyBhbiBpbmNyZW1lbnRhbFxyXG4gICAgICogZ2FyYmFnZSBjb2xsZWN0aW9uIGJlIHBlcmZvcm1lZC5cclxuICAgICAqL1xyXG4gICAgTHVhLkdDU1RFUCA9IDU7XHJcbiAgICAvKiogQWN0aW9uLCBwYXNzZWQgdG8ge0BsaW5rICNnY30sIHRoYXQgc2V0cyBhIG5ldyB2YWx1ZSBmb3IgdGhlXHJcbiAgICAgKiA8dmFyPnBhdXNlPC92YXI+IG9mIHRoZSBjb2xsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIEx1YS5HQ1NFVFBBVVNFID0gNjtcclxuICAgIC8qKiBBY3Rpb24sIHBhc3NlZCB0byB7QGxpbmsgI2djfSwgdGhhdCBzZXRzIGEgbmV3IHZhbHVlcyBmb3IgdGhlXHJcbiAgICAgKiA8dmFyPnN0ZXAgbXVsdGlwbGllcjwvdmFyPiBvZiB0aGUgY29sbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBMdWEuR0NTRVRTVEVQTVVMID0gNztcclxuICAgIC8vIFNvbWUgb2YgdGhlIGhvb2tzLCBldGMsIGFyZW4ndCBpbXBsZW1lbnRlZCwgc28gcmVtYWluIHByaXZhdGUuXHJcbiAgICBMdWEuSE9PS0NBTEwgPSAwO1xyXG4gICAgTHVhLkhPT0tSRVQgPSAxO1xyXG4gICAgTHVhLkhPT0tMSU5FID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB7QGxpbmsgSG9va30gY2FsbGJhY2sgaXMgY2FsbGVkIGFzIGEgbGluZSBob29rLCBpdHNcclxuICAgICAqIDx2YXI+YXIuZXZlbnQ8L3Zhcj4gZmllbGQgaXMgPGNvZGU+SE9PS0NPVU5UPC9jb2RlPi5cclxuICAgICAqL1xyXG4gICAgTHVhLkhPT0tDT1VOVCA9IDM7XHJcbiAgICBMdWEuSE9PS1RBSUxSRVQgPSA0O1xyXG4gICAgTHVhLk1BU0tDQUxMID0gMSA8PCBMdWEuSE9PS0NBTEw7XHJcbiAgICBMdWEuTUFTS1JFVCA9IDEgPDwgTHVhLkhPT0tSRVQ7XHJcbiAgICBMdWEuTUFTS0xJTkUgPSAxIDw8IEx1YS5IT09LTElORTtcclxuICAgIC8qKlxyXG4gICAgKiBCaXRtYXNrIHRoYXQgc3BlY2lmaWVzIGNvdW50IGhvb2sgaW4gY2FsbCB0byB7QGxpbmsgI3NldEhvb2t9LlxyXG4gICAgKi9cclxuICAgIEx1YS5NQVNLQ09VTlQgPSAxIDw8IEx1YS5IT09LQ09VTlQ7XHJcbiAgICBMdWEuTUVNRVJSTVNHID0gXCJub3QgZW5vdWdoIG1lbW9yeVwiO1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gT2JqZWN0XHJcbiAgICAvLyBNZXRob2RzIGVxdWl2YWxlbnQgdG8gdGhlIGZpbGUgbG9iamVjdC5jLiAgUHJlZml4ZWQgd2l0aCBvLlxyXG4gICAgTHVhLklEU0laRSA9IDYwO1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBWTVxyXG4gICAgLy8gTW9zdCBvZiB0aGUgbWV0aG9kcyBpbiB0aGlzIHNlY3Rpb24gYXJlIGVxdWl2YWxlbnQgdG8gdGhlIGZpbGVzXHJcbiAgICAvLyBsdm0uYyBhbmQgbGRvLmMgZnJvbSBQVUMtUmlvLiAgVGhleSdyZSBtb3N0bHkgcHJlZml4ZWQgd2l0aCB2bSBhc1xyXG4gICAgLy8gd2VsbC5cclxuICAgIEx1YS5QQ1JMVUEgPSAwO1xyXG4gICAgTHVhLlBDUkogPSAxO1xyXG4gICAgTHVhLlBDUllJRUxEID0gMjtcclxuICAgIC8vIEluc3RydWN0aW9uIGRlY29tcG9zaXRpb24uXHJcbiAgICAvLyBUaGVyZSBmb2xsb3dzIGEgc2VyaWVzIG9mIG1ldGhvZHMgdGhhdCBleHRyYWN0IHRoZSB2YXJpb3VzIGZpZWxkc1xyXG4gICAgLy8gZnJvbSBhIFZNIGluc3RydWN0aW9uLiAgU2VlIGxvcGNvZGVzLmggZnJvbSBQVUMtUmlvLlxyXG4gICAgLy8gOnRvZG86IENvbnNpZGVyIHJlcGxhY2luZyB3aXRoIG00IG1hY3JvcyAob3Igc2ltaWxhcikuXHJcbiAgICAvLyBBIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBpbnN0cnVjdGlvbiBmb3JtYXQ6XHJcbiAgICAvLyBMb2dpY2FsbHkgYW4gaW5zdHJ1Y3Rpb24gaGFzIGFuIG9wY29kZSAoNiBiaXRzKSwgb3AsIGFuZCB1cCB0b1xyXG4gICAgLy8gdGhyZWUgZmllbGRzIHVzaW5nIG9uZSBvZiB0aHJlZSBmb3JtYXRzOlxyXG4gICAgLy8gQSBCIEMgICg4IGJpdHMsIDkgYml0cywgOSBiaXRzKVxyXG4gICAgLy8gQSBCeCAgICg4IGJpdHMsIDE4IGJpdHMpXHJcbiAgICAvLyBBIHNCeCAgKDggYml0cywgMTggYml0cyBzaWduZWQgLSBleGNlc3MgSylcclxuICAgIC8vIFNvbWUgaW5zdHJ1Y3Rpb25zIGRvIG5vdCB1c2UgYWxsIHRoZSBmaWVsZHMgKEVHIE9QX1VOTSBvbmx5IHVzZXMgQVxyXG4gICAgLy8gYW5kIEIpLlxyXG4gICAgLy8gV2hlbiBwYWNrZWQgaW50byBhIHdvcmQgKGFuIGludCBpbiBKaWxsKSB0aGUgZm9sbG93aW5nIGxheW91dHMgYXJlXHJcbiAgICAvLyB1c2VkOlxyXG4gICAgLy8gIDMxIChNU0IpICAgIDIzIDIyICAgICAgICAgIDE0IDEzICAgICAgICAgNiA1ICAgICAgMCAoTFNCKVxyXG4gICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLSstLS0tLS0tLStcclxuICAgIC8vIHwgQiAgICAgICAgICAgIHwgQyAgICAgICAgICAgIHwgQSAgICAgICAgICB8IE9QQ09ERSB8XHJcbiAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tKy0tLS0tLS0tK1xyXG4gICAgLy9cclxuICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rLS0tLS0tLS0rXHJcbiAgICAvLyB8IEJ4ICAgICAgICAgICAgICAgICAgICAgICAgICB8IEEgICAgICAgICAgfCBPUENPREUgfFxyXG4gICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLSstLS0tLS0tLStcclxuICAgIC8vXHJcbiAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tKy0tLS0tLS0tK1xyXG4gICAgLy8gfCBzQnggICAgICAgICAgICAgICAgICAgICAgICAgfCBBICAgICAgICAgIHwgT1BDT0RFIHxcclxuICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rLS0tLS0tLS0rXHJcbiAgICBMdWEuTk9fUkVHID0gMHhmZjsgLy8gU0laRV9BID09IDgsICgxIDw8IDgpLTFcclxuICAgIC8vIG9wY29kZSBlbnVtZXJhdGlvbi5cclxuICAgIC8vIEdlbmVyYXRlZCBieSBhIHNjcmlwdDpcclxuICAgIC8vIGF3ayAtZiBvcGNvZGUuYXdrIDwgbG9wY29kZXMuaFxyXG4gICAgLy8gYW5kIHRoZW4gcGFzdGVkIGludG8gaGVyZS5cclxuICAgIC8vIE1hZGUgZGVmYXVsdCBhY2Nlc3Mgc28gdGhhdCBjb2RlIGdlbmVyYXRpb24sIGluIEZ1bmNTdGF0ZSwgY2FuIHNlZVxyXG4gICAgLy8gdGhlIGVudW1lcmF0aW9uIGFzIHdlbGwuXHJcbiAgICBMdWEuT1BfTU9WRSA9IDA7XHJcbiAgICBMdWEuT1BfTE9BREsgPSAxO1xyXG4gICAgTHVhLk9QX0xPQURCT09MID0gMjtcclxuICAgIEx1YS5PUF9MT0FETklMID0gMztcclxuICAgIEx1YS5PUF9HRVRVUFZBTCA9IDQ7XHJcbiAgICBMdWEuT1BfR0VUR0xPQkFMID0gNTtcclxuICAgIEx1YS5PUF9HRVRUQUJMRSA9IDY7XHJcbiAgICBMdWEuT1BfU0VUR0xPQkFMID0gNztcclxuICAgIEx1YS5PUF9TRVRVUFZBTCA9IDg7XHJcbiAgICBMdWEuT1BfU0VUVEFCTEUgPSA5O1xyXG4gICAgTHVhLk9QX05FV1RBQkxFID0gMTA7XHJcbiAgICBMdWEuT1BfU0VMRiA9IDExO1xyXG4gICAgTHVhLk9QX0FERCA9IDEyO1xyXG4gICAgTHVhLk9QX1NVQiA9IDEzO1xyXG4gICAgTHVhLk9QX01VTCA9IDE0O1xyXG4gICAgTHVhLk9QX0RJViA9IDE1O1xyXG4gICAgTHVhLk9QX01PRCA9IDE2O1xyXG4gICAgTHVhLk9QX1BPVyA9IDE3O1xyXG4gICAgTHVhLk9QX1VOTSA9IDE4O1xyXG4gICAgTHVhLk9QX05PVCA9IDE5O1xyXG4gICAgTHVhLk9QX0xFTiA9IDIwO1xyXG4gICAgTHVhLk9QX0NPTkNBVCA9IDIxO1xyXG4gICAgTHVhLk9QX0pNUCA9IDIyO1xyXG4gICAgTHVhLk9QX0VRID0gMjM7XHJcbiAgICBMdWEuT1BfTFQgPSAyNDtcclxuICAgIEx1YS5PUF9MRSA9IDI1O1xyXG4gICAgTHVhLk9QX1RFU1QgPSAyNjtcclxuICAgIEx1YS5PUF9URVNUU0VUID0gMjc7XHJcbiAgICBMdWEuT1BfQ0FMTCA9IDI4O1xyXG4gICAgTHVhLk9QX1RBSUxDQUxMID0gMjk7XHJcbiAgICBMdWEuT1BfUkVUVVJOID0gMzA7XHJcbiAgICBMdWEuT1BfRk9STE9PUCA9IDMxO1xyXG4gICAgTHVhLk9QX0ZPUlBSRVAgPSAzMjtcclxuICAgIEx1YS5PUF9URk9STE9PUCA9IDMzO1xyXG4gICAgTHVhLk9QX1NFVExJU1QgPSAzNDtcclxuICAgIEx1YS5PUF9DTE9TRSA9IDM1O1xyXG4gICAgTHVhLk9QX0NMT1NVUkUgPSAzNjtcclxuICAgIEx1YS5PUF9WQVJBUkcgPSAzNztcclxuICAgIC8vIGVuZCBvZiBpbnN0cnVjdGlvbiBkZWNvbXBvc2l0aW9uXHJcbiAgICBMdWEuU0laRV9DID0gOTtcclxuICAgIEx1YS5TSVpFX0IgPSA5O1xyXG4gICAgTHVhLlNJWkVfQnggPSBMdWEuU0laRV9DICsgTHVhLlNJWkVfQjtcclxuICAgIEx1YS5TSVpFX0EgPSA4O1xyXG4gICAgTHVhLlNJWkVfT1AgPSA2O1xyXG4gICAgTHVhLlBPU19PUCA9IDA7XHJcbiAgICBMdWEuUE9TX0EgPSBMdWEuUE9TX09QICsgTHVhLlNJWkVfT1A7XHJcbiAgICBMdWEuUE9TX0MgPSBMdWEuUE9TX0EgKyBMdWEuU0laRV9BO1xyXG4gICAgTHVhLlBPU19CID0gTHVhLlBPU19DICsgTHVhLlNJWkVfQztcclxuICAgIEx1YS5QT1NfQnggPSBMdWEuUE9TX0M7XHJcbiAgICBMdWEuTUFYQVJHX0J4ID0gKDEgPDwgTHVhLlNJWkVfQngpIC0gMTtcclxuICAgIEx1YS5NQVhBUkdfc0J4ID0gTHVhLk1BWEFSR19CeCA+PiAxOyAvLyBgc0J4JyBpcyBzaWduZWRcclxuICAgIEx1YS5NQVhBUkdfQSA9ICgxIDw8IEx1YS5TSVpFX0EpIC0gMTtcclxuICAgIEx1YS5NQVhBUkdfQiA9ICgxIDw8IEx1YS5TSVpFX0IpIC0gMTtcclxuICAgIEx1YS5NQVhBUkdfQyA9ICgxIDw8IEx1YS5TSVpFX0MpIC0gMTtcclxuICAgIC8qIHRoaXMgYml0IDEgbWVhbnMgY29uc3RhbnQgKDAgbWVhbnMgcmVnaXN0ZXIpICovXHJcbiAgICBMdWEuQklUUksgPSAxIDw8IChMdWEuU0laRV9CIC0gMSk7XHJcbiAgICBMdWEuTUFYSU5ERVhSSyA9IEx1YS5CSVRSSyAtIDE7XHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIG51bWVyaWMgb3BlcmFuZHMuICBVc2VkIHdoZW4gY29udmVydGluZyBzdHJpbmdzIHRvIG51bWJlcnNcclxuICAgICAqIGJ5IGFuIGFyaXRobWV0aWMgb3Bjb2RlIChBREQsIFNVQiwgTVVMLCBESVYsIE1PRCwgUE9XLCBVTk0pLlxyXG4gICAgICovXHJcbiAgICBMdWEuTlVNT1AgPSBuZXcgQXJyYXkoMik7IC8vZG91YmxlW11cclxuICAgIC8qKlxyXG4gICAgKiBQcmludGYgZm9ybWF0IGl0ZW0gdXNlZCB0byBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5ncyAoaW4ge0BsaW5rXHJcbiAgICAqICN2bVRvc3RyaW5nfSkuICBUaGUgaW5pdGlhbCAnJScgc2hvdWxkIGJlIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAqL1xyXG4gICAgTHVhLk5VTUJFUl9GTVQgPSBcIi4xNGdcIjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUx1YS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL2phdmEvUnVudGltZUV4Y2VwdGlvblwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuTHVhRXJyb3IgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBSdW50aW1lRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vamF2YS9SdW50aW1lRXhjZXB0aW9uXCIpO1xyXG4gICAgLyogICRIZWFkZXIkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnQgYSBMdWEgZXJyb3JcclxuICAgICAqL1xyXG4gICAgY2xhc3MgTHVhRXJyb3IgZXh0ZW5kcyBSdW50aW1lRXhjZXB0aW9uXzEuUnVudGltZUV4Y2VwdGlvbiB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZXJyb3JTdGF0dXMpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJMdWEgZXJyb3JcIjsgLy9zdXBlcihcIkx1YSBlcnJvclwiKTtcclxuICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0dXMgPSBlcnJvclN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGVycm9yU3RhdHVzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3JTdGF0dXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5MdWFFcnJvciA9IEx1YUVycm9yO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9THVhRXJyb3IuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCIuLi9qYXZhL051bGxQb2ludGVyRXhjZXB0aW9uXCIsIFwiLi4vamF2YS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkx1YUZ1bmN0aW9uID0gdm9pZCAwO1xyXG4gICAgY29uc3QgTnVsbFBvaW50ZXJFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL051bGxQb2ludGVyRXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vamF2YS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvTHVhRnVuY3Rpb24uamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIE1vZGVscyBhIEx1YSBmdW5jdGlvbi5cclxuICAgICAqIE5vdGUgdGhhdCB3aGlsc3QgdGhlIGNsYXNzIGlzIHB1YmxpYywgaXRzIGNvbnN0cnVjdG9ycyBhcmUgbm90LlxyXG4gICAgICogRnVuY3Rpb25zIGFyZSBjcmVhdGVkIGJ5IGxvYWRpbmcgTHVhIGNodW5rcyAoaW4gc291cmNlIG9yIGJpbmFyeVxyXG4gICAgICogZm9ybSkgb3IgZXhlY3V0aW5nIEx1YSBjb2RlIHdoaWNoIGRlZmluZXMgZnVuY3Rpb25zIChhbmQsIGZvclxyXG4gICAgICogZXhhbXBsZSwgcGxhY2VzIHRoZW0gaW4gdGhlIGdsb2JhbCB0YWJsZSkuICB7QGxpbmtcclxuICAgICAqIEx1YSNsb2FkKElucHV0U3RyZWFtLCBTdHJpbmcpIEx1YS5sb2FkfSBpcyB1c2VkXHJcbiAgICAgKiB0byBsb2FkIGEgTHVhIGNodW5rIChpdCByZXR1cm5zIGEgPGNvZGU+THVhRnVuY3Rpb248L2NvZGU+KSxcclxuICAgICAqIGFuZCB7QGxpbmsgTHVhI2NhbGwgTHVhLmNhbGx9IGlzIHVzZWQgdG8gY2FsbCBhIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBMdWFGdW5jdGlvbiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBmcm9tIGEgdHJpcGxlIG9mIHtQcm90bywgdXB2YWx1ZXMsXHJcbiAgICAgICAgICogZW52aXJvbm1lbnR9LiAgRGVsaWJlcmF0ZWx5IG5vdCBwdWJsaWMsIFNlZSB7QGxpbmtcclxuICAgICAgICAgKiBMdWEjbG9hZChJbnB1dFN0cmVhbSwgU3RyaW5nKSBMdWEubG9hZH0gZm9yXHJcbiAgICAgICAgICogcHVibGljIGNvbnN0cnVjdGlvbi4gIEFsbCBhcmd1bWVudHMgYXJlIHJlZmVyZW5jZWQgZnJvbSB0aGVcclxuICAgICAgICAgKiBpbnN0YW5jZS4gIFRoZSA8Y29kZT51cHZhbDwvY29kZT4gYXJyYXkgbXVzdCBoYXZlIGV4YWN0bHkgdGhlIHNhbWVcclxuICAgICAgICAgKiBudW1iZXIgb2YgZWxlbWVudHMgYXMgdGhlIG51bWJlciBvZiB1cHZhbHVlcyBpbiA8Y29kZT5wcm90bzwvY29kZT5cclxuICAgICAgICAgKiAodGhlIHZhbHVlIG9mIHRoZSA8Y29kZT5udXBzPC9jb2RlPiBwYXJhbWV0ZXIgaW4gdGhlXHJcbiAgICAgICAgICogPGNvZGU+UHJvdG88L2NvZGU+IGNvbnN0cnVjdG9yKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm90byAgQSBQcm90byBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHVwdmFsICBBcnJheSBvZiB1cHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0gZW52ICAgIFRoZSBmdW5jdGlvbidzIGVudmlyb25tZW50LlxyXG4gICAgICAgICAqIEB0aHJvd3MgTnVsbFBvaW50ZXJFeGNlcHRpb24gaWYgYW55IGFyZ3VtZW50cyBhcmUgbnVsbC5cclxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudHNFeGNlcHRpb24gaWYgdXB2YWwubGVuZ3RoIGlzIHdyb25nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3RvLCB1cHZhbCAvKlVwVmFsW10qLywgZW52KSB7XHJcbiAgICAgICAgICAgIGlmIChudWxsID09IHByb3RvIHx8IG51bGwgPT0gdXB2YWwgfHwgbnVsbCA9PSBlbnYpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOdWxsUG9pbnRlckV4Y2VwdGlvbl8xLk51bGxQb2ludGVyRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVwdmFsLmxlbmd0aCAhPSBwcm90by5udXBzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcCA9IHByb3RvO1xyXG4gICAgICAgICAgICB0aGlzLl91cHZhbCA9IHVwdmFsO1xyXG4gICAgICAgICAgICAvL0ZJWE1FOuiwg+ivleeUqFxyXG4gICAgICAgICAgICAvL2lmICh0aGlzLl91cHZhbCAhPSBudWxsICYmIFxyXG4gICAgICAgICAgICAvL1x0dGhpcy5fdXB2YWwubGVuZ3RoID09IDIpXHJcbiAgICAgICAgICAgIC8ve1xyXG4gICAgICAgICAgICAvL1x0KHRoaXMuX3VwdmFsWzBdIGFzIFVwVmFsKS5fcy50YWdVcFZhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vXHQodGhpcy5fdXB2YWxbMV0gYXMgVXBWYWwpLl9zLnRhZ1VwVmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy9cdHRyYWNlKFwidGhpcy5fdXB2YWwubGVuZ3RoID09IDJcIik7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICB0aGlzLl9lbnYgPSBlbnY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBHZXQgbnRoIFVwVmFsLiAqL1xyXG4gICAgICAgIHVwVmFsKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwdmFsW25dO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogR2V0IHRoZSBQcm90byBvYmplY3QuICovXHJcbiAgICAgICAgZ2V0IHByb3RvKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEdldHRlciBmb3IgZW52aXJvbm1lbnQuICovXHJcbiAgICAgICAgZ2V0IGVudigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VudjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFNldHRlciBmb3IgZW52aXJvbm1lbnQuICovXHJcbiAgICAgICAgc2V0IGVudihlbnYpIHtcclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gZW52KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb25fMS5OdWxsUG9pbnRlckV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2VudiA9IGVudjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkx1YUZ1bmN0aW9uID0gTHVhRnVuY3Rpb247XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MdWFGdW5jdGlvbi5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL2phdmEvSW5wdXRTdHJlYW1SZWFkZXJcIiwgXCIuL0x1YUphdmFDYWxsYmFja1wiLCBcIi4vTHVhXCIsIFwiLi9Mb2FkZXJcIiwgXCIuL0Zyb21SZWFkZXJcIiwgXCIuL1N5bnRheFwiLCBcIi4vTHVhRnVuY3Rpb25cIl0sIGZhY3RvcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkx1YUludGVybmFsID0gdm9pZCAwO1xyXG4gICAgY29uc3QgSW5wdXRTdHJlYW1SZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0lucHV0U3RyZWFtUmVhZGVyXCIpO1xyXG4gICAgY29uc3QgTHVhSmF2YUNhbGxiYWNrXzEgPSByZXF1aXJlKFwiLi9MdWFKYXZhQ2FsbGJhY2tcIik7XHJcbiAgICBjb25zdCBMdWFfMSA9IHJlcXVpcmUoXCIuL0x1YVwiKTtcclxuICAgIGNvbnN0IExvYWRlcl8xID0gcmVxdWlyZShcIi4vTG9hZGVyXCIpO1xyXG4gICAgY29uc3QgRnJvbVJlYWRlcl8xID0gcmVxdWlyZShcIi4vRnJvbVJlYWRlclwiKTtcclxuICAgIGNvbnN0IFN5bnRheF8xID0gcmVxdWlyZShcIi4vU3ludGF4XCIpO1xyXG4gICAgY29uc3QgTHVhRnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL0x1YUZ1bmN0aW9uXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL0x1YUludGVybmFsLmphdmEjMSAkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB1c2VkIHRvIGltcGxlbWVudCBpbnRlcm5hbCBjYWxsYmFja3MuICBDdXJyZW50bHkgdGhlcmUgaXMgb25seVxyXG4gICAgICogb25lIGNhbGxiYWNrIHVzZWQsIG9uZSB0aGF0IHBhcnNlcyBvciBsb2FkcyBhIEx1YSBjaHVuayBpbnRvIGJpbmFyeVxyXG4gICAgICogZm9ybS5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgTHVhSW50ZXJuYWwgZXh0ZW5kcyBMdWFKYXZhQ2FsbGJhY2tfMS5MdWFKYXZhQ2FsbGJhY2sge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9jaHVua25hbWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbml0MShfaW4sIGNodW5rbmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBfaW47XHJcbiAgICAgICAgICAgIHRoaXMuX2NodW5rbmFtZSA9IGNodW5rbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5pdDIoX2luLCBjaHVua25hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZGVyID0gX2luO1xyXG4gICAgICAgICAgICB0aGlzLl9jaHVua25hbWUgPSBjaHVua25hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGx1YUZ1bmN0aW9uKEwpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIEluIGVpdGhlciB0aGUgc3RyZWFtIG9yIHRoZSByZWFkZXIgY2FzZSB0aGVyZSBpcyBhIHdheSBvZlxyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydGluZyB0aGUgaW5wdXQgdG8gdGhlIG90aGVyIHR5cGUuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RyZWFtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW0ubWFyaygxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuX3N0cmVhbS5yZWFkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBSZWFkZXIgaWYgbG9va3MgbGlrZSBzb3VyY2UgY29kZSBpbnN0ZWFkIG9mXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluYXJ5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09IExvYWRlcl8xLkxvYWRlci5IRUFERVJbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBuZXcgTG9hZGVyXzEuTG9hZGVyKHRoaXMuX3N0cmVhbSwgdGhpcy5fY2h1bmtuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGwudW5kdW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkZXIgPSBuZXcgSW5wdXRTdHJlYW1SZWFkZXJfMS5JbnB1dFN0cmVhbVJlYWRlcih0aGlzLl9zdHJlYW0sIFwiVVRGLThcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBTeW50YXhfMS5TeW50YXgucGFyc2VyKEwsIHRoaXMuX3JlYWRlciwgdGhpcy5fY2h1bmtuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIFN0cmVhbSBpZiBsb29rcyBsaWtlIGJpbmFyeSAoZHVtcGVkIHZpYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5kdW1wKSBpbnN0ZWFkIG9mIHNvdXJjZSBjb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkZXIubWFya1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRlci5tYXJrKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSB0aGlzLl9yZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkZXIucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMyID09IExvYWRlcl8xLkxvYWRlci5IRUFERVJbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cmVhbSA9IG5ldyBGcm9tUmVhZGVyXzEuRnJvbVJlYWRlcih0aGlzLl9yZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwyID0gbmV3IExvYWRlcl8xLkxvYWRlcih0aGlzLl9zdHJlYW0sIHRoaXMuX2NodW5rbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gbDIudW5kdW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gU3ludGF4XzEuU3ludGF4LnBhcnNlcihMLCB0aGlzLl9yZWFkZXIsIHRoaXMuX2NodW5rbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBTeW50YXhfMS5TeW50YXgucGFyc2VyKEwsIHRoaXMuX3JlYWRlciwgdGhpcy5fY2h1bmtuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy9uZXcgVXBWYWxbMF0gOiBcclxuICAgICAgICAgICAgICAgIC8vRXJyb3IgIzEwMDc6IOWwneivleWunuS+i+WMlueahOWHveaVsOS4jeaYr+aehOmAoOWHveaVsOOAglxyXG4gICAgICAgICAgICAgICAgLy9UeXBlRXJyb3I6IEVycm9yICMxMDA3OiBJbnN0YW50aWF0aW9uIGF0dGVtcHRlZCBvbiBhIG5vbi1jb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvL0wucHVzaChuZXcgTHVhRnVuY3Rpb24ocCwgbmV3IFVwVmFsWzBdLCBMLmdldEdsb2JhbHMoKSkpO1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoT2JqZWN0KG5ldyBMdWFGdW5jdGlvbl8xLkx1YUZ1bmN0aW9uKHAsIG5ldyBBcnJheSgpLCBMLmdldEdsb2JhbHMoKSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoU3RyaW5nKFwiY2Fubm90IHJlYWQgXCIgKyB0aGlzLl9jaHVua25hbWUgKyBcIjogXCIgKyBlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTC5kVGhyb3coTHVhXzEuTHVhLkVSUkZJTEUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy91bnJlYWNoYWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkx1YUludGVybmFsID0gTHVhSW50ZXJuYWw7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MdWFJbnRlcm5hbC5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuTHVhSmF2YUNhbGxiYWNrID0gdm9pZCAwO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL0x1YUphdmFDYWxsYmFjay5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIC8qKlxyXG4gICAgICogQ29tbW9uIHN1cGVyY2xhc3MgZm9yIGFsbCBMdWEgSmF2YSBGdW5jdGlvbnMuICBBIEx1YSBmdW5jdGlvbiB0aGF0XHJcbiAgICAgKiBpcyBpbXBsZW1lbnRlZCBpbiBKYXZhIGlzIGNhbGxlZCBhIEx1YSBKYXZhIEZ1bmN0aW9uLiAgRWFjaCBzdWNoXHJcbiAgICAgKiBmdW5jdGlvbiBjb3JyZXNwb25kcyB0byBhbiBpbmRpcmVjdCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLiAgSWYgeW91XHJcbiAgICAgKiB3aXNoIHRvIGltcGxlbWVudCB5b3VyIG93biBMdWEgSmF2YSBGdW5jdGlvbiB0aGVuIHlvdSdsbCBuZWVkIHRvXHJcbiAgICAgKiBzdWJjbGFzcyB0aGlzIGNsYXNzIGFuZCBoYXZlIG9uZSBpbnN0YW5jZSBmb3IgZWFjaCBmdW5jdGlvbiB0aGF0IHlvdVxyXG4gICAgICogbmVlZC4gIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IGV4dGVuZCB0aGUgY2xhc3Mgd2l0aCBhdCBsZWFzdCBvbmVcclxuICAgICAqIG1lbWJlciBzbyB0aGF0IHlvdSBjYW4gZGlzdGluZ3Vpc2ggdGhlIGRpZmZlcmVudCBpbnN0YW5jZXMuICBXaGlsc3RcclxuICAgICAqIGl0IGlzIHBvc3NpYmxlIHRvIGltcGxlbWVudCBlYWNoIGRpZmZlcmVudCBMdWEgSmF2YSBGdW5jdGlvbiBieVxyXG4gICAgICogaGF2aW5nIGEgbmV3IHN1YmNsYXNzIGZvciBlYWNoIG9uZSwgdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgYXMgaXRcclxuICAgICAqIHdpbGwgaW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyA8Y29kZT4uamFyPC9jb2RlPiBmaWxlIGJ5IGFcclxuICAgICAqIGxhcmdlIGFtb3VudC5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgTHVhSmF2YUNhbGxiYWNrIHtcclxuICAgICAgICBsdWFGdW5jdGlvbihMKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFic3RyYWN0IGNsYXNzIGVycm9yXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTHVhSmF2YUNhbGxiYWNrID0gTHVhSmF2YUNhbGxiYWNrO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9THVhSmF2YUNhbGxiYWNrLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9IYXNodGFibGVcIiwgXCIuLi9qYXZhL1N5c3RlbVV0aWxcIiwgXCIuLi9qYXZhL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiLCBcIi4vTHVhXCIsIFwiLi9FbnVtXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5MdWFUYWJsZSA9IHZvaWQgMDtcclxuICAgIGNvbnN0IEhhc2h0YWJsZV8xID0gcmVxdWlyZShcIi4uL2phdmEvSGFzaHRhYmxlXCIpO1xyXG4gICAgY29uc3QgU3lzdGVtVXRpbF8xID0gcmVxdWlyZShcIi4uL2phdmEvU3lzdGVtVXRpbFwiKTtcclxuICAgIGNvbnN0IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2phdmEvSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICBjb25zdCBFbnVtXzEgPSByZXF1aXJlKFwiLi9FbnVtXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL0x1YVRhYmxlLmphdmEjMSAkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB0aGF0IG1vZGVscyBMdWEncyB0YWJsZXMuICBFYWNoIEx1YSB0YWJsZSBpcyBhbiBpbnN0YW5jZSBvZlxyXG4gICAgICogdGhpcyBjbGFzcy4gIFdoaWxzdCB5b3UgY2FuIGNsZWFybHkgc2VlIHRoYXQgdGhpcyBjbGFzcyBleHRlbmRzXHJcbiAgICAgKiB7QGxpbmsgamF2YS51dGlsLkhhc2h0YWJsZX0geW91IHNob3VsZCBpbiBubyB3YXkgcmVseSB1cG9uIHRoYXQuXHJcbiAgICAgKiBDYWxsaW5nIGFueSBtZXRob2RzIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluIHRoaXMgY2xhc3MgKGJ1dCBhcmVcclxuICAgICAqIGRlZmluZWQgaW4gYSBzdXBlciBjbGFzcykgaXMgZXh0cmVtZWx5IGRlcHJlY2F0ZWQuXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIEx1YVRhYmxlIGV4dGVuZHMgSGFzaHRhYmxlXzEuSGFzaHRhYmxlIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgLy9UT0RPOuaaguaXtuWxj+iUvVxyXG4gICAgICAgICAgICBzdXBlcigxKTtcclxuICAgICAgICAgICAgdGhpcy5fbWV0YXRhYmxlID0gbnVsbDsgLy8gPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXJyYXkgdXNlZCBzbyB0aGF0IHRhYmxlcyBhY2Nlc3NlZCBsaWtlIGFycmF5cyBhcmUgbW9yZSBlZmZpY2llbnQuXHJcbiAgICAgICAgICAgICAqIEFsbCBlbGVtZW50cyBzdG9yZWQgYXQgYW4gaW50ZWdlciBpbmRleCwgPHZhcj5pPC92YXI+LCBpbiB0aGVcclxuICAgICAgICAgICAgICogcmFuZ2UgWzEsc2l6ZUFycmF5XSBhcmUgc3RvcmVkIGF0IDxjb2RlPmFycmF5W2ktMV08L2NvZGU+LlxyXG4gICAgICAgICAgICAgKiBUaGlzIHNwZWVkIGFuZCBzcGFjZSB1c2FnZSBmb3IgYXJyYXktbGlrZSBhY2Nlc3MuXHJcbiAgICAgICAgICAgICAqIFdoZW4gdGhlIHRhYmxlIGlzIHJlaGFzaGVkIHRoZSBhcnJheSdzIHNpemUgaXMgY2hvc2VuIHRvIGJlIHRoZVxyXG4gICAgICAgICAgICAgKiBsYXJnZXN0IHBvd2VyIG9mIDIgc3VjaCB0aGF0IGF0IGxlYXN0IGhhbGYgdGhlIGVudHJpZXMgYXJlXHJcbiAgICAgICAgICAgICAqIG9jY3VwaWVkLiAgRGVmYXVsdCBhY2Nlc3MgZ3JhbnRlZCBmb3Ige0BsaW5rIEVudW19IGNsYXNzLCBkbyBub3RcclxuICAgICAgICAgICAgICogYWJ1c2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9hcnJheSA9IEx1YVRhYmxlLlpFUk87IC8vT2JqZWN0W11cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVxdWFsIHRvIDxjb2RlPmFycmF5Lmxlbmd0aDwvY29kZT4uICBEZWZhdWx0IGFjY2VzcyBncmFudGVkIGZvclxyXG4gICAgICAgICAgICAgKiB7QGxpbmsgRW51bX0gY2xhc3MsIGRvIG5vdCBhYnVzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVBcnJheSA9IDA7IC8vID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIDxjb2RlPnRydWU8L2NvZGU+IHdoZW5ldmVyIHdlIGFyZSBpbiB0aGUge0BsaW5rICNyZWhhc2h9XHJcbiAgICAgICAgICAgICAqIG1ldGhvZC4gIEF2b2lkcyBpbmZpbml0ZSByZWhhc2ggbG9vcHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pbnJlaGFzaCA9IGZhbHNlOyAvLyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGcmVzaCBMdWFUYWJsZSB3aXRoIGhpbnRzIGZvciBwcmVhbGxvY2F0aW5nIHRvIHNpemUuXHJcbiAgICAgICAgICogQHBhcmFtIG5hcnJheSAgbnVtYmVyIG9mIGFycmF5IHNsb3RzIHRvIHByZWFsbG9jYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSBuaGFzaCAgIG51bWJlciBvZiBoYXNoIHNsb3RzIHRvIHByZWFsbG9jYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQobmFycmF5LCBuaGFzaCkge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogc3VwZXIobmhhc2gpIGlzbid0IGNsZWFybHkgY29ycmVjdCBhcyBhZGRpbmcgbmhhc2ggaGFzaFxyXG4gICAgICAgICAgICAvLyB0YWJsZSBlbnRyaWVzIHdpbGwgY2F1c2VzIGEgcmVoYXNoIHdpdGggdGhlIHVzdWFsIGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgIC8vICh3aGljaCByZWhhc2hlcyB3aGVuIHJhdGlvIG9mIGVudHJpZXMgdG8gY2FwYWNpdHkgZXhjZWVkcyB0aGVcclxuICAgICAgICAgICAgLy8gbG9hZCBmYWN0b3Igb2YgMC43NSkuICBQZXJoYXBzIGlkZWFsbHkgd2Ugd291bGQgc2l6ZSB0aGUgaGFzaFxyXG4gICAgICAgICAgICAvLyB0YWJsZXMgc3VjaCB0aGF0IGFkZGluZyBuaGFzaCBlbnRyaWVzIHdpbGwgbm90IGNhdXNlIGEgcmVoYXNoLlxyXG4gICAgICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgICAgIC8vc3VwZXIobmhhc2gpOyBcclxuICAgICAgICAgICAgdGhpcy5fYXJyYXkgPSBuZXcgQXJyYXkobmFycmF5KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYXJyYXk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXJyYXlbaV0gPSBMdWFfMS5MdWEuTklMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVBcnJheSA9IG5hcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW1wbGVtZW50cyBkaXNjcmltaW5hdGluZyBlcXVhbGl0eS4gIDxjb2RlPm8xLmVxdWFscyhvMikgPT0gKG8xID09XHJcbiAgICAgICAgICogbzIpIDwvY29kZT4uICBUaGlzIG1ldGhvZCBpcyBub3QgbmVjZXNzYXJ5IGluIENMREMsIGl0J3Mgb25seVxyXG4gICAgICAgICAqIG5lY2Vzc2FyeSBpbiBKMlNFIGJlY2F1c2UgamF2YS51dGlsLkhhc2h0YWJsZSBvdmVycmlkZXMgZXF1YWxzLlxyXG4gICAgICAgICAqIEBwYXJhbSBvICB0aGUgcmVmZXJlbmNlIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgd2hlbiBlcXVhbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBlcXVhbHMobykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcyA9PSBvO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlZCB0byBhdm9pZCBDaGVja3N0eWxlIHdhcm5pbmcuICBUaGlzIG1ldGhvZCBpcyBub3QgbmVjZXNzYXJ5XHJcbiAgICAgICAgICogZm9yIGNvcnJlY3RuZXNzIChpbiBuZWl0aGVyIEpNRSBub3IgSlNFKSwgaXQncyBvbmx5IHByb3ZpZGVkIHRvXHJcbiAgICAgICAgICogcmVtb3ZlIGEgQ2hlY2tzdHlsZSB3YXJuaW5nLlxyXG4gICAgICAgICAqIFNpbmNlIHtAbGluayAjZXF1YWxzfSBpbXBsZW1lbnRzIHRoZSBtb3N0IGRpc2NyaW1pbmF0aW5nXHJcbiAgICAgICAgICogZXF1YWxpdHkgcG9zc2libGUsIHRoaXMgbWV0aG9kIGNhbiBoYXZlIGFueSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJuIGFuIGludC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGhhc2hDb2RlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuaWRlbnRpdHlIYXNoQ29kZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGFycmF5aW5kZXgoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGtleSkgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IGQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PSBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xOyAvLyAna2V5JyBkaWQgbm90IG1hdGNoIHNvbWUgY29uZGl0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBjb21wdXRlc2l6ZXMobnVtcyAvKmludFtdICovLCBuYXJyYXkgLyppbnRbXSAqLykge1xyXG4gICAgICAgICAgICB2YXIgdCA9IG5hcnJheVswXTtcclxuICAgICAgICAgICAgdmFyIGEgPSAwOyAvLyBudW1iZXIgb2YgZWxlbWVudHMgc21hbGxlciB0aGFuIDJeaVxyXG4gICAgICAgICAgICB2YXIgbmEgPSAwOyAvLyBudW1iZXIgb2YgZWxlbWVudHMgdG8gZ28gdG8gYXJyYXkgcGFydFxyXG4gICAgICAgICAgICB2YXIgbiA9IDA7IC8vIG9wdGltYWwgc2l6ZSBmb3IgYXJyYXkgcGFydFxyXG4gICAgICAgICAgICB2YXIgdHdvdG9pID0gMTsgLy8gMl5pXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyB0d290b2kgLyAyIDwgdDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtc1tpXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhICs9IG51bXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPiB0d290b2kgLyAyKSAvLyBtb3JlIHRoYW4gaGFsZiBlbGVtZW50cyBwcmVzZW50P1xyXG4gICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0d290b2k7IC8vIG9wdGltYWwgc2l6ZSAodGlsbCBub3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hID0gYTsgLy8gYWxsIGVsZW1lbnRzIHNtYWxsZXIgdGhhbiBuIHdpbGwgZ28gdG8gYXJyYXkgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhID09IHQpIC8vIGFsbCBlbGVtZW50cyBhbHJlYWR5IGNvdW50ZWRcclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0d290b2kgKj0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuYXJyYXlbMF0gPSBuO1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IG5hcnJheVswXS8yIDw9IG5hICYmIG5hIDw9IG5hcnJheVswXVxyXG4gICAgICAgICAgICByZXR1cm4gbmE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvdW50aW50KGtleSwgbnVtcyAvKmludFtdICovKSB7XHJcbiAgICAgICAgICAgIHZhciBrID0gTHVhVGFibGUuYXJyYXlpbmRleChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoMCA8IGsgJiYgayA8PSBMdWFUYWJsZS5NQVhBU0laRSkgLy8gaXMgJ2tleScgYW4gYXBwcm9wcmlhdGUgYXJyYXkgaW5kZXg/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICArK251bXNbTHVhVGFibGUuY2VpbGxvZzIoayldOyAvLyBjb3VudCBhcyBzdWNoXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbnVtdXNlYXJyYXkobnVtcyAvKmludFtdICovKSB7XHJcbiAgICAgICAgICAgIHZhciBhdXNlID0gMDsgLy8gc3VtbWF0aW9uIG9mICdudW1zJ1xyXG4gICAgICAgICAgICB2YXIgaSA9IDE7IC8vIGNvdW50IHRvIHRyYXZlcnNlIGFsbCBhcnJheSBrZXlzXHJcbiAgICAgICAgICAgIHZhciB0dGxnID0gMTsgLy8gMl5sZ1xyXG4gICAgICAgICAgICBmb3IgKHZhciBsZyA9IDA7IGxnIDw9IEx1YVRhYmxlLk1BWEJJVFM7ICsrbGcpIC8vIGZvciBlYWNoIHNsaWNlXHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGMgPSAwOyAvLyBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICB2YXIgbGltID0gdHRsZztcclxuICAgICAgICAgICAgICAgIGlmIChsaW0gPiB0aGlzLl9zaXplQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW0gPSB0aGlzLl9zaXplQXJyYXk7IC8vIGFkanVzdCB1cHBlciBsaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gbGltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBubyBtb3JlIGVsZW1lbnRzIHRvIGNvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY291bnQgZWxlbWVudHMgaW4gcmFuZ2UgKDJeKGxnLTEpLCAyXmxnXVxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPD0gbGltOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXJyYXlbaSAtIDFdICE9IEx1YV8xLkx1YS5OSUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKytsYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBudW1zW2xnXSArPSBsYztcclxuICAgICAgICAgICAgICAgIGF1c2UgKz0gbGM7XHJcbiAgICAgICAgICAgICAgICB0dGxnICo9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGF1c2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG51bXVzZWhhc2gobnVtcyAvKmludFtdICovLCBwbmFzaXplIC8qaW50W10gKi8pIHtcclxuICAgICAgICAgICAgdmFyIHRvdGFsdXNlID0gMDsgLy8gdG90YWwgbnVtYmVyIG9mIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIHZhciBhdXNlID0gMDsgLy8gc3VtbWF0aW9uIG9mIG51bXNcclxuICAgICAgICAgICAgdmFyIGU7XHJcbiAgICAgICAgICAgIGUgPSBzdXBlci5rZXlzKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChlLmhhc01vcmVFbGVtZW50cygpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbyA9IGUubmV4dEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGF1c2UgKz0gdGhpcy5jb3VudGludChvLCBudW1zKTtcclxuICAgICAgICAgICAgICAgICsrdG90YWx1c2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG5hc2l6ZVswXSArPSBhdXNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdG90YWx1c2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBuYXNpemUgIChuZXcpIHNpemUgb2YgYXJyYXkgcGFydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2l6ZShuYXNpemUpIHtcclxuICAgICAgICAgICAgaWYgKG5hc2l6ZSA9PSB0aGlzLl9zaXplQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3YXJyYXkgPSBuZXcgQXJyYXkobmFzaXplKTsgLy9PYmplY3RbXSBcclxuICAgICAgICAgICAgaWYgKG5hc2l6ZSA+IHRoaXMuX3NpemVBcnJheSkgLy8gYXJyYXkgcGFydCBtdXN0IGdyb3c/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgbmV3IGFycmF5IHNsb3RzLCBmcm9tIHNpemVBcnJheSB0byBuYXNpemUtMSwgbXVzdFxyXG4gICAgICAgICAgICAgICAgLy8gYmUgZmlsbGVkIHdpdGggdGhlaXIgdmFsdWVzIGZyb20gdGhlIGhhc2ggcGFydC5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSB0d28gc3RyYXRlZ2llczpcclxuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbmV3IGFycmF5IHNsb3RzLCBhbmQgbG9vayB1cCBlYWNoIGluZGV4IGluIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gaGFzaCBwYXJ0IHRvIHNlZSBpZiBpdCBoYXMgYSB2YWx1ZTsgb3IsXHJcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGhhc2ggcGFydCBhbmQgc2VlIGlmIGVhY2gga2V5IGJlbG9uZ3MgaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBhcnJheSBwYXJ0LlxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSBjaG9vc2UgdGhlIGZpcnN0IGFsZ29yaXRobS5cclxuICAgICAgICAgICAgICAgIC8vIDp0b2RvOiBjb25zaWRlciB1c2luZyBzZWNvbmQgYWxnb3JpdGhtLCBwb3NzaWJseSBkeW5hbWljYWxseS5cclxuICAgICAgICAgICAgICAgIFN5c3RlbVV0aWxfMS5TeXN0ZW1VdGlsLmFycmF5Y29weSh0aGlzLl9hcnJheSwgMCwgbmV3YXJyYXksIDAsIHRoaXMuX2FycmF5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fYXJyYXkubGVuZ3RoOyBpIDwgbmFzaXplOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gbmV3IE51bWJlcihpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBzdXBlci5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBMdWFfMS5MdWEuTklMO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXdhcnJheVtpXSA9IHY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hc2l6ZSA8IHRoaXMuX3NpemVBcnJheSkgLy8gYXJyYXkgcGFydCBtdXN0IHNocmluaz9cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgZWxlbWVudHMgZnJvbSBhcnJheSBzbG90cyBuYXNpemUgdG8gc2l6ZUFycmF5LTEgdG8gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBoYXNoIHBhcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBuYXNpemU7IGkgPCB0aGlzLl9zaXplQXJyYXk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcnJheVtpXSAhPSBMdWFfMS5MdWEuTklMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBOdW1iZXIoaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlci5wdXQoa2V5LCB0aGlzLl9hcnJheVtpXSk7IC8vVE9ETzpcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5hcnJheWNvcHkodGhpcy5fYXJyYXksIDAsIG5ld2FycmF5LCAwLCBuZXdhcnJheS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FycmF5ID0gbmV3YXJyYXk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVBcnJheSA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVoYXNoKCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkaW5yZWhhc2ggPSB0aGlzLl9pbnJlaGFzaDtcclxuICAgICAgICAgICAgdGhpcy5faW5yZWhhc2ggPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIW9sZGlucmVoYXNoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFzaXplID0gbmV3IEFycmF5KDEpOyAvL2ludFtdIFxyXG4gICAgICAgICAgICAgICAgdmFyIG51bXMgPSBuZXcgQXJyYXkoTHVhVGFibGUuTUFYQklUUyArIDEpOyAvL2ludFtdIFxyXG4gICAgICAgICAgICAgICAgbmFzaXplWzBdID0gdGhpcy5udW11c2VhcnJheShudW1zKTsgLy8gY291bnQga2V5cyBpbiBhcnJheSBwYXJ0XHJcbiAgICAgICAgICAgICAgICB2YXIgdG90YWx1c2UgPSBuYXNpemVbMF07XHJcbiAgICAgICAgICAgICAgICB0b3RhbHVzZSArPSB0aGlzLm51bXVzZWhhc2gobnVtcywgbmFzaXplKTtcclxuICAgICAgICAgICAgICAgIHZhciBuYSA9IEx1YVRhYmxlLmNvbXB1dGVzaXplcyhudW1zLCBuYXNpemUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUobmFzaXplWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXBlci5yZWhhc2goKTtcclxuICAgICAgICAgICAgdGhpcy5faW5yZWhhc2ggPSBvbGRpbnJlaGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0dGVyIGZvciBtZXRhdGFibGUgbWVtYmVyLlxyXG4gICAgICAgICAqIEByZXR1cm4gIFRoZSBtZXRhdGFibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IG1ldGF0YWJsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ldGF0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0dGVyIGZvciBtZXRhdGFibGUgbWVtYmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhdGFibGUgIFRoZSBtZXRhdGFibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gOnRvZG86IFN1cHBvcnQgbWV0YXRhYmxlJ3MgX19nYyBhbmQgX19tb2RlIGtleXMgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAvLyAgICAgICAgVGhpcyBpbnZvbHZlcyBkZXRlY3Rpbmcgd2hlbiB0aG9zZSBrZXlzIGFyZSBwcmVzZW50IGluIHRoZVxyXG4gICAgICAgIC8vICAgICAgICBtZXRhdGFibGUsIGFuZCBjaGFuZ2luZyBhbGwgdGhlIGVudHJpZXMgaW4gdGhlIEhhc2h0YWJsZVxyXG4gICAgICAgIC8vICAgICAgICB0byBiZSBpbnN0YW5jZSBvZiBqYXZhLmxhbmcuUmVmIGFzIGFwcHJvcHJpYXRlLlxyXG4gICAgICAgIHNldE1ldGF0YWJsZShtZXRhdGFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWV0YXRhYmxlID0gbWV0YXRhYmxlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1cHBvcnRzIEx1YSdzIGxlbmd0aCAoIykgb3BlcmF0b3IuICBNb3JlIG9yIGxlc3MgZXF1aXZhbGVudCB0b1xyXG4gICAgICAgICAqIGx1YUhfZ2V0biBhbmQgdW5ib3VuZF9zZWFyY2ggaW4gbHRhYmxlLmMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0bigpIHtcclxuICAgICAgICAgICAgdmFyIGogPSB0aGlzLl9zaXplQXJyYXk7XHJcbiAgICAgICAgICAgIGlmIChqID4gMCAmJiB0aGlzLl9hcnJheVtqIC0gMV0gPT0gTHVhXzEuTHVhLk5JTCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBib3VuZGFyeSBpbiB0aGUgYXJyYXkgcGFydDogKGJpbmFyeSkgc2VhcmNoIGZvciBpdFxyXG4gICAgICAgICAgICAgICAgdmFyIGkyID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqIC0gaTIgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSAoaTIgKyBqKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FycmF5W20gLSAxXSA9PSBMdWFfMS5MdWEuTklMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaTIgPSBtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB1bmJvdW5kX3NlYXJjaFxyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAvLyBGaW5kICdpJyBhbmQgJ2onIHN1Y2ggdGhhdCBpIGlzIHByZXNlbnQgYW5kIGogaXMgbm90LlxyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5nZXRudW0oaikgIT0gTHVhXzEuTHVhLk5JTCkge1xyXG4gICAgICAgICAgICAgICAgaSA9IGo7XHJcbiAgICAgICAgICAgICAgICBqICo9IDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDApIC8vIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhdGhvbG9naWNhbCBjYXNlLiAgTGluZWFyIHNlYXJjaC5cclxuICAgICAgICAgICAgICAgICAgICBpID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5nZXRudW0oaSkgIT0gTHVhXzEuTHVhLk5JTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpIC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBiaW5hcnkgc2VhcmNoIGJldHdlZW4gaSBhbmQgalxyXG4gICAgICAgICAgICB3aGlsZSAoaiAtIGkgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbTIgPSAoaSArIGopIC8gMjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldG51bShtMikgPT0gTHVhXzEuTHVhLk5JTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGogPSBtMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlrZSB7QGxpbmsgamF2YS51dGlsLkhhc2h0YWJsZSNnZXR9LiAgRW5zdXJlcyB0aGF0IGluZGV4ZXNcclxuICAgICAgICAgKiB3aXRoIG5vIHZhbHVlIHJldHVybiB7QGxpbmsgTHVhI05JTH0uICBJbiBvcmRlciB0byBnZXQgdGhlIGNvcnJlY3RcclxuICAgICAgICAgKiBiZWhhdmlvdXIgZm9yIDxjb2RlPnRbbmlsXTwvY29kZT4sIHRoaXMgY29kZSBhc3N1bWVzIHRoYXQgTHVhLk5JTFxyXG4gICAgICAgICAqIGlzIG5vbi08Y29kZT5udWxsPC9jb2RlPi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRsdWEoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGtleSkgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA8PSB0aGlzLl9zaXplQXJyYXkgJiYgZCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHIgPSBzdXBlci5fZ2V0KGtleSk7IC8vVE9ETzpnZXRcclxuICAgICAgICAgICAgaWYgKHIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgciA9IEx1YV8xLkx1YS5OSUw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpa2Uge0BsaW5rICNnZXRsdWEoT2JqZWN0KX0gYnV0IHRoZSByZXN1bHQgaXMgd3JpdHRlbiBpbnRvXHJcbiAgICAgICAgICogdGhlIDx2YXI+dmFsdWU8L3Zhcj4ge0BsaW5rIFNsb3R9LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fZ2V0bHVhKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGtleS5yID09IEx1YV8xLkx1YS5OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0ga2V5LmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA8PSB0aGlzLl9zaXplQXJyYXkgJiYgZCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0T2JqZWN0KHRoaXMuX2FycmF5W2kgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHIgPSBzdXBlci5fZ2V0KGtleS5hc09iamVjdCgpKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICBpZiAociA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByID0gTHVhXzEuTHVhLk5JTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZS5zZXRPYmplY3Qocik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBMaWtlIGdldCBmb3IgbnVtZXJpYyAoaW50ZWdlcikga2V5cy4gKi9cclxuICAgICAgICBnZXRudW0oaykge1xyXG4gICAgICAgICAgICBpZiAoayA8PSB0aGlzLl9zaXplQXJyYXkgJiYgayA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbayAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByID0gc3VwZXIuX2dldChuZXcgTnVtYmVyKGspKTsgLy9UT0RPOmdldFxyXG4gICAgICAgICAgICBpZiAociA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTHVhXzEuTHVhLk5JTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlrZSB7QGxpbmsgamF2YS51dGlsLkhhc2h0YWJsZSNwdXR9IGJ1dCBlbmFibGVzIEx1YSdzIHNlbWFudGljc1xyXG4gICAgICAgICAqIGZvciA8Y29kZT5uaWw8L2NvZGU+O1xyXG4gICAgICAgICAqIEluIHBhcnRpY3VsYXIgdGhhdCA8Y29kZT54ID0gbmlsPC9uaWw+XHJcbiAgICAgICAgICogZGVsZXRlcyA8Y29kZT54PC9jb2RlPi5cclxuICAgICAgICAgKiBBbmQgYWxzbyB0aGF0IDxjb2RlPnRbbmlsXTwvY29kZT4gcmFpc2VzIGFuIGVycm9yLlxyXG4gICAgICAgICAqIEdlbmVyYWxseSwgdXNlcnMgb2YgSmlsbCBzaG91bGQgYmUgdXNpbmdcclxuICAgICAgICAgKiB7QGxpbmsgTHVhI3NldFRhYmxlfSBpbnN0ZWFkIG9mIHRoaXMuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1dGx1YU9iaihMLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gMC4wO1xyXG4gICAgICAgICAgICB2YXIgaSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOyAvL1RPRE86XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT0gTHVhXzEuTHVhLk5JTCkge1xyXG4gICAgICAgICAgICAgICAgTC5nUnVuZXJyb3IoXCJ0YWJsZSBpbmRleCBpcyBuaWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSA9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBkID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGogPSBkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT0gZCAmJiBqID49IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0gajsgLy8gd2lsbCBjYXVzZSBhZGRpdGlvbmFsIGNoZWNrIGZvciBhcnJheSBwYXJ0IGxhdGVyIGlmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFycmF5IHBhcnQgY2hlY2sgZmFpbHMgbm93LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDw9IHRoaXMuX3NpemVBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcnJheVtpIC0gMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEwuZ1J1bmVycm9yKFwidGFibGUgaW5kZXggaXMgTmFOXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBDb25zaWRlciBjaGVja2luZyBrZXkgZm9yIE5hTiAoUFVDLVJpbyBkb2VzKVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gTHVhXzEuTHVhLk5JTCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXBlci5wdXQoa2V5LCB2YWx1ZSk7IC8vVE9ETzpcclxuICAgICAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzb21ldGltZXMgdGhlIGNhbGwgdG8gc3VwZXIucHV0XHJcbiAgICAgICAgICAgIC8vIGNhbiByZWhhc2ggYW5kIHRoZSBuZXcgKGssdikgcGFpciBzaG91bGQgYmUgaW4gdGhlIGFycmF5IHBhcnRcclxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHJlaGFzaCwgYnV0IGlzIHN0aWxsIGluIHRoZSBoYXNoIHBhcnQuXHJcbiAgICAgICAgICAgIGlmIChpIDw9IHRoaXMuX3NpemVBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FycmF5W2kgLSAxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1dGx1YVNsb3QoTCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOyAvL1RPRE86XHJcbiAgICAgICAgICAgIGlmIChrZXkuciA9PSBMdWFfMS5MdWEuTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaiA9IGtleS5kO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT0ga2V5LmQgJiYgaiA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPD0gdGhpcy5fc2l6ZUFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FycmF5W2kgLSAxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGtleS5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEwuZ1J1bmVycm9yKFwidGFibGUgaW5kZXggaXMgTmFOXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBrID0ga2V5LmFzT2JqZWN0KCk7XHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBjb25zaWRlciBzb21lIHNvcnQgb2YgdGFpbCBtZXJnZSB3aXRoIHRoZSBvdGhlciBwdXRsdWFcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IEx1YV8xLkx1YS5OSUwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGspO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1cGVyLnB1dChrLCB2YWx1ZSk7IC8vVE9ETzpcclxuICAgICAgICAgICAgaWYgKGkgPD0gdGhpcy5fc2l6ZUFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShrKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FycmF5W2kgLSAxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpa2UgcHV0IGZvciBudW1lcmljIChpbnRlZ2VyKSBrZXlzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1dG51bShrLCB2KSB7XHJcbiAgICAgICAgICAgIGlmIChrIDw9IHRoaXMuX3NpemVBcnJheSAmJiBrID49IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FycmF5W2sgLSAxXSA9IHY7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhlIGtleSBjYW4gbmV2ZXIgYmUgTklMIHNvIHB1dGx1YSB3aWxsIG5ldmVyIG5vdGljZSB0aGF0IGl0cyBMXHJcbiAgICAgICAgICAgIC8vIGFyZ3VtZW50IGlzIG51bGwuXHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBvcHRpbWlzYXRpb24gdG8gYXZvaWQgcHV0bHVhIGNoZWNraW5nIGZvciBhcnJheSBwYXJ0IGFnYWluXHJcbiAgICAgICAgICAgIHRoaXMucHV0bHVhT2JqKG51bGwsIG5ldyBOdW1iZXIoayksIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEbyBub3QgdXNlLCBpbXBsZW1lbnRhdGlvbiBleGlzdHMgb25seSB0byBnZW5lcmF0ZSBkZXByZWNhdGVkXHJcbiAgICAgICAgICogd2FybmluZy5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgZ2V0bHVhIGluc3RlYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2dldChrZXkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLklsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXlzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVudW1fMS5FbnVtKHRoaXMsIHN1cGVyLmtleXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERvIG5vdCB1c2UsIGltcGxlbWVudGF0aW9uIGV4aXN0cyBvbmx5IHRvIGdlbmVyYXRlIGRlcHJlY2F0ZWRcclxuICAgICAgICAgKiB3YXJuaW5nLlxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBwdXRsdWEgaW5zdGVhZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVxdWl2YWxlbnQgdG8gbHVhT19sb2cyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBvTG9nMih4KSB7XHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgeCA+PSAwXHJcbiAgICAgICAgICAgIHZhciBsID0gLTE7XHJcbiAgICAgICAgICAgIHdoaWxlICh4ID49IDI1Nikge1xyXG4gICAgICAgICAgICAgICAgbCArPSA4O1xyXG4gICAgICAgICAgICAgICAgeCA+Pj49IDg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGwgKyBMdWFUYWJsZS5MT0cyW3hdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgY2VpbGxvZzIoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTHVhVGFibGUub0xvZzIoeCAtIDEpICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgYXJyYXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgc2l6ZUFycmF5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZUFycmF5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTHVhVGFibGUgPSBMdWFUYWJsZTtcclxuICAgIEx1YVRhYmxlLk1BWEJJVFMgPSAyNjtcclxuICAgIEx1YVRhYmxlLk1BWEFTSVpFID0gMSA8PCBMdWFUYWJsZS5NQVhCSVRTO1xyXG4gICAgTHVhVGFibGUuWkVSTyA9IG5ldyBBcnJheSgwKTsgLy9maW5hbCBPYmplY3RbXVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGJ5IG9Mb2cyLiAgRE8gTk9UIE1PRElGWS5cclxuICAgICAqL1xyXG4gICAgTHVhVGFibGUuTE9HMiA9IFtcclxuICAgICAgICAwLCAxLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LFxyXG4gICAgICAgIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsIDYsXHJcbiAgICAgICAgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNyxcclxuICAgICAgICA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LFxyXG4gICAgICAgIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsXHJcbiAgICAgICAgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCxcclxuICAgICAgICA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LFxyXG4gICAgICAgIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDhcclxuICAgIF07XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MdWFUYWJsZS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuTHVhVXNlcmRhdGEgPSB2b2lkIDA7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvTHVhVXNlcmRhdGEuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIE1vZGVscyBhbiBhcmJpdHJhcnkgSmF2YSByZWZlcmVuY2UgYXMgYSBMdWEgdmFsdWUuXHJcbiAgICAgKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgZmFjaWxpdHkgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSB1c2VyZGF0YVxyXG4gICAgICogZmFjaWxpdHkgcHJvdmlkZWQgYnkgdGhlIFBVQy1SaW8gaW1wbGVtZW50YXRpb24uICBJdCBoYXMgdHdvIHByaW1hcnlcclxuICAgICAqIHVzZXM6IHRoZSBmaXJzdCBpcyB3aGVuIHlvdSB3aXNoIHRvIHN0b3JlIGFuIGFyYml0cmFyeSBKYXZhIHJlZmVyZW5jZVxyXG4gICAgICogaW4gYSBMdWEgdGFibGU7IHRoZSBzZWNvbmQgaXMgd2hlbiB5b3Ugd2lzaCB0byBjcmVhdGUgYSBuZXcgTHVhIHR5cGVcclxuICAgICAqIGJ5IGRlZmluaW5nIGFuIG9wYXF1ZSBvYmplY3Qgd2l0aCBtZXRhbWV0aG9kcy4gIFRoZSBmb3JtZXIgaXNcclxuICAgICAqIHBvc3NpYmxlIGJlY2F1c2UgYSA8Y29kZT5MdWFVc2VyZGF0YTwvY29kZT4gY2FuIGJlIHN0b3JlZCBpbiB0YWJsZXMsXHJcbiAgICAgKiBhbmQgcGFzc2VkIHRvIGZ1bmN0aW9ucywganVzdCBsaWtlIGFueSBvdGhlciBMdWEgdmFsdWUuICBUaGUgbGF0dGVyXHJcbiAgICAgKiBpcyBwb3NzaWJsZSBiZWNhdXNlIGVhY2ggPGNvZGU+THVhVXNlcmRhdGE8L2NvZGU+IHN1cHBvcnRzIGFcclxuICAgICAqIG1ldGF0YWJsZS5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgTHVhVXNlcmRhdGEge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyYXBzIGFuIGFyYml0cmFyeSBKYXZhIHJlZmVyZW5jZS4gIFRvIHJldHJpZXZlIHRoZSByZWZlcmVuY2UgdGhhdFxyXG4gICAgICAgICAqIHdhcyB3cmFwcGVkLCB1c2Uge0BsaW5rIEx1YSN0b1VzZXJkYXRhfS5cclxuICAgICAgICAgKiBAcGFyYW0gIG8gVGhlIEphdmEgcmVmZXJlbmNlIHRvIHdyYXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3RydWN0b3Iobykge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXRhdGFibGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9lbnYgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl91c2VyZGF0YSA9IG87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHRlciBmb3IgdXNlcmRhdGEuXHJcbiAgICAgICAgICogQHJldHVybiB0aGUgdXNlcmRhdGEgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGlzXHJcbiAgICAgICAgICogaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IHVzZXJkYXRhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlcmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHRlciBmb3IgbWV0YXRhYmxlLlxyXG4gICAgICAgICAqIEByZXR1cm4gdGhlIG1ldGF0YWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgbWV0YXRhYmxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWV0YXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXR0ZXIgZm9yIG1ldGF0YWJsZS5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YXRhYmxlIFRoZSBtZXRhdGFibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0IG1ldGF0YWJsZShtZXRhdGFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWV0YXRhYmxlID0gbWV0YXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXR0ZXIgZm9yIGVudmlyb25tZW50LlxyXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGVudmlyb25tZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBlbnYoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHRlciBmb3IgZW52aXJvbm1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIGVudiAgVGhlIGVudmlyb25tZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldCBlbnYoZW52KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudiA9IGVudjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkx1YVVzZXJkYXRhID0gTHVhVXNlcmRhdGE7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MdWFVc2VyZGF0YS5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL2phdmEvQ2hhcmFjdGVyXCIsIFwiLi9MdWFcIiwgXCIuL1N5bnRheFwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuTWF0Y2hTdGF0ZSA9IHZvaWQgMDtcclxuICAgIGNvbnN0IENoYXJhY3Rlcl8xID0gcmVxdWlyZShcIi4uL2phdmEvQ2hhcmFjdGVyXCIpO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICBjb25zdCBTeW50YXhfMSA9IHJlcXVpcmUoXCIuL1N5bnRheFwiKTtcclxuICAgIC8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9TdHJpbmdMaWIuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICBjbGFzcyBNYXRjaFN0YXRlIHtcclxuICAgICAgICAvLyA6dG9kbzogY29uc2lkZXIgYWRkaW5nIHRoZSBwYXR0ZXJuIHN0cmluZyBhcyBhIG1lbWJlciAoYW5kIHJlbW92aW5nXHJcbiAgICAgICAgLy8gcCBwYXJhbWV0ZXIgZnJvbSBtZXRob2RzKS5cclxuICAgICAgICAvLyA6dG9kbzogY29uc2lkZXIgcmVtb3ZpbmcgZW5kIHBhcmFtZXRlciwgaWYgZW5kIGFsd2F5cyA9PSAvLyBzcmMubGVuZ3RoKClcclxuICAgICAgICBjb25zdHJ1Y3RvcihMLCBzcmMsIGVuZCkge1xyXG4gICAgICAgICAgICAvKiogVG90YWwgbnVtYmVyIG9mIGNhcHR1cmVzIChmaW5pc2hlZCBvciB1bmZpbmlzaGVkKS4gKi9cclxuICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSAwO1xyXG4gICAgICAgICAgICAvKiogRWFjaCBjYXB0dXJlIGVsZW1lbnQgaXMgYSAyLWVsZW1lbnQgYXJyYXkgb2YgKGluZGV4LCBsZW4pLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9jYXB0dXJlID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX0wgPSBMO1xyXG4gICAgICAgICAgICB0aGlzLl9zcmMgPSBzcmM7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IGVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGNhcHR1cmUgPHZhcj5pPC92YXI+LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNhcHR1cmVMZW4oaSkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2NhcHR1cmVbaV07IC8vKGludFtdKVxyXG4gICAgICAgICAgICByZXR1cm4gY1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW5pdCBpbmRleCBvZiBjYXB0dXJlIDx2YXI+aTwvdmFyPi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjYXB0dXJlSW5pdChpKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fY2FwdHVyZVtpXTsgLy8oaW50W10pXHJcbiAgICAgICAgICAgIHJldHVybiBjWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSAyLWVsZW1lbnQgYXJyYXkgZm9yIHRoZSBjYXB0dXJlIDx2YXI+aTwvdmFyPi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjYXB0dXJlKGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcHR1cmVbaV07IC8vKGludFtdKVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXBJbnZhbGlkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fTC5lcnJvcihcImludmFsaWQgY2FwdHVyZSBpbmRleFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFsQnJhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fTC5lcnJvcihcIm1hbGZvcm1lZCBwYXR0ZXJuIChtaXNzaW5nICdbJylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhcFVuZmluaXNoZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9MLmVycm9yKFwidW5maW5pc2hlZCBjYXB0dXJlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYWxFc2MoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9MLmVycm9yKFwibWFsZm9ybWVkIHBhdHRlcm4gKGVuZHMgd2l0aCAnJScpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja19jYXB0dXJlKGwpIHtcclxuICAgICAgICAgICAgbCAtPSAnMScuY2hhckNvZGVBdCgwKTsgLy8gcmVsaWVzIG9uIHdyYXBhcm91bmQuXHJcbiAgICAgICAgICAgIGlmIChsID49IHRoaXMuX2xldmVsIHx8IHRoaXMuY2FwdHVyZUxlbihsKSA9PSBNYXRjaFN0YXRlLkNBUF9VTkZJTklTSEVEKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYXBJbnZhbGlkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXB0dXJlX3RvX2Nsb3NlKCkge1xyXG4gICAgICAgICAgICB2YXIgbGV2ID0gdGhpcy5fbGV2ZWw7XHJcbiAgICAgICAgICAgIGZvciAobGV2LS07IGxldiA+PSAwOyBsZXYtLSlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmVMZW4obGV2KSA9PSBNYXRjaFN0YXRlLkNBUF9VTkZJTklTSEVEKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZXY7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcEludmFsaWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhc3NlbmQocCwgcGkpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChwLmNoYXJBdChwaSsrKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGNoU3RhdGUuTF9FU0MpOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc2VydCBwaSA8IHAubGVuZ3RoKCkgLy8gY2hlY2tlZCBieSBjYWxsZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpICsgMTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSBwaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFsQnJhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuY2hhckF0KHBpKSA9PSAnXicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrcGk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG8gLy8gbG9vayBmb3IgYSAnXSdcclxuICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gcGkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWxCcmEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuY2hhckNvZGVBdChwaSsrKSA9PSBNYXRjaFN0YXRlLkxfRVNDKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gcGkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFsQnJhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3BpOyAvLyBza2lwIGVzY2FwZXMgKGUuZy4gJyVdJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSBwaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWxCcmEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHAuY2hhckF0KHBpKSAhPSAnXScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwaSArIDE7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYyAgIGNoYXIgbWF0Y2guXHJcbiAgICAgICAgICogQHBhcmFtIGNsICBjaGFyYWN0ZXIgY2xhc3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIG1hdGNoX2NsYXNzKGMsIGNsKSB7XHJcbiAgICAgICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoQ2hhcmFjdGVyXzEuQ2hhcmFjdGVyLnRvTG93ZXJDYXNlKGNsKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gU3ludGF4XzEuU3ludGF4LmlzYWxwaGEoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBTeW50YXhfMS5TeW50YXguaXNjbnRybChjKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IFN5bnRheF8xLlN5bnRheC5pc2RpZ2l0KGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gU3ludGF4XzEuU3ludGF4LmlzbG93ZXIoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBTeW50YXhfMS5TeW50YXguaXNwdW5jdChjKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IFN5bnRheF8xLlN5bnRheC5pc3NwYWNlKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gU3ludGF4XzEuU3ludGF4LmlzdXBwZXIoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBTeW50YXhfMS5TeW50YXguaXNhbG51bShjKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IFN5bnRheF8xLlN5bnRheC5pc3hkaWdpdChjKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IChjID09IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNsID09IGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBDaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMb3dlckNhc2UoY2wpID8gcmVzIDogIXJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHBpICBpbmRleCBpbiBwIG9mIHN0YXJ0IG9mIGNsYXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSBlYyAgaW5kZXggaW4gcCBvZiBlbmQgb2YgY2xhc3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIG1hdGNoYnJhY2tldGNsYXNzKGMsIHAsIHBpLCBlYykge1xyXG4gICAgICAgICAgICAvLyA6dG9kbzogY29uc2lkZXIgY2hhbmdpbmcgY2hhciBjIHRvIGludCBjLCB0aGVuIC0xIGNvdWxkIGJlIHVzZWRcclxuICAgICAgICAgICAgLy8gcmVwcmVzZW50IGEgZ3VhcmQgdmFsdWUgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGFsbCBzdHJpbmdzIChhXHJcbiAgICAgICAgICAgIC8vIGJldHRlciBOVUwpLiAgLTEgb2YgY291cnNlIHdvdWxkIG1hdGNoIG5vIHBvc2l0aXZlIGNsYXNzLlxyXG4gICAgICAgICAgICAvLyBhc3NlcnQgcC5jaGFyQXQocGkpID09ICdbJztcclxuICAgICAgICAgICAgLy8gYXNzZXJ0IHAuY2hhckF0KGVjKSA9PSAnXSc7XHJcbiAgICAgICAgICAgIHZhciBzaWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAocC5jaGFyQ29kZUF0KHBpICsgMSkgPT0gJ14nLmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICAgICAgICAgIHNpZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgKytwaTsgLy8gc2tpcCB0aGUgJzYnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKCsrcGkgPCBlYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuY2hhckNvZGVBdChwaSkgPT0gTWF0Y2hTdGF0ZS5MX0VTQykge1xyXG4gICAgICAgICAgICAgICAgICAgICsrcGk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hfY2xhc3MoYywgcC5jaGFyQ29kZUF0KHBpKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocC5jaGFyQXQocGkgKyAxKSA9PSAnLScpICYmIChwaSArIDIgPCBlYykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwaSArPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmNoYXJDb2RlQXQocGkgLSAyKSA8PSBjICYmIGMgPD0gcC5jaGFyQ29kZUF0KHBpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAuY2hhckNvZGVBdChwaSkgPT0gYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICFzaWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBzaW5nbGVtYXRjaChjLCBwLCBwaSwgZXApIHtcclxuICAgICAgICAgICAgc3dpdGNoIChwLmNoYXJBdChwaSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBtYXRjaGVzIGFueSBjaGFyXHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoTWF0Y2hTdGF0ZS5MX0VTQyk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hfY2xhc3MoYywgcC5jaGFyQ29kZUF0KHBpICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hicmFja2V0Y2xhc3MoYywgcCwgcGksIGVwIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNoYXJDb2RlQXQocGkpID09IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2VuZXJhbGx5IGFsbCB0aGUgdmFyaW91cyBtYXRjaCBmdW5jdGlvbnMgZnJvbSBQVUMtUmlvIHdoaWNoIHRha2UgYVxyXG4gICAgICAgIC8vIE1hdGNoU3RhdGUgYW5kIHJldHVybiBhIFwiY29uc3QgY2hhciAqXCIgYXJlIHRyYW5zZm9ybWVkIGludG9cclxuICAgICAgICAvLyBpbnN0YW5jZSBtZXRob2RzIHRoYXQgdGFrZSBhbmQgcmV0dXJuIHN0cmluZyBpbmRleGVzLlxyXG4gICAgICAgIG1hdGNoYmFsYW5jZShzaSwgcCwgcGkpIHtcclxuICAgICAgICAgICAgaWYgKHBpICsgMSA+PSBwLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRoaXMuX0wuZXJyb3IoXCJ1bmJhbGFuY2VkIHBhdHRlcm5cIik7XHJcbiAgICAgICAgICAgIGlmIChzaSA+PSB0aGlzLl9lbmQgfHwgdGhpcy5fc3JjLmNoYXJBdChzaSkgIT0gcC5jaGFyQXQocGkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGIgPSBwLmNoYXJDb2RlQXQocGkpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHAuY2hhckNvZGVBdChwaSArIDEpO1xyXG4gICAgICAgICAgICB2YXIgY29udCA9IDE7XHJcbiAgICAgICAgICAgIHdoaWxlICgrK3NpIDwgdGhpcy5fZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3JjLmNoYXJDb2RlQXQoc2kpID09IGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb250ID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaSArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zcmMuY2hhckNvZGVBdChzaSkgPT0gYikge1xyXG4gICAgICAgICAgICAgICAgICAgICsrY29udDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7IC8vIHN0cmluZyBlbmRzIG91dCBvZiBiYWxhbmNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1heF9leHBhbmQoc2ksIHAsIHBpLCBlcCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7IC8vIGNvdW50cyBtYXhpbXVtIGV4cGFuZCBmb3IgaXRlbVxyXG4gICAgICAgICAgICB3aGlsZSAoc2kgKyBpIDwgdGhpcy5fZW5kICYmIE1hdGNoU3RhdGUuc2luZ2xlbWF0Y2godGhpcy5fc3JjLmNoYXJDb2RlQXQoc2kgKyBpKSwgcCwgcGksIGVwKSkge1xyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGtlZXBzIHRyeWluZyB0byBtYXRjaCB3aXRoIHRoZSBtYXhpbXVtIHJlcGV0aXRpb25zXHJcbiAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLm1hdGNoKHNpICsgaSwgcCwgZXAgKyAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMgPj0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgLS1pOyAvLyBlbHNlIGRpZG4ndCBtYXRjaDsgcmVkdWNlIDEgcmVwZXRpdGlvbiB0byB0cnkgYWdhaW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1pbl9leHBhbmQoc2ksIHAsIHBpLCBlcCkge1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMubWF0Y2goc2ksIHAsIGVwICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpIDwgdGhpcy5fZW5kICYmIE1hdGNoU3RhdGUuc2luZ2xlbWF0Y2godGhpcy5fc3JjLmNoYXJDb2RlQXQoc2kpLCBwLCBwaSwgZXApKVxyXG4gICAgICAgICAgICAgICAgICAgICsrc2k7IC8vIHRyeSB3aXRoIG9uZSBtb3JlIHJlcGV0aXRpb25cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy91bnJlYWNoYWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0X2NhcHR1cmUoc2ksIHAsIHBpLCB3aGF0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gbmV3IEFycmF5KHRoaXMuX2xldmVsICsgMSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtrID0gMDsga2sgPCB0ZW1wLmxlbmd0aDsgKytraykge1xyXG4gICAgICAgICAgICAgICAgdGVtcFtra10gPSB0aGlzLl9jYXB0dXJlW2trXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jYXB0dXJlID0gdGVtcDtcclxuICAgICAgICAgICAgdGhpcy5fY2FwdHVyZVt0aGlzLl9sZXZlbF0gPSBbc2ksIHdoYXRdO1xyXG4gICAgICAgICAgICArK3RoaXMuX2xldmVsO1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5tYXRjaChzaSwgcCwgcGkpO1xyXG4gICAgICAgICAgICBpZiAocmVzIDwgMCkgLy8gbWF0Y2ggZmFpbGVkXHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAtLXRoaXMuX2xldmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZF9jYXB0dXJlKHNpLCBwLCBwaSkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuY2FwdHVyZV90b19jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUobClbMV0gPSBzaSAtIHRoaXMuY2FwdHVyZUluaXQobCk7IC8vIGNsb3NlIGl0XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLm1hdGNoKHNpLCBwLCBwaSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPCAwKSAvLyBtYXRjaCBmYWlsZWQ/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUobClbMV0gPSBNYXRjaFN0YXRlLkNBUF9VTkZJTklTSEVEOyAvLyB1bmRvIGNhcHR1cmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXRjaF9jYXB0dXJlKHNpLCBsKSB7XHJcbiAgICAgICAgICAgIGwgPSB0aGlzLmNoZWNrX2NhcHR1cmUobCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmNhcHR1cmVMZW4obCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmQgLSBzaSA+PSBsZW4pIC8vVE9ETzogXHJcbiAgICAgICAgICAgICBcclxuICAgICAgICAgICAgLyogICAgICAgICAgICAgICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYy5yZWdpb25NYXRjaGVzKGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUluaXQobCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbikpKi9cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpICsgbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHNpICBpbmRleCBvZiBzdWJqZWN0IGF0IHdoaWNoIHRvIGF0dGVtcHQgbWF0Y2guXHJcbiAgICAgICAgICogQHBhcmFtIHAgICBwYXR0ZXJuIHN0cmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gcGkgIGluZGV4IGludG8gcGF0dGVybiAoZnJvbSB3aGljaCB0byBiZWluZyBtYXRjaGluZykuXHJcbiAgICAgICAgICogQHJldHVybiB0aGUgaW5kZXggb2YgdGhlIGVuZCBvZiB0aGUgbWF0Y2gsIC0xIGZvciBubyBtYXRjaC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBtYXRjaChzaSwgcCwgcGkpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb2RlIGhhcyBiZWVuIGNvbnNpZGVyYWJseSBjaGFuZ2VkIGluIHRoZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgICAvLyBmcm9tIEMgdG8gSmF2YS4gIFRoZXJlIGFyZSB0aGUgZm9sbG93aW5nIG5vbi1vYnZpb3VzIGNoYW5nZXM6XHJcbiAgICAgICAgICAgIC8vIC0gVGhlIEMgY29kZSByb3V0aW5lbHkgcmVsaWVzIG9uIE5VTCBiZWluZyBhY2Nlc3NpYmxlIGF0IHRoZSBlbmQgb2ZcclxuICAgICAgICAgICAgLy8gICB0aGUgcGF0dGVybiBzdHJpbmcuICBJbiBKYXZhIHdlIGNhbid0IGRvIHRoaXMsIHNvIHdlIHVzZSBtYW55XHJcbiAgICAgICAgICAgIC8vICAgbW9yZSBleHBsaWNpdCBsZW5ndGggY2hlY2tzIGFuZCBwdWxsIGVycm9yIGNhc2VzIGludG8gdGhpc1xyXG4gICAgICAgICAgICAvLyAgIGZ1bmN0aW9uLiAgOnRvZG86IGNvbnNpZGVyIGFwcGVuZGluZyBOVUwgdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxyXG4gICAgICAgICAgICAvLyAtIFRoZSBDIGNvZGUgdXNlcyBhIFwiZ290byBkZmx0XCIgd2hpY2ggaXMgZGlmZmljdWx0IHRvIHRyYW5zZm9ybSBpblxyXG4gICAgICAgICAgICAvLyAgIHRoZSB1c3VhbCB3YXkuXHJcbiAgICAgICAgICAgIGluaXQ6IC8vIGxhYmVsbGVkIHdoaWxlIGxvb3AgZW11bGF0ZXMgXCJnb3RvIGluaXRcIiwgd2hpY2ggd2UgdXNlIHRvXHJcbiAgICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gb3B0aW1pemUgdGFpbCByZWN1cnNpb24uXHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gcGkpIC8vIGVuZCBvZiBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpOyAvLyBtYXRjaCBzdWNjZWVkZWRcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocC5jaGFyQXQocGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSBwaSArIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcFVuZmluaXNoZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5jaGFyQXQocGkgKyAxKSA9PSAnKScpIC8vIHBvc2l0aW9uIGNhcHR1cmU/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydF9jYXB0dXJlKHNpLCBwLCBwaSArIDIsIE1hdGNoU3RhdGUuQ0FQX1BPU0lUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRfY2FwdHVyZShzaSwgcCwgcGkgKyAxLCBNYXRjaFN0YXRlLkNBUF9VTkZJTklTSEVEKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICcpJzogLy8gZW5kIGNhcHR1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kX2NhcHR1cmUoc2ksIHAsIHBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGNoU3RhdGUuTF9FU0MpOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gcGkgKyAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWxFc2MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHAuY2hhckF0KHBpICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOiAvLyBiYWxhbmNlZCBzdHJpbmc/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2kgPSB0aGlzLm1hdGNoYmFsYW5jZShzaSwgcCwgcGkgKyAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2kgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGkgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHJldHVybiBtYXRjaChtcywgcywgcCs0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBpbml0OyAvLyBnb3RvIGluaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOiAvLyBmcm9udGllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGkgKz0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAubGVuZ3RoID09IHBpIHx8IHAuY2hhckF0KHBpKSAhPSAnWycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fTC5lcnJvcihcIm1pc3NpbmcgJ1snIGFmdGVyICclZicgaW4gcGF0dGVyblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVwID0gdGhpcy5jbGFzc2VuZChwLCBwaSk7IC8vIGluZGV4ZXMgd2hhdCBpcyBuZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IChzaSA9PSAwKSA/ICdcXDAnLmNoYXJDb2RlQXQoMCkgOiB0aGlzLl9zcmMuY2hhckNvZGVBdChzaSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXQgPSAoc2kgPT0gdGhpcy5fZW5kKSA/ICdcXDAnLmNoYXJDb2RlQXQoMCkgOiB0aGlzLl9zcmMuY2hhckNvZGVBdChzaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRjaFN0YXRlLm1hdGNoYnJhY2tldGNsYXNzKHByZXZpb3VzLCBwLCBwaSwgZXAgLSAxKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIU1hdGNoU3RhdGUubWF0Y2hicmFja2V0Y2xhc3MoYXQsIHAsIHBpLCBlcCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGkgPSBlcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSByZXR1cm4gbWF0Y2gobXMsIHMsIGVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgaW5pdDsgLy8gZ290byBpbml0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTeW50YXhfMS5TeW50YXguaXNkaWdpdChwLmNoYXJDb2RlQXQocGkgKyAxKSkpIC8vIGNhcHR1cmUgcmVzdWx0cyAoJTAtJTA5KT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaSA9IHRoaXMubWF0Y2hfY2FwdHVyZShzaSwgcC5jaGFyQ29kZUF0KHBpICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2kgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaSArPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHJldHVybiBtYXRjaChtcywgcywgcCsyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgaW5pdDsgLy8gZ290byBpbml0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZW11bGF0ZSBhIGdvdG8gZGZsdCBieSBhIGZhbGx0aHJvdWdoIHRvIHRoZSBuZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIChvZiB0aGUgb3V0ZXIgc3dpdGNoKSBhbmQgbWFraW5nIHN1cmUgdGhhdCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgY2FzZSBoYXMgbm8gZWZmZWN0IHdoZW4gd2UgZmFsbHRocm91Z2ggdG8gaXQgZnJvbSBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ290byBkZmx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRkFMTFRIUk9VR0hcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuY2hhckF0KHBpKSA9PSAnJCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSBwaSArIDEpIC8vIGlzIHRoZSAnJCcgdGhlIGxhc3QgY2hhciBpbiBwYXR0ZXJuP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoc2kgPT0gdGhpcy5fZW5kKSA/IHNpIDogLTE7IC8vIGNoZWNrIGVuZCBvZiBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZ290byBkZmx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRkFMTFRIUk9VR0hcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAvLyBpdCBpcyBhIHBhdHRlcm4gaXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXAyID0gdGhpcy5jbGFzc2VuZChwLCBwaSk7IC8vIGluZGV4ZXMgd2hhdCBpcyBuZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHNpIDwgdGhpcy5fZW5kICYmIE1hdGNoU3RhdGUuc2luZ2xlbWF0Y2godGhpcy5fc3JjLmNoYXJDb2RlQXQoc2kpLCBwLCBwaSwgZXAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IGVwMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocC5jaGFyQXQoZXAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc/JzogLy8gb3B0aW9uYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMubWF0Y2goc2kgKyAxLCBwLCBlcDIgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaSA9IGVwMiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHJldHVybiBtYXRjaChzLCBlcCsxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGluaXQ7IC8vIGdvdG8gaW5pdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzogLy8gMCBvciBtb3JlIHJlcGV0aXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhfZXhwYW5kKHNpLCBwLCBwaSwgZXAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6IC8vIDEgb3IgbW9yZSByZXBldGl0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gPyB0aGlzLm1heF9leHBhbmQoc2kgKyAxLCBwLCBwaSwgZXAyKSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzogLy8gMCBvciBtb3JlIHJlcGV0aXRpb25zIChtaW5pbXVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluX2V4cGFuZChzaSwgcCwgcGksIGVwMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBvciBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrc2k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaSA9IGVwMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBtYXRjaChtcywgcysxLCBlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBpbml0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy91bnJlYWNoYWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBzICBpbmRleCBvZiBzdGFydCBvZiBtYXRjaC5cclxuICAgICAgICAgKiBAcGFyYW0gZSAgaW5kZXggb2YgZW5kIG9mIG1hdGNoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uZWNhcHR1cmUoaSwgcywgZSkge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLl9sZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkgLy8gbGV2ZWwgPT0gMCwgdG9vXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyYy5zdWJzdHJpbmcocywgZSk7IC8vIGFkZCB3aG9sZSBtYXRjaFxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwSW52YWxpZCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9UUkVBQ0hFRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuY2FwdHVyZUxlbihpKTtcclxuICAgICAgICAgICAgaWYgKGwgPT0gTWF0Y2hTdGF0ZS5DQVBfVU5GSU5JU0hFRClcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FwVW5maW5pc2hlZCgpO1xyXG4gICAgICAgICAgICBpZiAobCA9PSBNYXRjaFN0YXRlLkNBUF9QT1NJVElPTilcclxuICAgICAgICAgICAgICAgIHJldHVybiBMdWFfMS5MdWEudmFsdWVPZk51bWJlcih0aGlzLmNhcHR1cmVJbml0KGkpICsgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcmMuc3Vic3RyaW5nKHRoaXMuY2FwdHVyZUluaXQoaSksIHRoaXMuY2FwdHVyZUluaXQoaSkgKyBsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaF9vbmVjYXB0dXJlKGksIHMsIGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fTC5wdXNoT2JqZWN0KHRoaXMub25lY2FwdHVyZShpLCBzLCBlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBzICBpbmRleCBvZiBzdGFydCBvZiBtYXRjaC5cclxuICAgICAgICAgKiBAcGFyYW0gZSAgaW5kZXggb2YgZW5kIG9mIG1hdGNoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1c2hfY2FwdHVyZXMocywgZSkge1xyXG4gICAgICAgICAgICB2YXIgbmxldmVscyA9ICh0aGlzLl9sZXZlbCA9PSAwICYmIHMgPj0gMCkgPyAxIDogdGhpcy5fbGV2ZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmxldmVsczsgKytpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoX29uZWNhcHR1cmUoaSwgcywgZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBubGV2ZWxzOyAvLyBudW1iZXIgb2Ygc3RyaW5ncyBwdXNoZWRcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEEgaGVscGVyIGZvciBnc3ViLiAgRXF1aXZhbGVudCB0byBhZGRfcyBmcm9tIGxzdHJsaWIuYy4gKi9cclxuICAgICAgICBhZGRzKGIsIHNpLCBlaSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3cyA9IHRoaXMuX0wudG9TdHJpbmdfKHRoaXMuX0wudmFsdWUoMykpO1xyXG4gICAgICAgICAgICB2YXIgbCA9IG5ld3MubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld3MuY2hhckNvZGVBdChpKSAhPSBNYXRjaFN0YXRlLkxfRVNDKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmQobmV3cy5jaGFyQ29kZUF0KGkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICsraTsgLy8gc2tpcCBMX0VTQ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghU3ludGF4XzEuU3ludGF4LmlzZGlnaXQobmV3cy5jaGFyQ29kZUF0KGkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZChuZXdzLmNoYXJDb2RlQXQoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdzLmNoYXJBdChpKSA9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcodGhpcy5fc3JjLnN1YnN0cmluZyhzaSwgZWkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBjYXB0dXJlIHRvIGFjY3VtdWxhdGVkIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZFN0cmluZyh0aGlzLl9MLnRvU3RyaW5nXyh0aGlzLm9uZWNhcHR1cmUobmV3cy5jaGFyQ29kZUF0KGkpIC0gJzEnLmNoYXJDb2RlQXQoMCksIHNpLCBlaSkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEEgaGVscGVyIGZvciBnc3ViLiAgRXF1aXZhbGVudCB0byBhZGRfdmFsdWUgZnJvbSBsc3RybGliLmMuICovXHJcbiAgICAgICAgYWRkdmFsdWUoYiwgc2ksIGVpKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fTC50eXBlKDMpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5UTlVNQkVSOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuVFNUUklORzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZHMoYiwgc2ksIGVpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5URlVOQ1RJT046XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9MLnB1c2hWYWx1ZSgzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnB1c2hfY2FwdHVyZXMoc2ksIGVpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fTC5jYWxsKG4sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLlRUQUJMRTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9MLnB1c2hPYmplY3QodGhpcy5fTC5nZXRUYWJsZSh0aGlzLl9MLnZhbHVlKDMpLCB0aGlzLm9uZWNhcHR1cmUoMCwgc2ksIGVpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0wuYXJnRXJyb3IoMywgXCJzdHJpbmcvZnVuY3Rpb24vdGFibGUgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9MLnRvQm9vbGVhbih0aGlzLl9MLnZhbHVlKC0xKSkpIC8vIG5pbCBvciBmYWxzZVxyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fTC5wb3AoMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9MLnB1c2hTdHJpbmcodGhpcy5fc3JjLnN1YnN0cmluZyhzaSwgZWkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghTHVhXzEuTHVhLmlzU3RyaW5nKHRoaXMuX0wudmFsdWUoLTEpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fTC5lcnJvcihcImludmFsaWQgcmVwbGFjZW1lbnQgdmFsdWUgKGEgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIEx1YV8xLkx1YS50eXBlTmFtZSh0aGlzLl9MLnR5cGUoLTEpKSArIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiLmFwcGVuZFN0cmluZyh0aGlzLl9MLnRvU3RyaW5nXyh0aGlzLl9MLnZhbHVlKC0xKSkpOyAvLyBhZGQgcmVzdWx0IHRvIGFjY3VtdWxhdG9yXHJcbiAgICAgICAgICAgIHRoaXMuX0wucG9wKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBlbmQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgc2V0IGxldmVsKGxldmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5NYXRjaFN0YXRlID0gTWF0Y2hTdGF0ZTtcclxuICAgIE1hdGNoU3RhdGUuTF9FU0MgPSAnJScuY2hhckNvZGVBdCgwKTtcclxuICAgIE1hdGNoU3RhdGUuU1BFQ0lBTFMgPSBcIl4kKis/LihbJS1cIjtcclxuICAgIE1hdGNoU3RhdGUuQ0FQX1VORklOSVNIRUQgPSAtMTtcclxuICAgIE1hdGNoU3RhdGUuQ0FQX1BPU0lUSU9OID0gLTI7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRjaFN0YXRlLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9SYW5kb21cIiwgXCIuLi9qYXZhL01hdGhVdGlsXCIsIFwiLi9MdWFKYXZhQ2FsbGJhY2tcIiwgXCIuL0x1YVwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuTWF0aExpYiA9IHZvaWQgMDtcclxuICAgIGNvbnN0IFJhbmRvbV8xID0gcmVxdWlyZShcIi4uL2phdmEvUmFuZG9tXCIpO1xyXG4gICAgY29uc3QgTWF0aFV0aWxfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL01hdGhVdGlsXCIpO1xyXG4gICAgY29uc3QgTHVhSmF2YUNhbGxiYWNrXzEgPSByZXF1aXJlKFwiLi9MdWFKYXZhQ2FsbGJhY2tcIik7XHJcbiAgICBjb25zdCBMdWFfMSA9IHJlcXVpcmUoXCIuL0x1YVwiKTtcclxuICAgIC8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9NYXRoTGliLmphdmEjMSAkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWlucyBMdWEncyBtYXRoIGxpYnJhcnkuXHJcbiAgICAgKiBUaGUgbGlicmFyeSBjYW4gYmUgb3BlbmVkIHVzaW5nIHRoZSB7QGxpbmsgI29wZW59IG1ldGhvZC5cclxuICAgICAqIEJlY2F1c2UgdGhpcyBsaWJyYXJ5IGlzIGltcGxlbWVudGVkIG9uIHRvcCBvZiBDTERDIDEuMSBpdCBpcyBub3QgYXNcclxuICAgICAqIGNvbXBsZXRlIGFzIHRoZSBQVUMtUmlvIG1hdGggbGlicmFyeS4gIFRyaWdvbm9ubWV0cmljIGludmVyc2VzXHJcbiAgICAgKiAoRUcgPGNvZGU+YWNvczwvY29kZT4pIGFuZCBoeXBlcmJvbGljIHRyaWdvbm9tZXRyaWMgZnVuY3Rpb25zIChFR1xyXG4gICAgICogPGNvZGU+Y29zaDwvY29kZT4pIGFyZSBub3QgcHJvdmlkZWQuXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIE1hdGhMaWIgZXh0ZW5kcyBMdWFKYXZhQ2FsbGJhY2tfMS5MdWFKYXZhQ2FsbGJhY2sge1xyXG4gICAgICAgIC8qKiBDb25zdHJ1Y3RzIGluc3RhbmNlLCBmaWxsaW5nIGluIHRoZSAnd2hpY2gnIG1lbWJlci4gKi9cclxuICAgICAgICBjb25zdHJ1Y3Rvcih3aGljaCkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl93aGljaCA9IHdoaWNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXBsZW1lbnRzIGFsbCBvZiB0aGUgZnVuY3Rpb25zIGluIHRoZSBMdWEgbWF0aCBsaWJyYXJ5LiAgRG8gbm90XHJcbiAgICAgICAgICogY2FsbCBkaXJlY3RseS5cclxuICAgICAgICAgKiBAcGFyYW0gTCAgdGhlIEx1YSBzdGF0ZSBpbiB3aGljaCB0byBleGVjdXRlLlxyXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIHJldHVybmVkIHBhcmFtZXRlcnMsIGFzIHBlciBjb252ZW50aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx1YUZ1bmN0aW9uKEwpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl93aGljaCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLkFCUzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aExpYi5hYnMoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGhMaWIuQ0VJTDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aExpYi5jZWlsKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLkNPUzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aExpYi5jb3MoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGhMaWIuREVHOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoTGliLmRlZyhMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0aExpYi5FWFA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIuZXhwKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLkZMT09SOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoTGliLmZsb29yKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLkZNT0Q6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIuZm1vZChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0aExpYi5NQVg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIubWF4KEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLk1JTjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aExpYi5taW4oTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGhMaWIuTU9ERjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aExpYi5tb2RmKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLlBPVzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aExpYi5wb3coTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGhMaWIuUkFEOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoTGliLnJhZChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0aExpYi5SQU5ET006XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIucmFuZG9tKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLlJBTkRPTVNFRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIucmFuZG9tc2VlZChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0aExpYi5TSU46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIuc2luKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRoTGliLlNRUlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIuc3FydChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0aExpYi5UQU46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhMaWIudGFuKEwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcGVucyB0aGUgbGlicmFyeSBpbnRvIHRoZSBnaXZlbiBMdWEgc3RhdGUuICBUaGlzIHJlZ2lzdGVyc1xyXG4gICAgICAgICAqIHRoZSBzeW1ib2xzIG9mIHRoZSBsaWJyYXJ5IGluIHRoZSBnbG9iYWwgdGFibGUuXHJcbiAgICAgICAgICogQHBhcmFtIEwgIFRoZSBMdWEgc3RhdGUgaW50byB3aGljaCB0byBvcGVuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBvcGVuKEwpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBMLl9fcmVnaXN0ZXIoXCJtYXRoXCIpO1xyXG4gICAgICAgICAgICBNYXRoTGliLnIoTCwgXCJhYnNcIiwgTWF0aExpYi5BQlMpO1xyXG4gICAgICAgICAgICBNYXRoTGliLnIoTCwgXCJjZWlsXCIsIE1hdGhMaWIuQ0VJTCk7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcImNvc1wiLCBNYXRoTGliLkNPUyk7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcImRlZ1wiLCBNYXRoTGliLkRFRyk7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcImV4cFwiLCBNYXRoTGliLkVYUCk7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcImZsb29yXCIsIE1hdGhMaWIuRkxPT1IpO1xyXG4gICAgICAgICAgICBNYXRoTGliLnIoTCwgXCJmbW9kXCIsIE1hdGhMaWIuRk1PRCk7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcIm1heFwiLCBNYXRoTGliLk1BWCk7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcIm1pblwiLCBNYXRoTGliLk1JTik7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcIm1vZGZcIiwgTWF0aExpYi5NT0RGKTtcclxuICAgICAgICAgICAgTWF0aExpYi5yKEwsIFwicG93XCIsIE1hdGhMaWIuUE9XKTtcclxuICAgICAgICAgICAgTWF0aExpYi5yKEwsIFwicmFkXCIsIE1hdGhMaWIuUkFEKTtcclxuICAgICAgICAgICAgTWF0aExpYi5yKEwsIFwicmFuZG9tXCIsIE1hdGhMaWIuUkFORE9NKTtcclxuICAgICAgICAgICAgTWF0aExpYi5yKEwsIFwicmFuZG9tc2VlZFwiLCBNYXRoTGliLlJBTkRPTVNFRUQpO1xyXG4gICAgICAgICAgICBNYXRoTGliLnIoTCwgXCJzaW5cIiwgTWF0aExpYi5TSU4pO1xyXG4gICAgICAgICAgICBNYXRoTGliLnIoTCwgXCJzcXJ0XCIsIE1hdGhMaWIuU1FSVCk7XHJcbiAgICAgICAgICAgIE1hdGhMaWIucihMLCBcInRhblwiLCBNYXRoTGliLlRBTik7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQodCwgXCJwaVwiLCBMdWFfMS5MdWEudmFsdWVPZk51bWJlcihNYXRoLlBJKSk7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQodCwgXCJodWdlXCIsIEx1YV8xLkx1YS52YWx1ZU9mTnVtYmVyKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogUmVnaXN0ZXIgYSBmdW5jdGlvbi4gKi9cclxuICAgICAgICBzdGF0aWMgcihMLCBuYW1lLCB3aGljaCkge1xyXG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBNYXRoTGliKHdoaWNoKTtcclxuICAgICAgICAgICAgTC5zZXRGaWVsZChMLmdldEdsb2JhbChcIm1hdGhcIiksIG5hbWUsIGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgYWJzKEwpIHtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKE1hdGguYWJzKEwuY2hlY2tOdW1iZXIoMSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBjZWlsKEwpIHtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKE1hdGguY2VpbChMLmNoZWNrTnVtYmVyKDEpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgY29zKEwpIHtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKE1hdGguY29zKEwuY2hlY2tOdW1iZXIoMSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBkZWcoTCkge1xyXG4gICAgICAgICAgICBMLnB1c2hOdW1iZXIoTWF0aFV0aWxfMS5NYXRoVXRpbC50b0RlZ3JlZXMoTC5jaGVja051bWJlcigxKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGV4cChMKSB7XHJcbiAgICAgICAgICAgIC8vIENMREMgMS4xIGhhcyBNYXRoLkUgYnV0IG5vIGV4cCwgcG93LCBvciBsb2cuICBCaXphcnJlLlxyXG4gICAgICAgICAgICBMLnB1c2hOdW1iZXIoTHVhXzEuTHVhLmlOdW1wb3coTWF0aC5FLCBMLmNoZWNrTnVtYmVyKDEpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgZmxvb3IoTCkge1xyXG4gICAgICAgICAgICBMLnB1c2hOdW1iZXIoTWF0aC5mbG9vcihMLmNoZWNrTnVtYmVyKDEpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgZm1vZChMKSB7XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihMLmNoZWNrTnVtYmVyKDEpICUgTC5jaGVja051bWJlcigyKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgbWF4KEwpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBMLmdldFRvcCgpOyAvLyBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICAgIHZhciBkbWF4ID0gTC5jaGVja051bWJlcigxKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPD0gbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IEwuY2hlY2tOdW1iZXIoaSk7XHJcbiAgICAgICAgICAgICAgICBkbWF4ID0gTWF0aC5tYXgoZG1heCwgZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKGRtYXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIG1pbihMKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gTC5nZXRUb3AoKTsgLy8gbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICB2YXIgZG1pbiA9IEwuY2hlY2tOdW1iZXIoMSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBMLmNoZWNrTnVtYmVyKGkpO1xyXG4gICAgICAgICAgICAgICAgZG1pbiA9IE1hdGgubWluKGRtaW4sIGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihkbWluKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBtb2RmKEwpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBMLmNoZWNrTnVtYmVyKDEpO1xyXG4gICAgICAgICAgICB2YXIgZnAgPSB4ICUgMTtcclxuICAgICAgICAgICAgdmFyIGlwID0geCAtIGZwO1xyXG4gICAgICAgICAgICBMLnB1c2hOdW1iZXIoaXApO1xyXG4gICAgICAgICAgICBMLnB1c2hOdW1iZXIoZnApO1xyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIHBvdyhMKSB7XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihMdWFfMS5MdWEuaU51bXBvdyhMLmNoZWNrTnVtYmVyKDEpLCBMLmNoZWNrTnVtYmVyKDIpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgcmFkKEwpIHtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKE1hdGhVdGlsXzEuTWF0aFV0aWwudG9SYWRpYW5zKEwuY2hlY2tOdW1iZXIoMSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyByYW5kb20oTCkge1xyXG4gICAgICAgICAgICAvLyBJdCB3b3VsZCBzZWVtIGJldHRlciBzdHlsZSB0byBhc3NvY2lhdGUgdGhlIGphdmEudXRpbC5SYW5kb21cclxuICAgICAgICAgICAgLy8gaW5zdGFuY2Ugd2l0aCB0aGUgTHVhIGluc3RhbmNlIChieSBpbXBsZW1lbnRpbmcgYW5kIHVzaW5nIGFcclxuICAgICAgICAgICAgLy8gcmVnaXN0cnkgZm9yIGV4YW1wbGUpLiAgSG93ZXZlciwgUFVDLXJpbyB1c2VzIHRoZSBJU08gQyBsaWJyYXJ5XHJcbiAgICAgICAgICAgIC8vIGFuZCBzbyB3aWxsIHNoYXJlIHRoZSBzYW1lIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGFjcm9zcyBhbGwgTHVhXHJcbiAgICAgICAgICAgIC8vIHN0YXRlcy4gIFNvIHdlIGRvIHRvby5cclxuICAgICAgICAgICAgc3dpdGNoIChMLmdldFRvcCgpKSAvLyBjaGVjayBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IC8vIG5vIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIEwucHVzaE51bWJlcihNYXRoTGliLl9ybmcubmV4dERvdWJsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gb25seSB1cHBlciBsaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBMLmNoZWNrSW50KDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMLmFyZ0NoZWNrKDEgPD0gdSwgMSwgXCJpbnRlcnZhbCBpcyBlbXB0eVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTC5wdXNoTnVtYmVyKE1hdGhMaWIuX3JuZy5uZXh0SW50KHUpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBsb3dlciBhbmQgdXBwZXIgbGltaXRzXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IEwuY2hlY2tJbnQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1MiA9IEwuY2hlY2tJbnQoMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEwuYXJnQ2hlY2sobCA8PSB1MiwgMiwgXCJpbnRlcnZhbCBpcyBlbXB0eVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTC5wdXNoTnVtYmVyKE1hdGhMaWIuX3JuZy5uZXh0SW50KHUyKSArIGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEwuZXJyb3IoXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgcmFuZG9tc2VlZChMKSB7XHJcbiAgICAgICAgICAgIE1hdGhMaWIuX3JuZy5zZXRTZWVkKEwuY2hlY2tOdW1iZXIoMSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIHNpbihMKSB7XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihNYXRoLnNpbihMLmNoZWNrTnVtYmVyKDEpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgc3FydChMKSB7XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihNYXRoLnNxcnQoTC5jaGVja051bWJlcigxKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIHRhbihMKSB7XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihNYXRoLnRhbihMLmNoZWNrTnVtYmVyKDEpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuTWF0aExpYiA9IE1hdGhMaWI7XHJcbiAgICAvLyBFYWNoIGZ1bmN0aW9uIGluIHRoZSBsaWJyYXJ5IGNvcnJlc3BvbmRzIHRvIGFuIGluc3RhbmNlIG9mXHJcbiAgICAvLyB0aGlzIGNsYXNzIHdoaWNoIGlzIGFzc29jaWF0ZWQgKHRoZSAnd2hpY2gnIG1lbWJlcikgd2l0aCBhbiBpbnRlZ2VyXHJcbiAgICAvLyB3aGljaCBpcyB1bmlxdWUgd2l0aGluIHRoaXMgY2xhc3MuICBUaGV5IGFyZSB0YWtlbiBmcm9tIHRoZSBmb2xsb3dpbmdcclxuICAgIC8vIHNldC5cclxuICAgIE1hdGhMaWIuQUJTID0gMTtcclxuICAgIC8vcHJpdmF0ZSBzdGF0aWMgY29uc3QgYWNvczppbnQgPSAyO1xyXG4gICAgLy9wcml2YXRlIHN0YXRpYyBjb25zdCBhc2luOmludCA9IDM7XHJcbiAgICAvL3ByaXZhdGUgc3RhdGljIGNvbnN0IGF0YW4yOmludCA9IDQ7XHJcbiAgICAvL3ByaXZhdGUgc3RhdGljIGNvbnN0IGF0YW46aW50ID0gNTtcclxuICAgIE1hdGhMaWIuQ0VJTCA9IDY7XHJcbiAgICAvL3ByaXZhdGUgc3RhdGljIGNvbnN0IGNvc2g6aW50ID0gNztcclxuICAgIE1hdGhMaWIuQ09TID0gODtcclxuICAgIE1hdGhMaWIuREVHID0gOTtcclxuICAgIE1hdGhMaWIuRVhQID0gMTA7XHJcbiAgICBNYXRoTGliLkZMT09SID0gMTE7XHJcbiAgICBNYXRoTGliLkZNT0QgPSAxMjtcclxuICAgIC8vcHJpdmF0ZSBzdGF0aWMgY29uc3QgZnJleHA6aW50ID0gMTM7XHJcbiAgICAvL3ByaXZhdGUgc3RhdGljIGNvbnN0IGxkZXhwOmludCA9IDE0O1xyXG4gICAgLy9wcml2YXRlIHN0YXRpYyBjb25zdCBsb2c6aW50ID0gMTU7XHJcbiAgICBNYXRoTGliLk1BWCA9IDE2O1xyXG4gICAgTWF0aExpYi5NSU4gPSAxNztcclxuICAgIE1hdGhMaWIuTU9ERiA9IDE4O1xyXG4gICAgTWF0aExpYi5QT1cgPSAxOTtcclxuICAgIE1hdGhMaWIuUkFEID0gMjA7XHJcbiAgICBNYXRoTGliLlJBTkRPTSA9IDIxO1xyXG4gICAgTWF0aExpYi5SQU5ET01TRUVEID0gMjI7XHJcbiAgICAvL3ByaXZhdGUgc3RhdGljIGNvbnN0IHNpbmg6aW50ID0gMjM7XHJcbiAgICBNYXRoTGliLlNJTiA9IDI0O1xyXG4gICAgTWF0aExpYi5TUVJUID0gMjU7XHJcbiAgICAvL3ByaXZhdGUgc3RhdGljIGNvbnN0IHRhbmg6aW50ID0gMjY7XHJcbiAgICBNYXRoTGliLlRBTiA9IDI3O1xyXG4gICAgTWF0aExpYi5fcm5nID0gbmV3IFJhbmRvbV8xLlJhbmRvbSgpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0aExpYi5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL2phdmEvQ2FsZW5kYXJcIiwgXCIuLi9qYXZhL1N0cmluZ0J1ZmZlclwiLCBcIi4uL2phdmEvU3lzdGVtVXRpbFwiLCBcIi4uL2phdmEvVGltZVpvbmVcIiwgXCIuL0x1YVwiLCBcIi4vTHVhSmF2YUNhbGxiYWNrXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5PU0xpYiA9IHZvaWQgMDtcclxuICAgIGNvbnN0IENhbGVuZGFyXzEgPSByZXF1aXJlKFwiLi4vamF2YS9DYWxlbmRhclwiKTtcclxuICAgIGNvbnN0IFN0cmluZ0J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL2phdmEvU3RyaW5nQnVmZmVyXCIpO1xyXG4gICAgY29uc3QgU3lzdGVtVXRpbF8xID0gcmVxdWlyZShcIi4uL2phdmEvU3lzdGVtVXRpbFwiKTtcclxuICAgIGNvbnN0IFRpbWVab25lXzEgPSByZXF1aXJlKFwiLi4vamF2YS9UaW1lWm9uZVwiKTtcclxuICAgIGNvbnN0IEx1YV8xID0gcmVxdWlyZShcIi4vTHVhXCIpO1xyXG4gICAgY29uc3QgTHVhSmF2YUNhbGxiYWNrXzEgPSByZXF1aXJlKFwiLi9MdWFKYXZhQ2FsbGJhY2tcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvT1NMaWIuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvLyBSRUZFUkVOQ0VTXHJcbiAgICAvLyBbQzE5OTBdIFwiSVNPIFN0YW5kYXJkOiBQcm9ncmFtbWluZyBsYW5ndWFnZXMgLSBDXCI7IElTTyA5ODk5OjE5OTA7XHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBPUyBMaWJyYXJ5LiAgQ2FuIGJlIG9wZW5lZCBpbnRvIGEge0BsaW5rIEx1YX0gc3RhdGUgYnkgaW52b2tpbmdcclxuICAgICAqIHRoZSB7QGxpbmsgI29wZW59IG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgT1NMaWIgZXh0ZW5kcyBMdWFKYXZhQ2FsbGJhY2tfMS5MdWFKYXZhQ2FsbGJhY2sge1xyXG4gICAgICAgIC8qKiBDb25zdHJ1Y3RzIGluc3RhbmNlLCBmaWxsaW5nIGluIHRoZSAnd2hpY2gnIG1lbWJlci4gKi9cclxuICAgICAgICBjb25zdHJ1Y3Rvcih3aGljaCkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl93aGljaCA9IHdoaWNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXBsZW1lbnRzIGFsbCBvZiB0aGUgZnVuY3Rpb25zIGluIHRoZSBMdWEgb3MgbGlicmFyeSAodGhhdCBhcmVcclxuICAgICAgICAgKiBwcm92aWRlZCkuICBEbyBub3QgY2FsbCBkaXJlY3RseS5cclxuICAgICAgICAgKiBAcGFyYW0gTCAgdGhlIEx1YSBzdGF0ZSBpbiB3aGljaCB0byBleGVjdXRlLlxyXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIHJldHVybmVkIHBhcmFtZXRlcnMsIGFzIHBlciBjb252ZW50aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx1YUZ1bmN0aW9uKEwpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl93aGljaCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPU0xpYi5DTE9DSzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT1NMaWIuY2xvY2soTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9TTGliLkRBVEU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9TTGliLmRhdGUoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9TTGliLkRJRkZUSU1FOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPU0xpYi5kaWZmdGltZShMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT1NMaWIuR0VURU5WOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPU0xpYi5nZXRlbnYoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9TTGliLlNFVExPQ0FMRTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT1NMaWIuc2V0bG9jYWxlKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPU0xpYi5USU1FOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPU0xpYi50aW1lKEwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcGVucyB0aGUgbGlicmFyeSBpbnRvIHRoZSBnaXZlbiBMdWEgc3RhdGUuICBUaGlzIHJlZ2lzdGVyc1xyXG4gICAgICAgICAqIHRoZSBzeW1ib2xzIG9mIHRoZSBsaWJyYXJ5IGluIHRoZSB0YWJsZSBcIm9zXCIuXHJcbiAgICAgICAgICogQHBhcmFtIEwgIFRoZSBMdWEgc3RhdGUgaW50byB3aGljaCB0byBvcGVuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBvcGVuKEwpIHtcclxuICAgICAgICAgICAgTC5fX3JlZ2lzdGVyKFwib3NcIik7XHJcbiAgICAgICAgICAgIE9TTGliLnIoTCwgXCJjbG9ja1wiLCBPU0xpYi5DTE9DSyk7XHJcbiAgICAgICAgICAgIE9TTGliLnIoTCwgXCJkYXRlXCIsIE9TTGliLkRBVEUpO1xyXG4gICAgICAgICAgICBPU0xpYi5yKEwsIFwiZGlmZnRpbWVcIiwgT1NMaWIuRElGRlRJTUUpO1xyXG4gICAgICAgICAgICBPU0xpYi5yKEwsIFwiZ2V0ZW52XCIsIE9TTGliLkdFVEVOVik7XHJcbiAgICAgICAgICAgIE9TTGliLnIoTCwgXCJzZXRsb2NhbGVcIiwgT1NMaWIuU0VUTE9DQUxFKTtcclxuICAgICAgICAgICAgT1NMaWIucihMLCBcInRpbWVcIiwgT1NMaWIuVElNRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBSZWdpc3RlciBhIGZ1bmN0aW9uLiAqL1xyXG4gICAgICAgIHN0YXRpYyByKEwsIG5hbWUsIHdoaWNoKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gbmV3IE9TTGliKHdoaWNoKTtcclxuICAgICAgICAgICAgdmFyIGxpYiA9IEwuZ2V0R2xvYmFsKFwib3NcIik7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQobGliLCBuYW1lLCBmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgY2xvY2suICBKYXZhIHByb3ZpZGVzIG5vIHdheSB0byBnZXQgQ1BVIHRpbWUsIHNvIHdlXHJcbiAgICAgICAgICogcmV0dXJuIHRoZSBhbW91bnQgb2Ygd2FsbCBjbG9jayB0aW1lIHNpbmNlIHRoaXMgY2xhc3Mgd2FzIGxvYWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgY2xvY2soTCkge1xyXG4gICAgICAgICAgICB2YXIgZCA9IFN5c3RlbVV0aWxfMS5TeXN0ZW1VdGlsLmN1cnJlbnRUaW1lTWlsbGlzKCk7XHJcbiAgICAgICAgICAgIGQgPSBkIC0gT1NMaWIuVDA7XHJcbiAgICAgICAgICAgIGQgLz0gMTAwMDtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgZGF0ZS4gKi9cclxuICAgICAgICBzdGF0aWMgZGF0ZShMKSB7XHJcbiAgICAgICAgICAgIHZhciB0O1xyXG4gICAgICAgICAgICBpZiAoTC5pc05vbmVPck5pbCgyKSkge1xyXG4gICAgICAgICAgICAgICAgdCA9IFN5c3RlbVV0aWxfMS5TeXN0ZW1VdGlsLmN1cnJlbnRUaW1lTWlsbGlzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gTC5jaGVja051bWJlcigyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcyA9IEwub3B0U3RyaW5nKDEsIFwiJWNcIik7XHJcbiAgICAgICAgICAgIHZhciB0eiA9IFRpbWVab25lXzEuVGltZVpvbmUuZ2V0RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpZiAocy5zdWJzdHIoMCwgMSkgPT0gXCIhXCIpIHtcclxuICAgICAgICAgICAgICAgIHR6ID0gVGltZVpvbmVfMS5UaW1lWm9uZS5nZXRUaW1lWm9uZShcIkdNVFwiKTtcclxuICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYyA9IENhbGVuZGFyXzEuQ2FsZW5kYXIuZ2V0SW5zdGFuY2UodHopO1xyXG4gICAgICAgICAgICBjLnNldFRpbWUobmV3IERhdGUodCkpO1xyXG4gICAgICAgICAgICBpZiAocyA9PSBcIip0XCIpIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaE9iamVjdChMLmNyZWF0ZVRhYmxlKDAsIDgpKTsgLy8gOCA9IG51bWJlciBvZiBmaWVsZHNcclxuICAgICAgICAgICAgICAgIE9TTGliLnNldGZpZWxkKEwsIFwic2VjXCIsIGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLlNFQ09ORCkpO1xyXG4gICAgICAgICAgICAgICAgT1NMaWIuc2V0ZmllbGQoTCwgXCJtaW5cIiwgYy5fZ2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuTUlOVVRFKSk7XHJcbiAgICAgICAgICAgICAgICBPU0xpYi5zZXRmaWVsZChMLCBcImhvdXJcIiwgYy5fZ2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuSE9VUikpO1xyXG4gICAgICAgICAgICAgICAgT1NMaWIuc2V0ZmllbGQoTCwgXCJkYXlcIiwgYy5fZ2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuREFZX09GX01PTlRIKSk7XHJcbiAgICAgICAgICAgICAgICBPU0xpYi5zZXRmaWVsZChMLCBcIm1vbnRoXCIsIE9TTGliLmNhbm9uaWNhbG1vbnRoKGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLk1PTlRIKSkpO1xyXG4gICAgICAgICAgICAgICAgT1NMaWIuc2V0ZmllbGQoTCwgXCJ5ZWFyXCIsIGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLllFQVIpKTtcclxuICAgICAgICAgICAgICAgIE9TTGliLnNldGZpZWxkKEwsIFwid2RheVwiLCBPU0xpYi5jYW5vbmljYWx3ZWVrZGF5KGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLkRBWV9PRl9XRUVLKSkpO1xyXG4gICAgICAgICAgICAgICAgLy8geWRheSBpcyBub3Qgc3VwcG9ydGVkIGJlY2F1c2UgQ0xEQyAxLjEgZG9lcyBub3QgcHJvdmlkZSBpdC5cclxuICAgICAgICAgICAgICAgIC8vIHNldGZpZWxkKEwsIFwieWRheVwiLCBjLmdldChcIj8/P1wiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHoudXNlRGF5bGlnaHRUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDTERDIDEuMSBkb2VzIG5vdCBwcm92aWRlIGFueSB3YXkgdG8gZGV0ZXJtaW5lIGlzZHN0LCBzbyB3ZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB0byAtMSAod2hpY2ggaW4gQyBtZWFucyB0aGF0IHRoZSBpbmZvcm1hdGlvbiBpcyBub3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdmFpbGFibGUpLlxyXG4gICAgICAgICAgICAgICAgICAgIE9TTGliLnNldGZpZWxkKEwsIFwiaXNkc3RcIiwgLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQgaWYgdGhlIHRpbWV6b25lIGRvZXMgbm90IGRvIERTVCB0aGVuIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3QgYmUgaW4gZWZmZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgIE9TTGliLnNldGZpZWxkKEwsIFwiaXNkc3RcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPSAnJScuY2hhckNvZGVBdCgwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZChjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaCA9IHMuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhbGx5IGluIG9yZGVyIHRvIHNhdmUgc3BhY2UsIHRoZSBhYmJyZXZpYXRlZCBmb3JtcyBhcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZGVudGljYWwgdG8gdGhlIGxvbmcgZm9ybXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNwZWNpZmllcnMgYXJlIGZyb20gW0MxOTkwXS5cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKE9TTGliLndlZWtkYXluYW1lKGMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZFN0cmluZyhPU0xpYi5tb250aG5hbWUoYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcoYy5nZXRUaW1lKCkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZFN0cmluZyhPU0xpYi5mb3JtYXQoYy5fZ2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuREFZX09GX01PTlRIKSwgMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcoT1NMaWIuZm9ybWF0KGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLkhPVVIpLCAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBjLl9nZXQoQ2FsZW5kYXJfMS5DYWxlbmRhci5IT1VSKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gKGggKyAxMSkgJSAxMiArIDE7IC8vIGZvcmNlIGludG8gcmFuZ2UgMS0xMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKE9TTGliLmZvcm1hdChoLCAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBzdXBwb3J0ZWQgYmVjYXVzZSBDTERDIDEuMSBkb2Vzbid0IHByb3ZpZGUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZCgnJScuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZChjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBPU0xpYi5jYW5vbmljYWxtb250aChjLl9nZXQoQ2FsZW5kYXJfMS5DYWxlbmRhci5NT05USCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKE9TTGliLmZvcm1hdChtLCAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZFN0cmluZyhPU0xpYi5mb3JtYXQoYy5fZ2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuTUlOVVRFKSwgMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoMiA9IGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLkhPVVIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKGgyIDwgMTIgPyBcImFtXCIgOiBcInBtXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcoT1NMaWIuZm9ybWF0KGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLlNFQ09ORCksIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kKE9TTGliLmNhbm9uaWNhbHdlZWtkYXkoYy5fZ2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuREFZX09GX1dFRUspKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBjLmdldFRpbWUoKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4dHJhY3QgZmllbGRzIGZyb20gdGhlIHJlc3VsdCBvZiBEYXRlLnRvU3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvdXRwdXQgb2Ygd2hpY2ggaXMgb2YgdGhlIGZvcm06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93IG1vbiBkZCBoaDptbTpzcyB6enogeXl5eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCB0aGF0IHp6eiBpcyBvcHRpb25hbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZFN0cmluZyh1LnN1YnN0cmluZygwLCAxMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kKGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLllFQVIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdYJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdTIgPSBjLmdldFRpbWUoKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKHUyLnN1YnN0cmluZygxMSwgdTIubGVuZ3RoIC0gNSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3knOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcoT1NMaWIuZm9ybWF0KGMuX2dldChDYWxlbmRhcl8xLkNhbGVuZGFyLllFQVIpICUgMTAwLCAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZChjLl9nZXQoQ2FsZW5kYXJfMS5DYWxlbmRhci5ZRUFSKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZFN0cmluZyh0ei5nZXRJRCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kKCclJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gLyogd2hpbGUgKi9cclxuICAgICAgICAgICAgICAgIEwucHVzaFN0cmluZyhiLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBkaWZmdGltZS4gKi9cclxuICAgICAgICBzdGF0aWMgZGlmZnRpbWUoTCkge1xyXG4gICAgICAgICAgICBMLnB1c2hOdW1iZXIoKEwuY2hlY2tOdW1iZXIoMSkgLSBMLm9wdE51bWJlcigyLCAwKSkgLyAxMDAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHNldGxvY2FsZS4gKi9cclxuICAgICAgICBzdGF0aWMgc2V0bG9jYWxlKEwpIHtcclxuICAgICAgICAgICAgaWYgKEwuaXNOb25lT3JOaWwoMSkpIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaFN0cmluZyhcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaE5pbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyB0aW1lLiAqL1xyXG4gICAgICAgIHN0YXRpYyB0aW1lKEwpIHtcclxuICAgICAgICAgICAgaWYgKEwuaXNOb25lT3JOaWwoMSkpIC8vIGNhbGxlZCB3aXRob3V0IGFyZ3M/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBMLnB1c2hOdW1iZXIoU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuY3VycmVudFRpbWVNaWxsaXMoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLmNoZWNrVHlwZSgxLCBMdWFfMS5MdWEuVFRBQkxFKTtcclxuICAgICAgICAgICAgTC5zZXRUb3AoMSk7IC8vIG1ha2Ugc3VyZSB0YWJsZSBpcyBhdCB0aGUgdG9wXHJcbiAgICAgICAgICAgIHZhciBjID0gQ2FsZW5kYXJfMS5DYWxlbmRhci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBjLl9zZXQoQ2FsZW5kYXJfMS5DYWxlbmRhci5TRUNPTkQsIE9TTGliLmdldGZpZWxkKEwsIFwic2VjXCIsIDApKTtcclxuICAgICAgICAgICAgYy5fc2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuTUlOVVRFLCBPU0xpYi5nZXRmaWVsZChMLCBcIm1pblwiLCAwKSk7XHJcbiAgICAgICAgICAgIGMuX3NldChDYWxlbmRhcl8xLkNhbGVuZGFyLkhPVVIsIE9TTGliLmdldGZpZWxkKEwsIFwiaG91clwiLCAxMikpO1xyXG4gICAgICAgICAgICBjLl9zZXQoQ2FsZW5kYXJfMS5DYWxlbmRhci5EQVlfT0ZfTU9OVEgsIE9TTGliLmdldGZpZWxkKEwsIFwiZGF5XCIsIC0xKSk7XHJcbiAgICAgICAgICAgIGMuX3NldChDYWxlbmRhcl8xLkNhbGVuZGFyLk1PTlRILCBPU0xpYi5NT05USFtPU0xpYi5nZXRmaWVsZChMLCBcIm1vbnRoXCIsIC0xKSAtIDFdKTtcclxuICAgICAgICAgICAgYy5fc2V0KENhbGVuZGFyXzEuQ2FsZW5kYXIuWUVBUiwgT1NMaWIuZ2V0ZmllbGQoTCwgXCJ5ZWFyXCIsIC0xKSk7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBpc2RzdCBmaWVsZFxyXG4gICAgICAgICAgICBMLnB1c2hOdW1iZXIoYy5nZXRUaW1lKCkuZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBnZXRmaWVsZChMLCBrZXksIGQpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSBMLmdldEZpZWxkKEwudmFsdWUoLTEpLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAoTHVhXzEuTHVhLmlzTnVtYmVyKG8pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEwudG9OdW1iZXIobyk7XHJcbiAgICAgICAgICAgIGlmIChkIDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBMLmVycm9yKFwiZmllbGQgJ1wiICsga2V5ICsgXCInIG1pc3NpbmcgaW4gZGF0ZSB0YWJsZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBzZXRmaWVsZChMLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQoTC52YWx1ZSgtMSksIGtleSwgTHVhXzEuTHVhLnZhbHVlT2ZOdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEZvcm1hdCBhIHBvc2l0aXZlIGludGVnZXIgaW4gYSAwLWZpbGxlZCBmaWVsZCBvZiB3aWR0aFxyXG4gICAgICAgICAqIDx2YXI+dzwvdmFyPi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgZm9ybWF0KGksIHcpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBuZXcgU3RyaW5nQnVmZmVyXzEuU3RyaW5nQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGIuYXBwZW5kKGkpO1xyXG4gICAgICAgICAgICB3aGlsZSAoYi5sZW5ndGgoKSA8IHcpIHtcclxuICAgICAgICAgICAgICAgIGIuaW5zZXJ0KDAsICcwJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYi50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgd2Vla2RheW5hbWUoYykge1xyXG4gICAgICAgICAgICB2YXIgcyA9IGMuZ2V0VGltZSgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzLnN1YnN0cmluZygwLCAzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIG1vbnRobmFtZShjKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gYy5nZXRUaW1lKCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHMuc3Vic3RyaW5nKDQsIDcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAoYWxtb3N0KSBpbnZlcnRzIHRoZSBjb252ZXJzaW9uIHByb3ZpZGVkIGJ5IHtAbGluayAjTU9OVEh9LiAgQ29udmVydHNcclxuICAgICAgICAgKiBmcm9tIGEge0BsaW5rIENhbGVuZGFyfSB2YWx1ZSB0byBhIG1vbnRoIGluIHRoZSByYW5nZSAxLTEyLlxyXG4gICAgICAgICAqIEBwYXJhbSBtICBhIHZhbHVlIGZyb20gdGhlIGVudW0gQ2FsZW5kYXIuSkFOVUFSWSwgQ2FsZW5kYXIuRkVCUlVBUlksIGV0Y1xyXG4gICAgICAgICAqIEByZXR1cm4gYSBtb250aCBpbiB0aGUgcmFuZ2UgMS0xMiwgb3IgdGhlIG9yaWdpbmFsIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBjYW5vbmljYWxtb250aChtKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1NMaWIuTU9OVEgubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtID09IE9TTGliLk1PTlRIW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBmcm9tIGEge0BsaW5rIENhbGVuZGFyfSB2YWx1ZSB0byBhIHdlZWtkYXkgaW4gdGhlIHJhbmdlXHJcbiAgICAgICAgICogMC02IHdoZXJlIDAgaXMgU3VuZGF5IChhcyBwZXIgdGhlIGNvbnZlbnRpb24gdXNlZCBpbiBbQzE5OTBdKS5cclxuICAgICAgICAgKiBAcGFyYW0gdyAgYSB2YWx1ZSBmcm9tIHRoZSBlbnVtIENhbGVuZGFyLlNVTkRBWSwgQ2FsZW5kYXIuTU9OREFZLCBldGNcclxuICAgICAgICAgKiBAcmV0dXJuIGEgd2Vla2RheSBpbiB0aGUgcmFuZ2UgMC02LCBvciB0aGUgb3JpZ2luYWwgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGNhbm9uaWNhbHdlZWtkYXkodykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9TTGliLldFRUtEQVkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3ID09IE9TTGliLldFRUtEQVlbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9GSVhNRTpub3QgaW1wbGVtZW50ZWRcclxuICAgICAgICBzdGF0aWMgZ2V0ZW52KEwpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBMLmNoZWNrU3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAvL0ZJWE1FOlxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoTmlsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBMLnB1c2hTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuT1NMaWIgPSBPU0xpYjtcclxuICAgIC8vIEVhY2ggZnVuY3Rpb24gaW4gdGhlIGxpYnJhcnkgY29ycmVzcG9uZHMgdG8gYW4gaW5zdGFuY2Ugb2ZcclxuICAgIC8vIHRoaXMgY2xhc3Mgd2hpY2ggaXMgYXNzb2NpYXRlZCAodGhlICd3aGljaCcgbWVtYmVyKSB3aXRoIGFuIGludGVnZXJcclxuICAgIC8vIHdoaWNoIGlzIHVuaXF1ZSB3aXRoaW4gdGhpcyBjbGFzcy4gIFRoZXkgYXJlIHRha2VuIGZyb20gdGhlIGZvbGxvd2luZ1xyXG4gICAgLy8gc2V0LlxyXG4gICAgT1NMaWIuQ0xPQ0sgPSAxO1xyXG4gICAgT1NMaWIuREFURSA9IDI7XHJcbiAgICBPU0xpYi5ESUZGVElNRSA9IDM7XHJcbiAgICAvLyBFWEVDVVRFID0gNDtcclxuICAgIC8vIEVYSVQgPSA1O1xyXG4gICAgT1NMaWIuR0VURU5WID0gNjtcclxuICAgIC8vIFJFTU9WRSA9IDc7XHJcbiAgICAvLyBSRU5BTUUgPSA4O1xyXG4gICAgT1NMaWIuU0VUTE9DQUxFID0gOTtcclxuICAgIE9TTGliLlRJTUUgPSAxMDtcclxuICAgIE9TTGliLlQwID0gU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuY3VycmVudFRpbWVNaWxsaXMoKTtcclxuICAgIC8vIEluY3JlZGlibHksIHRoZSBzcGVjIGRvZXNuJ3QgZ2l2ZSBhIG51bWVyaWMgdmFsdWUgYW5kIHJhbmdlIGZvclxyXG4gICAgLy8gQ2FsZW5kYXIuSkFOVUFSWSB0aHJvdWdoIHRvIENhbGVuZGFyLkRFQ0VNQkVSLlxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBmcm9tIDAtMTEgdG8gcmVxdWlyZWQgQ2FsZW5kYXIgdmFsdWUuICBETyBOT1QgTU9ESUZZIFRISVNcclxuICAgICAqIEFSUkFZLlxyXG4gICAgICovXHJcbiAgICBPU0xpYi5NT05USCA9IFtcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLkpBTlVBUlksXHJcbiAgICAgICAgQ2FsZW5kYXJfMS5DYWxlbmRhci5GRUJSVUFSWSxcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLk1BUkNILFxyXG4gICAgICAgIENhbGVuZGFyXzEuQ2FsZW5kYXIuQVBSSUwsXHJcbiAgICAgICAgQ2FsZW5kYXJfMS5DYWxlbmRhci5NQVksXHJcbiAgICAgICAgQ2FsZW5kYXJfMS5DYWxlbmRhci5KVU5FLFxyXG4gICAgICAgIENhbGVuZGFyXzEuQ2FsZW5kYXIuSlVMWSxcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLkFVR1VTVCxcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLlNFUFRFTUJFUixcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLk9DVE9CRVIsXHJcbiAgICAgICAgQ2FsZW5kYXJfMS5DYWxlbmRhci5OT1ZFTUJFUixcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLkRFQ0VNQkVSXHJcbiAgICBdO1xyXG4gICAgLy8gRE8gTk9UIE1PRElGWSBBUlJBWVxyXG4gICAgT1NMaWIuV0VFS0RBWSA9IFtcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLlNVTkRBWSxcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLk1PTkRBWSxcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLlRVRVNEQVksXHJcbiAgICAgICAgQ2FsZW5kYXJfMS5DYWxlbmRhci5XRURORVNEQVksXHJcbiAgICAgICAgQ2FsZW5kYXJfMS5DYWxlbmRhci5USFVSU0RBWSxcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLkZSSURBWSxcclxuICAgICAgICBDYWxlbmRhcl8xLkNhbGVuZGFyLlNBVFVSREFZLFxyXG4gICAgXTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9TTGliLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9TdHJpbmdCdWZmZXJcIiwgXCIuLi9qYXZhL0lPRXhjZXB0aW9uXCIsIFwiLi4vamF2YS9TeXN0ZW1VdGlsXCIsIFwiLi9MdWFKYXZhQ2FsbGJhY2tcIiwgXCIuL0x1YVwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuUGFja2FnZUxpYiA9IHZvaWQgMDtcclxuICAgIGNvbnN0IFN0cmluZ0J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL2phdmEvU3RyaW5nQnVmZmVyXCIpO1xyXG4gICAgY29uc3QgSU9FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0lPRXhjZXB0aW9uXCIpO1xyXG4gICAgY29uc3QgU3lzdGVtVXRpbF8xID0gcmVxdWlyZShcIi4uL2phdmEvU3lzdGVtVXRpbFwiKTtcclxuICAgIGNvbnN0IEx1YUphdmFDYWxsYmFja18xID0gcmVxdWlyZShcIi4vTHVhSmF2YUNhbGxiYWNrXCIpO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvUGFja2FnZUxpYi5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbnMgTHVhJ3MgcGFja2FnZSBsaWJyYXJ5LlxyXG4gICAgICogVGhlIGxpYnJhcnlcclxuICAgICAqIGNhbiBiZSBvcGVuZWQgdXNpbmcgdGhlIHtAbGluayAjb3Blbn0gbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBQYWNrYWdlTGliIGV4dGVuZHMgTHVhSmF2YUNhbGxiYWNrXzEuTHVhSmF2YUNhbGxiYWNrIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcih3aGljaCwgbWUpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fd2hpY2ggPSB3aGljaDtcclxuICAgICAgICAgICAgdGhpcy5fbWUgPSAoKG1lICE9PSB1bmRlZmluZWQpID8gbWUgOiBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9wcml2YXRlIGZ1bmN0aW9uIF9faW5pdCh3aGljaDppbnQsIG1lOkx1YVRhYmxlKTp2b2lkXHJcbiAgICAgICAgLy97XHJcbiAgICAgICAgLy9cdHRoaXMuX3doaWNoID0gd2hpY2g7XHJcbiAgICAgICAgLy9cdHRoaXMubWUgPSBtZTtcclxuICAgICAgICAvL31cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEltcGxlbWVudHMgYWxsIG9mIHRoZSBmdW5jdGlvbnMgaW4gdGhlIEx1YSBwYWNrYWdlIGxpYnJhcnkuICBEbyBub3RcclxuICAgICAgICAqIGNhbGwgZGlyZWN0bHkuXHJcbiAgICAgICAgKiBAcGFyYW0gTCAgdGhlIEx1YSBzdGF0ZSBpbiB3aGljaCB0byBleGVjdXRlLlxyXG4gICAgICAgICogQHJldHVybiBudW1iZXIgb2YgcmV0dXJuZWQgcGFyYW1ldGVycywgYXMgcGVyIGNvbnZlbnRpb24uXHJcbiAgICAgICAgKi9cclxuICAgICAgICBsdWFGdW5jdGlvbihMKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fd2hpY2gpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFja2FnZUxpYi5NT0RVTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxlKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYWNrYWdlTGliLlJFUVVJUkU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZShMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFja2FnZUxpYi5TRUVBTEw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhY2thZ2VMaWIuc2VlYWxsKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYWNrYWdlTGliLkxPQURFUl9MVUE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyTHVhKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYWNrYWdlTGliLkxPQURFUl9QUkVMT0FEOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlclByZWxvYWQoTCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9wZW5zIHRoZSBsaWJyYXJ5IGludG8gdGhlIGdpdmVuIEx1YSBzdGF0ZS4gIFRoaXMgcmVnaXN0ZXJzXHJcbiAgICAgICAgICogdGhlIHN5bWJvbHMgb2YgdGhlIGxpYnJhcnkgaW4gdGhlIGdsb2JhbCB0YWJsZS5cclxuICAgICAgICAgKiBAcGFyYW0gTCAgVGhlIEx1YSBzdGF0ZSBpbnRvIHdoaWNoIHRvIG9wZW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIG9wZW4oTCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IEwuX19yZWdpc3RlcihcInBhY2thZ2VcIik7XHJcbiAgICAgICAgICAgIFBhY2thZ2VMaWIuZyhMLCB0LCBcIm1vZHVsZVwiLCBQYWNrYWdlTGliLk1PRFVMRSk7XHJcbiAgICAgICAgICAgIFBhY2thZ2VMaWIuZyhMLCB0LCBcInJlcXVpcmVcIiwgUGFja2FnZUxpYi5SRVFVSVJFKTtcclxuICAgICAgICAgICAgUGFja2FnZUxpYi5yKEwsIFwic2VlYWxsXCIsIFBhY2thZ2VMaWIuU0VFQUxMKTtcclxuICAgICAgICAgICAgTC5zZXRGaWVsZCh0LCBcImxvYWRlcnNcIiwgTC5uZXdUYWJsZSgpKTtcclxuICAgICAgICAgICAgUGFja2FnZUxpYi5wKEwsIHQsIFBhY2thZ2VMaWIuTE9BREVSX1BSRUxPQUQpO1xyXG4gICAgICAgICAgICBQYWNrYWdlTGliLnAoTCwgdCwgUGFja2FnZUxpYi5MT0FERVJfTFVBKTtcclxuICAgICAgICAgICAgUGFja2FnZUxpYi5zZXRwYXRoKEwsIHQsIFwicGF0aFwiLCBQYWNrYWdlTGliLlBBVEhfREVGQVVMVCk7IC8vIHNldCBmaWVsZCAncGF0aCdcclxuICAgICAgICAgICAgLy8gc2V0IGZpZWxkICdsb2FkZWQnXHJcbiAgICAgICAgICAgIEwuZmluZFRhYmxlKEwuZ2V0UmVnaXN0cnkoKSwgTHVhXzEuTHVhLkxPQURFRCwgMSk7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQodCwgXCJsb2FkZWRcIiwgTC52YWx1ZSgtMSkpO1xyXG4gICAgICAgICAgICBMLnBvcCgxKTtcclxuICAgICAgICAgICAgTC5zZXRGaWVsZCh0LCBcInByZWxvYWRcIiwgTC5uZXdUYWJsZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFJlZ2lzdGVyIGEgZnVuY3Rpb24uICovXHJcbiAgICAgICAgc3RhdGljIHIoTCwgbmFtZSwgd2hpY2gpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgUGFja2FnZUxpYih3aGljaCk7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQoTC5nZXRHbG9iYWwoXCJwYWNrYWdlXCIpLCBuYW1lLCBmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gaW4gdGhlIGdsb2JhbCB0YWJsZS4gKi9cclxuICAgICAgICBzdGF0aWMgZyhMLCB0LCBuYW1lLCB3aGljaCkge1xyXG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBQYWNrYWdlTGliKHdoaWNoLCB0KTtcclxuICAgICAgICAgICAgTC5zZXRHbG9iYWwobmFtZSwgZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBSZWdpc3RlciBhIGxvYWRlciBpbiBwYWNrYWdlLmxvYWRlcnMuICovXHJcbiAgICAgICAgc3RhdGljIHAoTCwgdCwgd2hpY2gpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgUGFja2FnZUxpYih3aGljaCwgdCk7XHJcbiAgICAgICAgICAgIHZhciBsb2FkZXJzID0gTC5nZXRGaWVsZCh0LCBcImxvYWRlcnNcIik7XHJcbiAgICAgICAgICAgIEwucmF3U2V0SShsb2FkZXJzLCBMdWFfMS5MdWEub2JqTGVuKGxvYWRlcnMpICsgMSwgZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogSW1wbGVtZW50cyB0aGUgcHJlbG9hZCBsb2FkZXIuICBUaGlzIGlzIGNvbnZlbnRpb25hbGx5IHN0b3JlZFxyXG4gICAgICAgICogZmlyc3QgaW4gdGhlIHBhY2thZ2UubG9hZGVycyB0YWJsZS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGxvYWRlclByZWxvYWQoTCkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IEwuY2hlY2tTdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIHZhciBwcmVsb2FkID0gTC5nZXRGaWVsZCh0aGlzLl9tZSwgXCJwcmVsb2FkXCIpO1xyXG4gICAgICAgICAgICBpZiAoIUx1YV8xLkx1YS5pc1RhYmxlKHByZWxvYWQpKVxyXG4gICAgICAgICAgICAgICAgTC5lcnJvcihcIidwYWNrYWdlLnByZWxvYWQnIG11c3QgYmUgYSB0YWJsZVwiKTtcclxuICAgICAgICAgICAgdmFyIGxvYWRlciA9IEwuZ2V0RmllbGQocHJlbG9hZCwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuaXNOaWwobG9hZGVyKSkgLy8gbm90IGZvdW5kP1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoU3RyaW5nKFwiXFxuXFx0bm8gZmllbGQgcGFja2FnZS5wcmVsb2FkWydcIiArIG5hbWUgKyBcIiddXCIpO1xyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3QobG9hZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcGxlbWVudHMgdGhlIGx1YSBsb2FkZXIuICBUaGlzIGlzIGNvbnZlbnRpb25hbGx5IHN0b3JlZCBzZWNvbmQgaW5cclxuICAgICAgICAgKiB0aGUgcGFja2FnZS5sb2FkZXJzIHRhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxvYWRlckx1YShMKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gdGhpcy5maW5kZmlsZShMLCBuYW1lLCBcInBhdGhcIik7XHJcbiAgICAgICAgICAgIGlmIChmaWxlbmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7IC8vIGxpYnJhcnkgbm90IGZvdW5kIGluIHRoaXMgcGF0aFxyXG4gICAgICAgICAgICBpZiAoTC5sb2FkRmlsZShmaWxlbmFtZSkgIT0gMClcclxuICAgICAgICAgICAgICAgIFBhY2thZ2VMaWIubG9hZGVycm9yKEwsIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7IC8vIGxpYnJhcnkgbG9hZGVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBtb2R1bGUuICovXHJcbiAgICAgICAgbW9kdWxlKEwpIHtcclxuICAgICAgICAgICAgdmFyIG1vZG5hbWUgPSBMLmNoZWNrU3RyaW5nKDEpO1xyXG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gTC5nZXRGaWVsZCh0aGlzLl9tZSwgXCJsb2FkZWRcIik7XHJcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSBMLmdldEZpZWxkKGxvYWRlZCwgbW9kbmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghTHVhXzEuTHVhLmlzVGFibGUobW9kdWxlKSkgLy8gbm90IGZvdW5kP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IGdsb2JhbCB2YXJpYWJsZSAoYW5kIGNyZWF0ZSBvbmUgaWYgaXQgZG9lcyBub3QgZXhpc3QpXHJcbiAgICAgICAgICAgICAgICBpZiAoTC5maW5kVGFibGUoTC5nZXRHbG9iYWxzKCksIG1vZG5hbWUsIDEpICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEwuZXJyb3IoXCJuYW1lIGNvbmZsaWN0IGZvciBtb2R1bGUgJ1wiICsgbW9kbmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIG1vZHVsZSA9IEwudmFsdWUoLTEpO1xyXG4gICAgICAgICAgICAgICAgTC5wb3AoMSk7XHJcbiAgICAgICAgICAgICAgICAvLyBwYWNrYWdlLmxvYWRlZCA9IG5ldyB0YWJsZVxyXG4gICAgICAgICAgICAgICAgTC5zZXRGaWVsZChsb2FkZWQsIG1vZG5hbWUsIG1vZHVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0YWJsZSBhbHJlYWR5IGhhcyBhIF9OQU1FIGZpZWxkXHJcbiAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuaXNOaWwoTC5nZXRGaWVsZChtb2R1bGUsIFwiX05BTUVcIikpKSB7XHJcbiAgICAgICAgICAgICAgICBQYWNrYWdlTGliLm1vZGluaXQoTCwgbW9kdWxlLCBtb2RuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQYWNrYWdlTGliLnNldGZlbnYoTCwgbW9kdWxlKTtcclxuICAgICAgICAgICAgUGFja2FnZUxpYi5kb29wdGlvbnMoTCwgbW9kdWxlLCBMLmdldFRvcCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHJlcXVpcmUuICovXHJcbiAgICAgICAgcmVxdWlyZShMKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgTC5zZXRUb3AoMSk7XHJcbiAgICAgICAgICAgIC8vIFBVQy1SaW8ncyB1c2Ugb2YgbHVhX2dldGZpZWxkKEwsIExVQV9SRUdJU1RSWUlOREVYLCBcIl9MT0FERURcIik7XHJcbiAgICAgICAgICAgIC8vIChwYWNrYWdlLmxvYWRlZCBpcyBrZXB0IGluIHRoZSByZWdpc3RyeSBpbiBQVUMtUmlvKSBpcyB0cmFuc2xhdGVkXHJcbiAgICAgICAgICAgIC8vIGludG8gdGhpczpcclxuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IEwuZ2V0RmllbGQodGhpcy5fbWUsIFwibG9hZGVkXCIpO1xyXG4gICAgICAgICAgICB2YXIgbW9kdWxlID0gTC5nZXRGaWVsZChsb2FkZWQsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoTC50b0Jvb2xlYW4obW9kdWxlKSkgLy8gaXMgaXQgdGhlcmU/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlID09IFBhY2thZ2VMaWIuU0VOVElORUwpIC8vIGNoZWNrIGxvb3BzXHJcbiAgICAgICAgICAgICAgICAgICAgTC5lcnJvcihcImxvb3Agb3IgcHJldmlvdXMgZXJyb3IgbG9hZGluZyBtb2R1bGUgJ1wiICsgbmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIEwucHVzaE9iamVjdChtb2R1bGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZWxzZSBtdXN0IGxvYWQgaXQ7IGl0ZXJhdGUgb3ZlciBhdmFpbGFibGUgbG9hZGVycy5cclxuICAgICAgICAgICAgdmFyIGxvYWRlcnMgPSBMLmdldEZpZWxkKHRoaXMuX21lLCBcImxvYWRlcnNcIik7XHJcbiAgICAgICAgICAgIGlmICghTHVhXzEuTHVhLmlzVGFibGUobG9hZGVycykpXHJcbiAgICAgICAgICAgICAgICBMLmVycm9yKFwiJ3BhY2thZ2UubG9hZGVycycgbXVzdCBiZSBhIHRhYmxlXCIpO1xyXG4gICAgICAgICAgICBMLnB1c2hTdHJpbmcoXCJcIik7IC8vIGVycm9yIG1lc3NhZ2UgYWNjdW11bGF0b3JcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb2FkZXIgPSBMdWFfMS5MdWEucmF3R2V0SShsb2FkZXJzLCBpKTsgLy8gZ2V0IGEgbG9hZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhXzEuTHVhLmlzTmlsKGxvYWRlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgTC5lcnJvcihcIm1vZHVsZSAnXCIgKyBuYW1lICsgXCInIG5vdCBmb3VuZDpcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEwudG9TdHJpbmdfKEwudmFsdWUoLTEpKSk7XHJcbiAgICAgICAgICAgICAgICBMLnB1c2hPYmplY3QobG9hZGVyKTtcclxuICAgICAgICAgICAgICAgIEwucHVzaFN0cmluZyhuYW1lKTtcclxuICAgICAgICAgICAgICAgIEwuY2FsbCgxLCAxKTsgLy8gY2FsbCBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5pc0Z1bmN0aW9uKEwudmFsdWUoLTEpKSkgLy8gZGlkIGl0IGZpbmQgbW9kdWxlP1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBtb2R1bGUgbG9hZGVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTHVhXzEuTHVhLmlzU3RyaW5nKEwudmFsdWUoLTEpKSkgLy8gbG9hZGVyIHJldHVybmVkIGVycm9yIG1lc3NhZ2U/XHJcbiAgICAgICAgICAgICAgICAgICAgTC5jb25jYXQoMik7IC8vIGFjY3VtdWxhdGUgaXRcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBMLnBvcCgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLnNldEZpZWxkKGxvYWRlZCwgbmFtZSwgUGFja2FnZUxpYi5TRU5USU5FTCk7IC8vIHBhY2thZ2UubG9hZGVkW25hbWVdID0gc2VudGluZWxcclxuICAgICAgICAgICAgTC5wdXNoU3RyaW5nKG5hbWUpOyAvLyBwYXNzIG5hbWUgYXMgYXJndW1lbnQgdG8gbW9kdWxlXHJcbiAgICAgICAgICAgIEwuY2FsbCgxLCAxKTsgLy8gcnVuIGxvYWRlZCBtb2R1bGVcclxuICAgICAgICAgICAgaWYgKCFMdWFfMS5MdWEuaXNOaWwoTC52YWx1ZSgtMSkpKSAvLyBub24tbmlsIHJldHVybj9cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHBhY2thZ2UubG9hZGVkW25hbWVdID0gcmV0dXJuZWQgdmFsdWVcclxuICAgICAgICAgICAgICAgIEwuc2V0RmllbGQobG9hZGVkLCBuYW1lLCBMLnZhbHVlKC0xKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW9kdWxlID0gTC5nZXRGaWVsZChsb2FkZWQsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAobW9kdWxlID09IFBhY2thZ2VMaWIuU0VOVElORUwpIC8vIG1vZHVsZSBkaWQgbm90IHNldCBhIHZhbHVlP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlID0gTHVhXzEuTHVhLnZhbHVlT2ZCb29sZWFuKHRydWUpOyAvLyB1c2UgdHJ1ZSBhcyByZXN1bHRcclxuICAgICAgICAgICAgICAgIEwuc2V0RmllbGQobG9hZGVkLCBuYW1lLCBtb2R1bGUpOyAvLyBwYWNrYWdlLmxvYWRlZFtuYW1lXSA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3QobW9kdWxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHBhY2thZ2Uuc2VlYWxsLiAqL1xyXG4gICAgICAgIHN0YXRpYyBzZWVhbGwoTCkge1xyXG4gICAgICAgICAgICBMLmNoZWNrVHlwZSgxLCBMdWFfMS5MdWEuVFRBQkxFKTtcclxuICAgICAgICAgICAgdmFyIG10ID0gTC5nZXRNZXRhdGFibGUoTC52YWx1ZSgxKSk7XHJcbiAgICAgICAgICAgIGlmIChtdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBtdCA9IEwuY3JlYXRlVGFibGUoMCwgMSk7XHJcbiAgICAgICAgICAgICAgICBMLnNldE1ldGF0YWJsZShMLnZhbHVlKDEpLCBtdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTC5zZXRGaWVsZChtdCwgXCJfX2luZGV4XCIsIEwuZ2V0R2xvYmFscygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogSGVscGVyIGZvciBtb2R1bGUuICA8dmFyPm1vZHVsZTwvdmFyPiBwYXJhbWV0ZXIgcmVwbGFjZXMgUFVDLVJpb1xyXG4gICAgICAgICogdXNlIG9mIHBhc3NpbmcgaXQgb24gdGhlIHN0YWNrLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIHNldGZlbnYoTCwgbW9kdWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBhciA9IEwuZ2V0U3RhY2soMSk7XHJcbiAgICAgICAgICAgIEwuZ2V0SW5mbyhcImZcIiwgYXIpO1xyXG4gICAgICAgICAgICBMLnNldEZlbnYoTC52YWx1ZSgtMSksIG1vZHVsZSk7XHJcbiAgICAgICAgICAgIEwucG9wKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIZWxwZXIgZm9yIG1vZHVsZS4gIDx2YXI+bW9kdWxlPC92YXI+IHBhcmFtZXRlciByZXBsYWNlcyBQVUMtUmlvXHJcbiAgICAgICAgICogdXNlIG9mIHBhc3NpbmcgaXQgb24gdGhlIHN0YWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBkb29wdGlvbnMoTCwgbW9kdWxlLCBuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoVmFsdWUoaSk7IC8vIGdldCBvcHRpb24gKGEgZnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICBMLnB1c2hPYmplY3QobW9kdWxlKTtcclxuICAgICAgICAgICAgICAgIEwuY2FsbCgxLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEhlbHBlciBmb3IgbW9kdWxlLiAgPHZhcj5tb2R1bGU8L3Zhcj4gcGFyYW1ldGVyIHJlcGxhY2VzIFBVQy1SaW9cclxuICAgICAgICAqIHVzZSBvZiBwYXNzaW5nIGl0IG9uIHRoZSBzdGFjay5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBtb2Rpbml0KEwsIG1vZHVsZSwgbW9kbmFtZSkge1xyXG4gICAgICAgICAgICBMLnNldEZpZWxkKG1vZHVsZSwgXCJfTVwiLCBtb2R1bGUpOyAvLyBtb2R1bGUuX00gPSBtb2R1bGVcclxuICAgICAgICAgICAgTC5zZXRGaWVsZChtb2R1bGUsIFwiX05BTUVcIiwgbW9kbmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBkb3QgPSBtb2RuYW1lLmxhc3RJbmRleE9mKCcuJyk7IC8vIGxvb2sgZm9yIGxhc3QgZG90IGluIG1vZHVsZSBuYW1lXHJcbiAgICAgICAgICAgIC8vIFN1cnByaXNpbmdseSwgKytkb3Qgd29ya3Mgd2hlbiAnLicgd2FzIGZvdW5kIGFuZCB3aGVuIGl0IHdhc24ndC5cclxuICAgICAgICAgICAgKytkb3Q7XHJcbiAgICAgICAgICAgIC8vIHNldCBfUEFDS0FHRSBhcyBwYWNrYWdlIG5hbWUgKGZ1bGwgbW9kdWxlIG5hbWUgbWludXMgbGFzdCBwYXJ0KVxyXG4gICAgICAgICAgICBMLnNldEZpZWxkKG1vZHVsZSwgXCJfUEFDS0FHRVwiLCBtb2RuYW1lLnN1YnN0cmluZygwLCBkb3QpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGxvYWRlcnJvcihMLCBmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICBMLmVycm9yKFwiZXJyb3IgbG9hZGluZyBtb2R1bGUgJ1wiICsgTC50b1N0cmluZ18oTC52YWx1ZSgxKSkgK1xyXG4gICAgICAgICAgICAgICAgXCInIGZyb20gZmlsZSAnXCIgKyBmaWxlbmFtZSArIFwiJzpcXG5cXHRcIiArXHJcbiAgICAgICAgICAgICAgICBMLnRvU3RyaW5nXyhMLnZhbHVlKC0xKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgcmVhZGFibGUoZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5nZXRSZXNvdXJjZUFzU3RyZWFtKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGYgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGYuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChlXyBpbnN0YW5jZW9mIElPRXhjZXB0aW9uXzEuSU9FeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlXy5nZXRTdGFja1RyYWNlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgcHVzaG5leHR0ZW1wbGF0ZShMLCBwYXRoKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgLy8gc2tpcCBzZXBlcmF0b3JzXHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGggJiYgcGF0aC5zdWJzdHIoaSwgMSkgPT0gUGFja2FnZUxpYi5QQVRIU0VQKSAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGlmIChpID09IHBhdGgubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG5vIG1vcmUgdGVtcGxhdGVzXHJcbiAgICAgICAgICAgIHZhciBsID0gcGF0aC5pbmRleE9mKFBhY2thZ2VMaWIuUEFUSFNFUCwgaSk7XHJcbiAgICAgICAgICAgIGlmIChsIDwgMClcclxuICAgICAgICAgICAgICAgIGwgPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICAgICAgTC5wdXNoU3RyaW5nKHBhdGguc3Vic3RyaW5nKGksIGwpKTsgLy8gdGVtcGxhdGVcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5kZmlsZShMLCBuYW1lLCBwbmFtZSkge1xyXG4gICAgICAgICAgICBuYW1lID0gUGFja2FnZUxpYi5nc3ViKG5hbWUsIFwiLlwiLCBQYWNrYWdlTGliLkRJUlNFUCk7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gTC50b1N0cmluZ18oTC5nZXRGaWVsZCh0aGlzLl9tZSwgcG5hbWUpKTtcclxuICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIEwuZXJyb3IoXCIncGFja2FnZS5cIiArIHBuYW1lICsgXCInIG11c3QgYmUgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIEwucHVzaFN0cmluZyhcIlwiKTsgLy8gZXJyb3IgYWNjdW11bGF0b3JcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBQYWNrYWdlTGliLnB1c2huZXh0dGVtcGxhdGUoTCwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gUGFja2FnZUxpYi5nc3ViKEwudG9TdHJpbmdfKEwudmFsdWUoLTEpKSwgUGFja2FnZUxpYi5QQVRIX01BUkssIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBhY2thZ2VMaWIucmVhZGFibGUoZmlsZW5hbWUpKSAvLyBkb2VzIGZpbGUgZXhpc3QgYW5kIGlzIHJlYWRhYmxlP1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlbmFtZTsgLy8gcmV0dXJuIHRoYXQgZmlsZSBuYW1lXHJcbiAgICAgICAgICAgICAgICBMLnBvcCgxKTsgLy8gcmVtb3ZlIHBhdGggdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgIEwucHVzaFN0cmluZyhcIlxcblxcdG5vIGZpbGUgJ1wiICsgZmlsZW5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICBMLmNvbmNhdCgyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm90IGZvdW5kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBBbG1vc3QgZXF1aXZhbGVudCB0byBsdWFMX2dzdWIuICovXHJcbiAgICAgICAgc3RhdGljIGdzdWIocywgcCwgcikge1xyXG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBpbmNyZW1lbnRpbmcgdGhlIGNoYXIgKnMsIHdlIHVzZSB0aGUgaW5kZXggaVxyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBsID0gcC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lsZCA9IHMuaW5kZXhPZihwLCBpKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aWxkIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKHMuc3Vic3RyaW5nKGksIHdpbGQpKTsgLy8gYWRkIHByZWZpeFxyXG4gICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcocik7IC8vIGFkZCByZXBsYWNlbWVudCBpbiBwbGFjZSBvZiBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICBpID0gd2lsZCArIGw7IC8vIGNvbnRpbnVlIGFmdGVyICdwJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKHMuc3Vic3RyaW5nKGkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGIudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIHNldHBhdGgoTCwgdCwgZmllbGRuYW1lLCBkZWYpIHtcclxuICAgICAgICAgICAgLy8gOnRvZG86IGNvbnNpZGVyIGltcGxlbWVudGluZyBhIHVzZXItc3BlY2lmaWVkIHBhdGggdmlhXHJcbiAgICAgICAgICAgIC8vIGphdmF4Lm1pY3JvZWRpdGlvbi5taWRsZXQuTUlEbGV0LmdldEFwcFByb3BlcnR5IG9yIHNpbWlsYXIuXHJcbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSB3ZSBqdXN0IHVzZSBhIGRlZmF1bHQgcGF0aCBkZWZpbmVkIGJ5IEppbGwuXHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQodCwgZmllbGRuYW1lLCBkZWYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuUGFja2FnZUxpYiA9IFBhY2thZ2VMaWI7XHJcbiAgICAvLyBFYWNoIGZ1bmN0aW9uIGluIHRoZSBsaWJyYXJ5IGNvcnJlc3BvbmRzIHRvIGFuIGluc3RhbmNlIG9mXHJcbiAgICAvLyB0aGlzIGNsYXNzIHdoaWNoIGlzIGFzc29jaWF0ZWQgKHRoZSAnd2hpY2gnIG1lbWJlcikgd2l0aCBhbiBpbnRlZ2VyXHJcbiAgICAvLyB3aGljaCBpcyB1bmlxdWUgd2l0aGluIHRoaXMgY2xhc3MuICBUaGV5IGFyZSB0YWtlbiBmcm9tIHRoZSBmb2xsb3dpbmdcclxuICAgIC8vIHNldC5cclxuICAgIFBhY2thZ2VMaWIuTU9EVUxFID0gMTtcclxuICAgIFBhY2thZ2VMaWIuUkVRVUlSRSA9IDI7XHJcbiAgICBQYWNrYWdlTGliLlNFRUFMTCA9IDM7XHJcbiAgICBQYWNrYWdlTGliLkxPQURFUl9QUkVMT0FEID0gNDtcclxuICAgIFBhY2thZ2VMaWIuTE9BREVSX0xVQSA9IDU7XHJcbiAgICBQYWNrYWdlTGliLkRJUlNFUCA9IFwiL1wiO1xyXG4gICAgUGFja2FnZUxpYi5QQVRIU0VQID0gJzsnOyAvL1RPRE86XHJcbiAgICBQYWNrYWdlTGliLlBBVEhfTUFSSyA9IFwiP1wiO1xyXG4gICAgUGFja2FnZUxpYi5QQVRIX0RFRkFVTFQgPSBcIj8ubHVhOz8vaW5pdC5sdWFcIjtcclxuICAgIFBhY2thZ2VMaWIuU0VOVElORUwgPSBuZXcgT2JqZWN0KCk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYWNrYWdlTGliLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIiwgXCIuLi9qYXZhL051bGxQb2ludGVyRXhjZXB0aW9uXCIsIFwiLi4vamF2YS9TeXN0ZW1VdGlsXCIsIFwiLi9Mb2NWYXJcIiwgXCIuL0x1YVwiLCBcIi4vU2xvdFwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuUHJvdG8gPSB2b2lkIDA7XHJcbiAgICBjb25zdCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuICAgIGNvbnN0IE51bGxQb2ludGVyRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vamF2YS9OdWxsUG9pbnRlckV4Y2VwdGlvblwiKTtcclxuICAgIGNvbnN0IFN5c3RlbVV0aWxfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL1N5c3RlbVV0aWxcIik7XHJcbiAgICBjb25zdCBMb2NWYXJfMSA9IHJlcXVpcmUoXCIuL0xvY1ZhclwiKTtcclxuICAgIGNvbnN0IEx1YV8xID0gcmVxdWlyZShcIi4vTHVhXCIpO1xyXG4gICAgY29uc3QgU2xvdF8xID0gcmVxdWlyZShcIi4vU2xvdFwiKTtcclxuICAgIC8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9Qcm90by5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvKipcclxuICAgICAqIE1vZGVscyBhIGZ1bmN0aW9uIHByb3RvdHlwZS4gIFRoaXMgY2xhc3MgaXMgaW50ZXJuYWwgdG8gSmlsbCBhbmRcclxuICAgICAqIHNob3VsZCBub3QgYmUgdXNlZCBieSBjbGllbnRzLiAgVGhpcyBpcyB0aGUgYW5hbG9ndWUgb2YgdGhlIFBVQy1SaW9cclxuICAgICAqIHR5cGUgPGNvZGU+UHJvdG88L2NvZGU+LCBoZW5jZSB0aGUgbmFtZS5cclxuICAgICAqIEEgZnVuY3Rpb24gcHJvdG90eXBlIHJlcHJlc2VudHMgdGhlIGNvbnN0YW50IHBhcnQgb2YgYSBmdW5jdGlvbiwgdGhhdFxyXG4gICAgICogaXMsIGEgZnVuY3Rpb24gd2l0aG91dCBjbG9zdXJlcyAodXB2YWx1ZXMpIGFuZCB3aXRob3V0IGFuXHJcbiAgICAgKiBlbnZpcm9ubWVudC4gIEl0J3MgYSBoYW5kbGUgZm9yIGEgYmxvY2sgb2YgVk0gaW5zdHJ1Y3Rpb25zIGFuZFxyXG4gICAgICogYW5jaWxsYXJ5IGNvbnN0YW50cy5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29udmVuaWVuY2Ugc29tZSBwcml2YXRlIGFycmF5cyBhcmUgZXhwb3NlZC4gIE1vZGlmeWluZyB0aGVzZVxyXG4gICAgICogYXJyYXlzIGlzIHB1bmlzaGFibGUgYnkgZGVhdGguIChKYXZhIGhhcyBubyBjb252ZW5pZW50IGNvbnN0YW50XHJcbiAgICAgKiBhcnJheSBkYXRhdHlwZSlcclxuICAgICAqL1xyXG4gICAgY2xhc3MgUHJvdG8ge1xyXG4gICAgICAgIC8vVE9ETzpcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgLy8gR2VuZXJhbGx5IHRoZSBmaWVsZHMgYXJlIG5hbWVkIGZvbGxvd2luZyB0aGUgUFVDLVJpbyBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAvLyBhbmQgc28gYXJlIHVudXN1YWxseSB0ZXJzZS5cclxuICAgICAgICAgICAgLyoqIEFycmF5IG9mIGNvbnN0YW50cy4gKi9cclxuICAgICAgICAgICAgdGhpcy5fayA9IG51bGw7IC8vU2xvdFtdIFxyXG4gICAgICAgICAgICB0aGlzLl9zaXplayA9IDA7XHJcbiAgICAgICAgICAgIC8qKiBBcnJheSBvZiBWTSBpbnN0cnVjdGlvbnMuICovXHJcbiAgICAgICAgICAgIHRoaXMuX2NvZGUgPSBudWxsOyAvL2ludFtdIFxyXG4gICAgICAgICAgICB0aGlzLl9zaXplY29kZSA9IDA7XHJcbiAgICAgICAgICAgIC8qKiBBcnJheSBvZiBQcm90byBvYmplY3RzLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9wID0gbnVsbDsgLy9Qcm90b1tdIFxyXG4gICAgICAgICAgICB0aGlzLl9zaXplcCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOdW1iZXIgb2YgdXB2YWx1ZXMgdXNlZCBieSB0aGlzIHByb3RvdHlwZSAoYW5kIHNvIGJ5IGFsbCB0aGVcclxuICAgICAgICAgICAgICogZnVuY3Rpb25zIGNyZWF0ZWQgZnJvbSB0aGlzIFByb3RvKS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX251cHMgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTnVtYmVyIG9mIGZvcm1hbCBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhpcyBwcm90b3R5cGUsIGFuZCBzbyB0aGVcclxuICAgICAgICAgICAgICogbnVtYmVyIG9mIGFyZ3VtZW50IHJlY2VpdmVkIGJ5IGEgZnVuY3Rpb24gY3JlYXRlZCBmcm9tIHRoaXMgUHJvdG8uXHJcbiAgICAgICAgICAgICAqIEluIGEgZnVuY3Rpb24gZGVmaW5lZCB0byBiZSB2YXJpYWRpYyB0aGVuIHRoaXMgaXMgdGhlIG51bWJlciBvZlxyXG4gICAgICAgICAgICAgKiBmaXhlZCBwYXJhbWV0ZXJzLCB0aGUgbnVtYmVyIGFwcGVhcmluZyBiZWZvcmUgJy4uLicgaW4gdGhlIHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgKiBsaXN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fbnVtcGFyYW1zID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIGFuZCBvbmx5IGlmIHRoZSBmdW5jdGlvbiBpcyB2YXJpYWRpYywgdGhhdCBpcyxcclxuICAgICAgICAgICAgICogZGVmaW5lZCB3aXRoICcuLi4nIGluIGl0cyBwYXJhbWV0ZXIgbGlzdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmFyYXJnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX21heHN0YWNrc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIC8vIERlYnVnIGluZm9cclxuICAgICAgICAgICAgLyoqIE1hcCBmcm9tIFBDIHRvIGxpbmUgbnVtYmVyLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9saW5laW5mbyA9IG51bGw7IC8vaW50W11cclxuICAgICAgICAgICAgdGhpcy5fc2l6ZWxpbmVpbmZvID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbG9jdmFycyA9IG51bGw7IC8vTG9jVmFyW10gXHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVsb2N2YXJzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdXB2YWx1ZXMgPSBudWxsOyAvL1N0cmluZ1tdIFxyXG4gICAgICAgICAgICB0aGlzLl9zaXpldXB2YWx1ZXMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lZGVmaW5lZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RsaW5lZGVmaW5lZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3RvIHN5bnRoZXNpemVkIGJ5IHtAbGluayBMb2FkZXJ9LlxyXG4gICAgICAgICAqIEFsbCB0aGUgYXJyYXlzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IgYXJlXHJcbiAgICAgICAgICogcmVmZXJlbmNlZCBieSB0aGUgaW5zdGFuY2UuICBBdm9pZCB1bmludGVudGlvbmFsIHNoYXJpbmcuICBBbGxcclxuICAgICAgICAgKiBhcnJheXMgbXVzdCBiZSBub24tbnVsbCBhbmQgYWxsIGludCBwYXJhbWV0ZXJzIG11c3Qgbm90IGJlXHJcbiAgICAgICAgICogbmVnYXRpdmUuICBHZW5lcmFsbHksIHRoaXMgY29uc3RydWN0b3IgaXMgdXNlZCBieSB7QGxpbmsgTG9hZGVyfVxyXG4gICAgICAgICAqIHNpbmNlIHRoYXQgaGFzIGFsbCB0aGUgcmVsZXZhbnQgYXJyYXlzIGFscmVhZHkgY29uc3RydWN0ZWQgKGFzXHJcbiAgICAgICAgICogb3Bwb3NlZCB0byB0aGUgY29tcGlsZXIpLlxyXG4gICAgICAgICAqIEBwYXJhbSBjb25zdGFudCAgIGFycmF5IG9mIGNvbnN0YW50cy5cclxuICAgICAgICAgKiBAcGFyYW0gY29kZSAgICAgICBhcnJheSBvZiBWTSBpbnN0cnVjdGlvbnMuXHJcbiAgICAgICAgICogQHBhcmFtIG51cHMgICAgICAgbnVtYmVyIG9mIHVwdmFsdWVzICh1c2VkIGJ5IHRoaXMgZnVuY3Rpb24pLlxyXG4gICAgICAgICAqIEBwYXJhbSBudW1wYXJhbXMgIG51bWJlciBvZiBmaXhlZCBmb3JtYWwgcGFyYW1ldGVycy5cclxuICAgICAgICAgKiBAcGFyYW0gaXNWYXJhcmcgICB3aGV0aGVyICcuLi4nIGlzIHVzZWQuXHJcbiAgICAgICAgICogQHBhcmFtIG1heHN0YWNrc2l6ZSAgbnVtYmVyIG9mIHN0YWNrIHNsb3RzIHJlcXVpcmVkIHdoZW4gaW52b2tpbmcuXHJcbiAgICAgICAgICogQHRocm93cyBOdWxsUG9pbnRlckV4Y2VwdGlvbiBpZiBhbnkgYXJyYXkgYXJndW1lbnRzIGFyZSBudWxsLlxyXG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIG51cHMgb3IgbnVtcGFyYW1zIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQxKGNvbnN0YW50LCAvL1Nsb3RbXSBcclxuICAgICAgICBjb2RlLCAvL2ludFtdIFxyXG4gICAgICAgIHByb3RvLCAvL1Byb3RvW10gXHJcbiAgICAgICAgbnVwcywgbnVtcGFyYW1zLCBpc1ZhcmFyZywgbWF4c3RhY2tzaXplKSB7XHJcbiAgICAgICAgICAgIGlmIChudWxsID09IGNvbnN0YW50IHx8IG51bGwgPT0gY29kZSB8fCBudWxsID09IHByb3RvKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb25fMS5OdWxsUG9pbnRlckV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChudXBzIDwgMCB8fCBudW1wYXJhbXMgPCAwIHx8IG1heHN0YWNrc2l6ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9rID0gY29uc3RhbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVrID0gdGhpcy5fay5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9zaXplY29kZSA9IHRoaXMuX2NvZGUubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl9wID0gcHJvdG87XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVwID0gcHJvdG8ubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl9udXBzID0gbnVwcztcclxuICAgICAgICAgICAgdGhpcy5fbnVtcGFyYW1zID0gbnVtcGFyYW1zO1xyXG4gICAgICAgICAgICB0aGlzLmlzVmFyYXJnID0gaXNWYXJhcmc7XHJcbiAgICAgICAgICAgIHRoaXMuX21heHN0YWNrc2l6ZSA9IG1heHN0YWNrc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmxhbmsgUHJvdG8gaW4gcHJlcGFyYXRpb24gZm9yIGNvbXBpbGF0aW9uLlxyXG4gICAgICAgICAqIOW6n+W8g++8n1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQyKHNvdXJjZSwgbWF4c3RhY2tzaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21heHN0YWNrc2l6ZSA9IG1heHN0YWNrc2l6ZTtcclxuICAgICAgICAgICAgLy8gbWF4c3RhY2tzaXplID0gMjsgICAvLyByZWdpc3RlciAwLzEgYXJlIGFsd2F5cyB2YWxpZC5cclxuICAgICAgICAgICAgLy8gOnRvZG86IENvbnNpZGVyIHJlbW92aW5nIHNpemUqIG1lbWJlcnNcclxuICAgICAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xyXG4gICAgICAgICAgICB0aGlzLl9rID0gUHJvdG8uWkVST19DT05TVEFOVF9BUlJBWTtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZWsgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2RlID0gUHJvdG8uWkVST19JTlRfQVJSQVk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVjb2RlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcCA9IFByb3RvLlpFUk9fUFJPVE9fQVJSQVk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVwID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGluZWluZm8gPSBQcm90by5aRVJPX0lOVF9BUlJBWTtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZWxpbmVpbmZvID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbG9jdmFycyA9IFByb3RvLlpFUk9fTE9DVkFSX0FSUkFZO1xyXG4gICAgICAgICAgICB0aGlzLl9zaXplbG9jdmFycyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwdmFsdWVzID0gUHJvdG8uWkVST19TVFJJTkdfQVJSQVk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemV1cHZhbHVlcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF1Z21lbnQgd2l0aCBkZWJ1ZyBpbmZvLiAgQWxsIHRoZSBhcmd1bWVudHMgYXJlIHJlZmVyZW5jZWQgYnkgdGhlXHJcbiAgICAgICAgICogaW5zdGFuY2UgYWZ0ZXIgdGhlIG1ldGhvZCBoYXMgcmV0dXJuZWQsIHNvIHRyeSBub3QgdG8gc2hhcmUgdGhlbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWJ1ZyhsaW5laW5mb0FyZywgLy9pbnRbXSBcclxuICAgICAgICBsb2N2YXJzQXJnLCAvL0xvY1ZhcltdIFxyXG4gICAgICAgIHVwdmFsdWVzQXJnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVpbmZvID0gbGluZWluZm9Bcmc7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVsaW5laW5mbyA9IHRoaXMuX2xpbmVpbmZvLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fbG9jdmFycyA9IGxvY3ZhcnNBcmc7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVsb2N2YXJzID0gdGhpcy5fbG9jdmFycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwdmFsdWVzID0gdXB2YWx1ZXNBcmc7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemV1cHZhbHVlcyA9IHRoaXMuX3VwdmFsdWVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEdldHMgc291cmNlLiAqL1xyXG4gICAgICAgIGdldCBzb3VyY2UoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBTZXR0ZXIgZm9yIHNvdXJjZS4gKi9cclxuICAgICAgICBzZXQgc291cmNlKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBsaW5lZGVmaW5lZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVkZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgbGluZWRlZmluZWQobGluZWRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGluZWRlZmluZWQgPSBsaW5lZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGxhc3RsaW5lZGVmaW5lZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RsaW5lZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGxhc3RsaW5lZGVmaW5lZChsYXN0bGluZWRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdGxpbmVkZWZpbmVkID0gbGFzdGxpbmVkZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogR2V0cyBOdW1iZXIgb2YgVXB2YWx1ZXMgKi9cclxuICAgICAgICBnZXQgbnVwcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX251cHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldCBudXBzKG51cHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fbnVwcyA9IG51cHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBOdW1iZXIgb2YgUGFyYW1ldGVycy4gKi9cclxuICAgICAgICBnZXQgbnVtcGFyYW1zKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnVtcGFyYW1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgbnVtcGFyYW1zKG51bXBhcmFtcykge1xyXG4gICAgICAgICAgICB0aGlzLl9udW1wYXJhbXMgPSBudW1wYXJhbXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBNYXhpbXVtIFN0YWNrIFNpemUuICovXHJcbiAgICAgICAgZ2V0IG1heHN0YWNrc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heHN0YWNrc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFNldHRlciBmb3IgbWF4aW11bSBzdGFjayBzaXplLiAqL1xyXG4gICAgICAgIHNldCBtYXhzdGFja3NpemUobSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXhzdGFja3NpemUgPSBtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW5zdHJ1Y3Rpb24gYmxvY2sgKGRvIG5vdCBtb2RpZnkpLiAqL1xyXG4gICAgICAgIGdldCBjb2RlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEFwcGVuZCBpbnN0cnVjdGlvbi4gKi9cclxuICAgICAgICBjb2RlQXBwZW5kKEwsIHBjLCBpbnN0cnVjdGlvbiwgbGluZSkge1xyXG4gICAgICAgICAgICBpZiAoUHJvdG8uRCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYzpcIiArIHBjICtcclxuICAgICAgICAgICAgICAgICAgICBcIiwgaW5zdHJ1Y3Rpb246XCIgKyBpbnN0cnVjdGlvbiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIsIGxpbmU6XCIgKyBsaW5lICtcclxuICAgICAgICAgICAgICAgICAgICBcIiwgbGluZWluZm8ubGVuZ3RoOlwiICsgdGhpcy5saW5laW5mby5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ29kZShMLCBwYyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvZGVbcGNdID0gaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgICAgIGlmIChwYyA+PSB0aGlzLl9saW5laW5mby5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdMaW5laW5mbyA9IG5ldyBBcnJheSh0aGlzLl9saW5laW5mby5sZW5ndGggKiAyICsgMSk7IC8vaW50W11cclxuICAgICAgICAgICAgICAgIFN5c3RlbVV0aWxfMS5TeXN0ZW1VdGlsLmFycmF5Y29weSh0aGlzLl9saW5laW5mbywgMCwgbmV3TGluZWluZm8sIDAsIHRoaXMuX2xpbmVpbmZvLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5laW5mbyA9IG5ld0xpbmVpbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVpbmZvW3BjXSA9IGxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuc3VyZUxvY3ZhcnMoTCwgYXRsZWFzdCwgbGltaXQpIHtcclxuICAgICAgICAgICAgaWYgKGF0bGVhc3QgKyAxID4gdGhpcy5fc2l6ZWxvY3ZhcnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdzaXplID0gYXRsZWFzdCAqIDIgKyAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld3NpemUgPiBsaW1pdClcclxuICAgICAgICAgICAgICAgICAgICBuZXdzaXplID0gbGltaXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXRsZWFzdCArIDEgPiBuZXdzaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIEwuZ1J1bmVycm9yKFwidG9vIG1hbnkgbG9jYWwgdmFyaWFibGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld2xvY3ZhcnMgPSBuZXcgQXJyYXkobmV3c2l6ZSk7IC8vTG9jVmFyIFtdXHJcbiAgICAgICAgICAgICAgICBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5hcnJheWNvcHkodGhpcy5sb2N2YXJzLCAwLCBuZXdsb2N2YXJzLCAwLCB0aGlzLl9zaXplbG9jdmFycyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fc2l6ZWxvY3ZhcnM7IGkgPCBuZXdzaXplOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3bG9jdmFyc1tpXSA9IG5ldyBMb2NWYXJfMS5Mb2NWYXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvY3ZhcnMgPSBuZXdsb2N2YXJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZWxvY3ZhcnMgPSBuZXdzaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuc3VyZVByb3RvcyhMLCBhdGxlYXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChhdGxlYXN0ICsgMSA+IHRoaXMuX3NpemVwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3c2l6ZSA9IGF0bGVhc3QgKiAyICsgMTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdzaXplID4gTHVhXzEuTHVhLk1BWEFSR19CeClcclxuICAgICAgICAgICAgICAgICAgICBuZXdzaXplID0gTHVhXzEuTHVhLk1BWEFSR19CeDtcclxuICAgICAgICAgICAgICAgIGlmIChhdGxlYXN0ICsgMSA+IG5ld3NpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgTC5nUnVuZXJyb3IoXCJjb25zdGFudCB0YWJsZSBvdmVyZmxvd1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdwcm90b3MgPSBuZXcgQXJyYXkobmV3c2l6ZSk7IC8vUHJvdG8gW10gXHJcbiAgICAgICAgICAgICAgICBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5hcnJheWNvcHkodGhpcy5fcCwgMCwgbmV3cHJvdG9zLCAwLCB0aGlzLl9zaXplcCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gbmV3cHJvdG9zO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZXAgPSBuZXdzaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuc3VyZVVwdmFscyhMLCBhdGxlYXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChhdGxlYXN0ICsgMSA+IHRoaXMuX3NpemV1cHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld3NpemUgPSBhdGxlYXN0ICogMiArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXRsZWFzdCArIDEgPiBuZXdzaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIEwuZ1J1bmVycm9yKFwidXB2YWx1ZXMgb3ZlcmZsb3dcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3dXB2YWx1ZXMgPSBuZXcgQXJyYXkobmV3c2l6ZSk7IC8vU3RyaW5nIFtdXHJcbiAgICAgICAgICAgICAgICBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5hcnJheWNvcHkodGhpcy5fdXB2YWx1ZXMsIDAsIG5ld3VwdmFsdWVzLCAwLCB0aGlzLl9zaXpldXB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXB2YWx1ZXMgPSBuZXd1cHZhbHVlcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NpemV1cHZhbHVlcyA9IG5ld3NpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZW5zdXJlQ29kZShMLCBhdGxlYXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChhdGxlYXN0ICsgMSA+IHRoaXMuX3NpemVjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3c2l6ZSA9IGF0bGVhc3QgKiAyICsgMTtcclxuICAgICAgICAgICAgICAgIGlmIChhdGxlYXN0ICsgMSA+IG5ld3NpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgTC5nUnVuZXJyb3IoXCJjb2RlIG92ZXJmbG93XCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld2NvZGUgPSBuZXcgQXJyYXkobmV3c2l6ZSk7IC8vaW50IFtdIFxyXG4gICAgICAgICAgICAgICAgU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuYXJyYXljb3B5KHRoaXMuX2NvZGUsIDAsIG5ld2NvZGUsIDAsIHRoaXMuX3NpemVjb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvZGUgPSBuZXdjb2RlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZWNvZGUgPSBuZXdzaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBTZXQgbGluZWluZm8gcmVjb3JkLiAqL1xyXG4gICAgICAgIHNldExpbmVpbmZvKHBjLCBsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVpbmZvW3BjXSA9IGxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBHZXQgbGluZW51bWJlciBjb3JyZXNwb25kaW5nIHRvIHBjLCBvciAwIGlmIG5vIGluZm8uICovXHJcbiAgICAgICAgZ2V0bGluZShwYykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZWluZm8ubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5laW5mb1twY107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBBcnJheSBvZiBpbm5lciBwcm90b3MgKGRvIG5vdCBtb2RpZnkpLiAqL1xyXG4gICAgICAgIGdldCBwcm90bygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBDb25zdGFudCBhcnJheSAoZG8gbm90IG1vZGlmeSkuICovXHJcbiAgICAgICAgZ2V0IGNvbnN0YW50KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEFwcGVuZCBjb25zdGFudC4gKi9cclxuICAgICAgICBjb25zdGFudEFwcGVuZChpZHgsIG8pIHtcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSB0aGlzLl9rLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0sgPSBuZXcgQXJyYXkodGhpcy5fay5sZW5ndGggKiAyICsgMSk7IC8vU2xvdFtdXHJcbiAgICAgICAgICAgICAgICBTeXN0ZW1VdGlsXzEuU3lzdGVtVXRpbC5hcnJheWNvcHkodGhpcy5faywgMCwgbmV3SywgMCwgdGhpcy5fay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fayA9IG5ld0s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fa1tpZHhdID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2tbaWR4XS5pbml0MihvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFByZWRpY2F0ZSBmb3Igd2hldGhlciBmdW5jdGlvbiB1c2VzIC4uLiBpbiBpdHMgcGFyYW1ldGVyIGxpc3QuICovXHJcbiAgICAgICAgZ2V0IGlzVmFyYXJnKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNWYXJhcmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBcIlNldHRlclwiIGZvciBpc1ZhcmFyZy4gIFNldHMgaXQgdG8gdHJ1ZS4gKi9cclxuICAgICAgICBzZXQgaXNWYXJhcmcoaXNWYXJhcmcpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNWYXJhcmcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogTG9jVmFyIGFycmF5IChkbyBub3QgbW9kaWZ5KS4gKi9cclxuICAgICAgICBnZXQgbG9jdmFycygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY3ZhcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFsbCB0aGUgdHJpbSBmdW5jdGlvbnMsIGJlbG93LCBjaGVjayBmb3IgdGhlIHJlZHVuZGFudCBjYXNlIG9mXHJcbiAgICAgICAgLy8gdHJpbW1pbmcgdG8gdGhlIGxlbmd0aCB0aGF0IHRoZXkgYWxyZWFkeSBhcmUuICBCZWNhdXNlIHRoZXkgYXJlXHJcbiAgICAgICAgLy8gaW5pdGlhbGx5IGFsbG9jYXRlZCBhcyBpbnRlcm5lZCB6ZXJvLWxlbmd0aCBhcnJheXMgdGhpcyBhbHNvIG1lYW5zXHJcbiAgICAgICAgLy8gdGhhdCBubyB1bm5lY2VzYXJ5IHplcm8tbGVuZ3RoIGFycmF5IG9iamVjdHMgYXJlIGFsbG9jYXRlZC5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmltIGFuIGludCBhcnJheSB0byBzcGVjaWZpZWQgc2l6ZS5cclxuICAgICAgICAgKiBAcmV0dXJuIHRoZSB0cmltbWVkIGFycmF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRyaW1JbnQob2xkIC8qaW50W10gKi8sIG4pIHtcclxuICAgICAgICAgICAgaWYgKG4gPT0gb2xkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobik7IC8vaW50W10gXHJcbiAgICAgICAgICAgIFN5c3RlbVV0aWxfMS5TeXN0ZW1VdGlsLmFycmF5Y29weShvbGQsIDAsIG5ld0FycmF5LCAwLCBuKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogVHJpbSBjb2RlIGFycmF5IHRvIHNwZWNpZmllZCBzaXplLiAqL1xyXG4gICAgICAgIGNsb3NlQ29kZShuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvZGUgPSB0aGlzLnRyaW1JbnQodGhpcy5fY29kZSwgbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVjb2RlID0gdGhpcy5fY29kZS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBUcmltIGxpbmVpbmZvIGFycmF5IHRvIHNwZWNpZmllZCBzaXplLiAqL1xyXG4gICAgICAgIGNsb3NlTGluZWluZm8obikge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5laW5mbyA9IHRoaXMudHJpbUludCh0aGlzLl9saW5laW5mbywgbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVsaW5laW5mbyA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBUcmltIGsgKGNvbnN0YW50KSBhcnJheSB0byBzcGVjaWZpZWQgc2l6ZS4gKi9cclxuICAgICAgICBjbG9zZUsobikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fay5sZW5ndGggPiBuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobik7IC8vU2xvdFtdIFxyXG4gICAgICAgICAgICAgICAgU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuYXJyYXljb3B5KHRoaXMuX2ssIDAsIG5ld0FycmF5LCAwLCBuKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2sgPSBuZXdBcnJheTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zaXplayA9IG47XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFRyaW0gcCAocHJvdG8pIGFycmF5IHRvIHNwZWNpZmllZCBzaXplLiAqL1xyXG4gICAgICAgIGNsb3NlUChuKSB7XHJcbiAgICAgICAgICAgIGlmIChuID09IHRoaXMuX3AubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG4pOyAvL1Byb3RvW10gXHJcbiAgICAgICAgICAgIFN5c3RlbVV0aWxfMS5TeXN0ZW1VdGlsLmFycmF5Y29weSh0aGlzLl9wLCAwLCBuZXdBcnJheSwgMCwgbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3AgPSBuZXdBcnJheTtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZXAgPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogVHJpbSBsb2N2YXIgYXJyYXkgdG8gc3BlY2lmaWVkIHNpemUuICovXHJcbiAgICAgICAgY2xvc2VMb2N2YXJzKG4pIHtcclxuICAgICAgICAgICAgaWYgKG4gPT0gdGhpcy5sb2N2YXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuKTsgLy9Mb2NWYXJbXSBcclxuICAgICAgICAgICAgU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuYXJyYXljb3B5KHRoaXMubG9jdmFycywgMCwgbmV3QXJyYXksIDAsIG4pO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2N2YXJzID0gbmV3QXJyYXk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVsb2N2YXJzID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFRyaW0gdXB2YWx1ZXMgYXJyYXkgdG8gc2l6ZSA8dmFyPm51cHM8L3Zhcj4uICovXHJcbiAgICAgICAgY2xvc2VVcHZhbHVlcygpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubnVwcyA9PSB0aGlzLl91cHZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkodGhpcy5udXBzKTsgLy9TdHJpbmdbXSBcclxuICAgICAgICAgICAgU3lzdGVtVXRpbF8xLlN5c3RlbVV0aWwuYXJyYXljb3B5KHRoaXMuX3VwdmFsdWVzLCAwLCBuZXdBcnJheSwgMCwgdGhpcy5udXBzKTtcclxuICAgICAgICAgICAgdGhpcy5fdXB2YWx1ZXMgPSBuZXdBcnJheTtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZXVwdmFsdWVzID0gdGhpcy5udXBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBrKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgc2l6ZWsoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgc2l6ZWNvZGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplY29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IHNpemVwKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IGxpbmVpbmZvKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZWluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IHNpemVsaW5laW5mbygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVsaW5laW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgc2l6ZWxvY3ZhcnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplbG9jdmFycztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgdXB2YWx1ZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBnZXQgc2l6ZXVwdmFsdWVzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZXVwdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuUHJvdG8gPSBQcm90bztcclxuICAgIFByb3RvLkQgPSBmYWxzZTtcclxuICAgIC8qKiBJbnRlcm5lZCAwLWVsZW1lbnQgYXJyYXkuICovXHJcbiAgICBQcm90by5aRVJPX0lOVF9BUlJBWSA9IG5ldyBBcnJheSgpOyAvKmludFtdID0gbmV3IGludFswXSovXHJcbiAgICBQcm90by5aRVJPX0xPQ1ZBUl9BUlJBWSA9IG5ldyBBcnJheSgpOyAvKkxvY1ZhcltdICA9IG5ldyBMb2NWYXJbMF0qL1xyXG4gICAgUHJvdG8uWkVST19DT05TVEFOVF9BUlJBWSA9IG5ldyBBcnJheSgpOyAvL2ZpbmFsIFNsb3RbXSBaRVJPX0NPTlNUQU5UX0FSUkFZID0gbmV3IFNsb3RbMF07XHJcbiAgICBQcm90by5aRVJPX1BST1RPX0FSUkFZID0gbmV3IEFycmF5KCk7IC8vZmluYWwgUHJvdG9bXSBaRVJPX1BST1RPX0FSUkFZID0gbmV3IFByb3RvWzBdO1xyXG4gICAgUHJvdG8uWkVST19TVFJJTkdfQVJSQVkgPSBuZXcgQXJyYXkoKTsgLy9maW5hbCBTdHJpbmdbXSBaRVJPX1NUUklOR19BUlJBWSA9IG5ldyBTdHJpbmdbMF07XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm90by5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vTHVhXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5TbG90ID0gdm9pZCAwO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvQmxvY2tDbnQuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICBjbGFzcyBTbG90IHtcclxuICAgICAgICAvL3ByaXZhdGUgdmFyIF90YWc6Qm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIC8vcHVibGljIHZhciB0YWdVcFZhbDpCb29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3IgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9kID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5pdDEocykge1xyXG4gICAgICAgICAgICB0aGlzLl9yID0gcy5fcjtcclxuICAgICAgICAgICAgdGhpcy5fZCA9IHMuX2Q7XHJcbiAgICAgICAgICAgIC8vdGVzdEQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgIGluaXQyKG8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRPYmplY3Qobyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzT2JqZWN0KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fciA9PSBMdWFfMS5MdWEuTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlcih0aGlzLl9kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0T2JqZWN0KG8pIHtcclxuICAgICAgICAgICAgLy9fdGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy9pZiAoIUx1YS5EKVxyXG4gICAgICAgICAgICAvL3tcclxuICAgICAgICAgICAgLy9cdGlmIChvID09IG51bGwpXHJcbiAgICAgICAgICAgIC8vXHR7XHJcbiAgICAgICAgICAgIC8vXHRcdHRyYWNlKFwic2V0T2JqZWN0OlwiLCBvLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAvL1x0fVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgdGhpcy5fciA9IG87XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG8pID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yID0gTHVhXzEuTHVhLk5VTUJFUjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2QgPSBvO1xyXG4gICAgICAgICAgICAgICAgLy90ZXN0RCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgKF9kID09IDE1MDA0OClcclxuICAgICAgICAgICAgLy97XHJcbiAgICAgICAgICAgIC8vXHR0cmFjZShcInNldE9iamVjdCAxNTAwNDg6XCIsIG8udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIHNldCByKHIpIHtcclxuICAgICAgICAgICAgdGhpcy5fciA9IHI7XHJcbiAgICAgICAgICAgIC8vaWYgKHIgPT0gbnVsbClcclxuICAgICAgICAgICAgLy97XHJcbiAgICAgICAgICAgIC8vXHRpZiAoTHVhLkQpXHJcbiAgICAgICAgICAgIC8vXHR7XHJcbiAgICAgICAgICAgIC8vXHRcdC8vRklYTUU65aaC5p6c5Li656m65YC855qE6K+d5oql6ZSZ77yM5Y+v5Lul55So5LqO5Y+R546w6Zeu6aKYKGluZGV4IG5vIHZhbHVl6ZSZ6K+v77yJXHJcbiAgICAgICAgICAgIC8vXHRcdHRyYWNlKFwiU2xvdCBzZXQgciA6IFwiLCByLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAvL1x0fVxyXG4gICAgICAgICAgICAvL31cdFxyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCByKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mlrDlop5cclxuICAgICAgICBzZXQgZChkKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKHRoaXMudGFnVXBWYWwgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgLy97XHJcbiAgICAgICAgICAgIC8vXHR0cmFjZShcIj09PT09PXRoaXMudGFnVXBWYWwgPT0gdHJ1ZSwgc2V0IGQgZnJvbSBcIiArIHRoaXMuX2QgKyBcIj0+XCIgKyBkKTtcclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIHRoaXMuX2QgPSBkO1xyXG4gICAgICAgICAgICAvL3Rlc3REKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5paw5aKeXHJcbiAgICAgICAgZ2V0IGQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+iwg+ivleeUqFxyXG4gICAgICAgIHRlc3REX18oKSB7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kID09IDE1MDA0OClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoXCJzZXRPYmplY3QgMTUwMDQ4Onh4eCByPT1cIiArIHRoaXMuX3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vaWYgKGlzTmFOKHRoaXMuX2QpKVxyXG4gICAgICAgICAgICAvL3tcclxuICAgICAgICAgICAgLy9cdHRyYWNlKFwic2V0T2JqZWN0IDE1MDA0ODp4eHh4eFwiKTtcclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIC8vaWYgKHRoaXMudGFnVXBWYWwgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgLy97XHJcbiAgICAgICAgICAgIC8vXHR0cmFjZShcIj09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgLy9pZiAodGhpcy50YWdVcFZhbCA9PSB0cnVlKVxyXG4gICAgICAgICAgICAvL3tcclxuICAgICAgICAgICAgLy9cdHRyYWNlKFwiPT09PT09dGhpcy50YWdVcFZhbCA9PSB0cnVlLCA9PlwiICsgdGhpcy5fZCk7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuU2xvdCA9IFNsb3Q7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TbG90LmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi4vamF2YS9TdHJpbmdCdWZmZXJcIiwgXCIuLi9qYXZhL0J5dGVBcnJheU91dHB1dFN0cmVhbVwiLCBcIi4vTHVhSmF2YUNhbGxiYWNrXCIsIFwiLi9Gb3JtYXRJdGVtXCIsIFwiLi9MdWFcIiwgXCIuL0x1YVRhYmxlXCIsIFwiLi9NYXRjaFN0YXRlXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5TdHJpbmdMaWIgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBTdHJpbmdCdWZmZXJfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL1N0cmluZ0J1ZmZlclwiKTtcclxuICAgIGNvbnN0IEJ5dGVBcnJheU91dHB1dFN0cmVhbV8xID0gcmVxdWlyZShcIi4uL2phdmEvQnl0ZUFycmF5T3V0cHV0U3RyZWFtXCIpO1xyXG4gICAgY29uc3QgTHVhSmF2YUNhbGxiYWNrXzEgPSByZXF1aXJlKFwiLi9MdWFKYXZhQ2FsbGJhY2tcIik7XHJcbiAgICBjb25zdCBGb3JtYXRJdGVtXzEgPSByZXF1aXJlKFwiLi9Gb3JtYXRJdGVtXCIpO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICBjb25zdCBMdWFUYWJsZV8xID0gcmVxdWlyZShcIi4vTHVhVGFibGVcIik7XHJcbiAgICBjb25zdCBNYXRjaFN0YXRlXzEgPSByZXF1aXJlKFwiLi9NYXRjaFN0YXRlXCIpO1xyXG4gICAgLyogICRIZWFkZXI6IC8vaW5mby5yYXZlbmJyb29rLmNvbS9wcm9qZWN0L2ppbGkvdmVyc2lvbi8xLjEvY29kZS9tbmovbHVhL1N0cmluZ0xpYi5qYXZhIzEgJFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA2IE5va2lhIENvcnBvcmF0aW9uIGFuZC9vciBpdHMgc3Vic2lkaWFyeSgtaWVzKS5cclxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICAgICAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICAgICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAgICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3RcclxuICAgICAqIHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gICAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAgICAgKlxyXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gICAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICAgICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUlxyXG4gICAgICogQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0ZcclxuICAgICAqIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gICAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuICAgIC8vc2VlIGppbGxjb2RlKEphdmEgSW1wbGVtZW50YXRpb24gb2YgTHVhIExhbmd1YWdlLCBKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHJcbiAgICAvL+i/memHjOeahOS7o+eggeenu+akjeiHqmppbGxjb2RlKEx1YeeahEphdmHlrp7njrDvvIxKaWxsKTpcclxuICAgIC8vXHRodHRwOi8vY29kZS5nb29nbGUuY29tL3AvamlsbGNvZGUvXHRcclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbnMgTHVhJ3Mgc3RyaW5nIGxpYnJhcnkuXHJcbiAgICAgKiBUaGUgbGlicmFyeSBjYW4gYmUgb3BlbmVkIHVzaW5nIHRoZSB7QGxpbmsgI29wZW59IG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgU3RyaW5nTGliIGV4dGVuZHMgTHVhSmF2YUNhbGxiYWNrXzEuTHVhSmF2YUNhbGxiYWNrIHtcclxuICAgICAgICAvKiogQ29uc3RydWN0cyBpbnN0YW5jZSwgZmlsbGluZyBpbiB0aGUgJ3doaWNoJyBtZW1iZXIuICovXHJcbiAgICAgICAgY29uc3RydWN0b3Iod2hpY2gpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fd2hpY2ggPSB3aGljaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRqdXN0cyB0aGUgb3V0cHV0IG9mIHN0cmluZy5mb3JtYXQgc28gdGhhdCAlZSBhbmQgJWcgdXNlICdlJ1xyXG4gICAgICAgICAqIGluc3RlYWQgb2YgJ0UnIHRvIGluZGljYXRlIHRoZSBleHBvbmVudC4gIEluIG90aGVyIHdvcmRzIHNvIHRoYXRcclxuICAgICAgICAgKiBzdHJpbmcuZm9ybWF0IGZvbGxvd3MgdGhlIElTTyBDIChJU08gOTg5OSkgc3RhbmRhcmQgZm9yIHByaW50Zi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3JtYXRJU08oKSB7XHJcbiAgICAgICAgICAgIEZvcm1hdEl0ZW1fMS5Gb3JtYXRJdGVtLkVfTE9XRVIgPSAnZScuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW1wbGVtZW50cyBhbGwgb2YgdGhlIGZ1bmN0aW9ucyBpbiB0aGUgTHVhIHN0cmluZyBsaWJyYXJ5LiAgRG8gbm90XHJcbiAgICAgICAgICogY2FsbCBkaXJlY3RseS5cclxuICAgICAgICAgKiBAcGFyYW0gTCAgdGhlIEx1YSBzdGF0ZSBpbiB3aGljaCB0byBleGVjdXRlLlxyXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIHJldHVybmVkIHBhcmFtZXRlcnMsIGFzIHBlciBjb252ZW50aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx1YUZ1bmN0aW9uKEwpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl93aGljaCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdMaWIuQllURTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nTGliLmJ5dGVGdW5jdGlvbihMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nTGliLkNIQVI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi5jaGFyRnVuY3Rpb24oTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ0xpYi5EVU1QOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdMaWIuZHVtcChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nTGliLkZJTkQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi5maW5kKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdMaWIuRk9STUFUOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdMaWIuZm9ybWF0KEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdMaWIuR01BVENIOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdMaWIuZ21hdGNoKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdMaWIuR1NVQjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nTGliLmdzdWIoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ0xpYi5MRU46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi5sZW4oTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ0xpYi5MT1dFUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nTGliLmxvd2VyKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdMaWIuTUFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi5tYXRjaChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nTGliLlJFUDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nTGliLnJlcChMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nTGliLlJFVkVSU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi5yZXZlcnNlKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdMaWIuU1VCOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdMaWIuc3ViKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdMaWIuVVBQRVI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi51cHBlcihMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nTGliLkdNQVRDSF9BVVg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi5nbWF0Y2hhdXgoTCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9wZW5zIHRoZSBzdHJpbmcgbGlicmFyeSBpbnRvIHRoZSBnaXZlbiBMdWEgc3RhdGUuICBUaGlzIHJlZ2lzdGVyc1xyXG4gICAgICAgICAqIHRoZSBzeW1ib2xzIG9mIHRoZSBzdHJpbmcgbGlicmFyeSBpbiBhIG5ld2x5IGNyZWF0ZWQgdGFibGUgY2FsbGVkXHJcbiAgICAgICAgICogXCJzdHJpbmdcIi5cclxuICAgICAgICAgKiBAcGFyYW0gTCAgVGhlIEx1YSBzdGF0ZSBpbnRvIHdoaWNoIHRvIG9wZW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIG9wZW4oTCkge1xyXG4gICAgICAgICAgICB2YXIgbGliID0gTC5fX3JlZ2lzdGVyKFwic3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBTdHJpbmdMaWIucihMLCBcImJ5dGVcIiwgU3RyaW5nTGliLkJZVEUpO1xyXG4gICAgICAgICAgICBTdHJpbmdMaWIucihMLCBcImNoYXJcIiwgU3RyaW5nTGliLkNIQVIpO1xyXG4gICAgICAgICAgICBTdHJpbmdMaWIucihMLCBcImR1bXBcIiwgU3RyaW5nTGliLkRVTVApO1xyXG4gICAgICAgICAgICBTdHJpbmdMaWIucihMLCBcImZpbmRcIiwgU3RyaW5nTGliLkZJTkQpO1xyXG4gICAgICAgICAgICBTdHJpbmdMaWIucihMLCBcImZvcm1hdFwiLCBTdHJpbmdMaWIuRk9STUFUKTtcclxuICAgICAgICAgICAgU3RyaW5nTGliLnIoTCwgXCJnZmluZFwiLCBTdHJpbmdMaWIuR0ZJTkQpO1xyXG4gICAgICAgICAgICBTdHJpbmdMaWIucihMLCBcImdtYXRjaFwiLCBTdHJpbmdMaWIuR01BVENIKTtcclxuICAgICAgICAgICAgU3RyaW5nTGliLnIoTCwgXCJnc3ViXCIsIFN0cmluZ0xpYi5HU1VCKTtcclxuICAgICAgICAgICAgU3RyaW5nTGliLnIoTCwgXCJsZW5cIiwgU3RyaW5nTGliLkxFTik7XHJcbiAgICAgICAgICAgIFN0cmluZ0xpYi5yKEwsIFwibG93ZXJcIiwgU3RyaW5nTGliLkxPV0VSKTtcclxuICAgICAgICAgICAgU3RyaW5nTGliLnIoTCwgXCJtYXRjaFwiLCBTdHJpbmdMaWIuTUFUQ0gpO1xyXG4gICAgICAgICAgICBTdHJpbmdMaWIucihMLCBcInJlcFwiLCBTdHJpbmdMaWIuUkVQKTtcclxuICAgICAgICAgICAgU3RyaW5nTGliLnIoTCwgXCJyZXZlcnNlXCIsIFN0cmluZ0xpYi5SRVZFUlNFKTtcclxuICAgICAgICAgICAgU3RyaW5nTGliLnIoTCwgXCJzdWJcIiwgU3RyaW5nTGliLlNVQik7XHJcbiAgICAgICAgICAgIFN0cmluZ0xpYi5yKEwsIFwidXBwZXJcIiwgU3RyaW5nTGliLlVQUEVSKTtcclxuICAgICAgICAgICAgdmFyIG10ID0gbmV3IEx1YVRhYmxlXzEuTHVhVGFibGUoKTtcclxuICAgICAgICAgICAgTC5zZXRNZXRhdGFibGUoXCJcIiwgbXQpOyAvLyBzZXQgc3RyaW5nIG1ldGF0YWJsZVxyXG4gICAgICAgICAgICBMLnNldEZpZWxkKG10LCBcIl9faW5kZXhcIiwgbGliKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFJlZ2lzdGVyIGEgZnVuY3Rpb24uICovXHJcbiAgICAgICAgc3RhdGljIHIoTCwgbmFtZSwgd2hpY2gpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgU3RyaW5nTGliKHdoaWNoKTtcclxuICAgICAgICAgICAgdmFyIGxpYiA9IEwuZ2V0R2xvYmFsKFwic3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBMLnNldEZpZWxkKGxpYiwgbmFtZSwgZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHN0cmluZy5ieXRlLiAgTmFtZSBtYW5nbGVkIHRvIGF2b2lkIGtleXdvcmQuICovXHJcbiAgICAgICAgc3RhdGljIGJ5dGVGdW5jdGlvbihMKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgdmFyIHBvc2kgPSBTdHJpbmdMaWIucG9zcmVsYXQoTC5vcHRJbnQoMiwgMSksIHMpO1xyXG4gICAgICAgICAgICB2YXIgcG9zZSA9IFN0cmluZ0xpYi5wb3NyZWxhdChMLm9wdEludCgzLCBwb3NpKSwgcyk7XHJcbiAgICAgICAgICAgIGlmIChwb3NpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHBvc2kgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb3NlID4gcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHBvc2UgPSBzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9zaSA+IHBvc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBlbXB0eSBpbnRlcnZhbDsgcmV0dXJuIG5vIHZhbHVlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuID0gcG9zZSAtIHBvc2kgKyAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoTnVtYmVyKHMuY2hhckNvZGVBdChwb3NpICsgaSAtIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgc3RyaW5nLmNoYXIuICBOYW1lIG1hbmdsZWQgdG8gYXZvaWQga2V5d29yZC4gKi9cclxuICAgICAgICBzdGF0aWMgY2hhckZ1bmN0aW9uKEwpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBMLmdldFRvcCgpOyAvLyBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICAgIHZhciBiID0gbmV3IFN0cmluZ0J1ZmZlcl8xLlN0cmluZ0J1ZmZlcigpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gTC5jaGVja0ludChpKTtcclxuICAgICAgICAgICAgICAgIEwuYXJnQ2hlY2soYyA9PSBjLCBpLCBcImludmFsaWQgdmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICBiLmFwcGVuZChjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLnB1c2hTdHJpbmcoYi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHN0cmluZy5kdW1wLiAqL1xyXG4gICAgICAgIHN0YXRpYyBkdW1wKEwpIHtcclxuICAgICAgICAgICAgTC5jaGVja1R5cGUoMSwgTHVhXzEuTHVhLlRGVU5DVElPTik7XHJcbiAgICAgICAgICAgIEwuc2V0VG9wKDEpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgQnl0ZUFycmF5T3V0cHV0U3RyZWFtXzEuQnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XHJcbiAgICAgICAgICAgICAgICBMdWFfMS5MdWEuZHVtcChMLnZhbHVlKDEpLCBzKTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gcy50b0J5dGVBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kKChhLmdldChpKSAmIDB4ZmYpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEwucHVzaFN0cmluZyhiLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZV8gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVfLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEwuZXJyb3IoXCJ1bmFiZSB0byBkdW1wIGdpdmVuIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5PVFJFQUNIRURcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBIZWxwZXIgZm9yIGZpbmQgYW5kIG1hdGNoLiAgRXF1aXZhbGVudCB0byBzdHJfZmluZF9hdXguICovXHJcbiAgICAgICAgc3RhdGljIGZpbmRBdXgoTCwgaXNGaW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgdmFyIHAgPSBMLmNoZWNrU3RyaW5nKDIpO1xyXG4gICAgICAgICAgICB2YXIgbDEgPSBzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGwyID0gcC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBpbml0ID0gU3RyaW5nTGliLnBvc3JlbGF0KEwub3B0SW50KDMsIDEpLCBzKSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChpbml0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5pdCA+IGwxKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0ID0gbDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRmluZCAmJiAoTC50b0Jvb2xlYW4oTC52YWx1ZSg0KSkgfHwgLy8gZXhwbGljaXQgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgU3RyaW5nTGliLnN0cnBicmsocCwgTWF0Y2hTdGF0ZV8xLk1hdGNoU3RhdGUuU1BFQ0lBTFMpIDwgMCkpIC8vIG9yIG5vIHNwZWNpYWwgY2hhcmFjdGVycz9cclxuICAgICAgICAgICAgIHsgLy8gZG8gYSBwbGFpbiBzZWFyY2hcclxuICAgICAgICAgICAgICAgIHZhciBvZmYgPSBTdHJpbmdMaWIubG1lbWZpbmQocy5zdWJzdHJpbmcoaW5pdCksIGwxIC0gaW5pdCwgcCwgbDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZiA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5wdXNoTnVtYmVyKGluaXQgKyBvZmYgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBMLnB1c2hOdW1iZXIoaW5pdCArIG9mZiArIGwyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtcyA9IG5ldyBNYXRjaFN0YXRlXzEuTWF0Y2hTdGF0ZShMLCBzLCBsMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gcC5jaGFyQXQoMCkgPT0gJ14nO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpID0gaW5pdDtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBtcy5sZXZlbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IG1zLm1hdGNoKHNpLCBwLCBhbmNob3IgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwucHVzaE51bWJlcihzaSArIDEpOyAvLyBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTC5wdXNoTnVtYmVyKHJlcyk7IC8vIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zLnB1c2hfY2FwdHVyZXMoLTEsIC0xKSArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXMucHVzaF9jYXB0dXJlcyhzaSwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzaSsrIDwgbXMuZW5kICYmICFhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucHVzaE5pbCgpOyAvLyBub3QgZm91bmRcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHN0cmluZy5maW5kLiAqL1xyXG4gICAgICAgIHN0YXRpYyBmaW5kKEwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0xpYi5maW5kQXV4KEwsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50IHN0cmluZy5tYXRjaC4gIE9wZXJhdGVzIHNsaWdodGx5IGRpZmZlcmVudGx5IGZyb20gdGhlXHJcbiAgICAgICAgICogUFVDLVJpbyBjb2RlIGJlY2F1c2UgaW5zdGVhZCBvZiBzdG9yaW5nIHRoZSBpdGVyYXRpb24gc3RhdGUgYXNcclxuICAgICAgICAgKiB1cHZhbHVlcyBvZiB0aGUgQyBjbG9zdXJlIHRoZSBpdGVyYXRpb24gc3RhdGUgaXMgc3RvcmVkIGluIGFuXHJcbiAgICAgICAgICogT2JqZWN0WzNdIGFuZCBrZXB0IG9uIHRoZSBzdGFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgZ21hdGNoKEwpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gbmV3IEFycmF5KDMpOyAvL09iamVjdFtdXHJcbiAgICAgICAgICAgIHN0YXRlWzBdID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgc3RhdGVbMV0gPSBMLmNoZWNrU3RyaW5nKDIpO1xyXG4gICAgICAgICAgICBzdGF0ZVsyXSA9IDA7XHJcbiAgICAgICAgICAgIEwucHVzaE9iamVjdChTdHJpbmdMaWIuR01BVENIX0FVWF9GVU4pO1xyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3Qoc3RhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXhwZWN0cyB0aGUgaXRlcmF0aW9uIHN0YXRlLCBhbiBPYmplY3RbM10gKHNlZSB7QGxpbmtcclxuICAgICAgICAgKiAjZ21hdGNofSksIHRvIGJlIGZpcnN0IG9uIHRoZSBzdGFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgZ21hdGNoYXV4KEwpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gTC52YWx1ZSgxKTsgLy9PYmplY3RbXSBcclxuICAgICAgICAgICAgdmFyIHMgPSBzdGF0ZVswXTtcclxuICAgICAgICAgICAgdmFyIHAgPSBzdGF0ZVsxXTtcclxuICAgICAgICAgICAgdmFyIGkgPSBzdGF0ZVsyXTtcclxuICAgICAgICAgICAgdmFyIG1zID0gbmV3IE1hdGNoU3RhdGVfMS5NYXRjaFN0YXRlKEwsIHMsIHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICg7IGkgPD0gbXMuZW5kOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG1zLmxldmVsID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gbXMubWF0Y2goaSwgcCwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld3N0YXJ0ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSA9PSBpKSAvLyBlbXB0eSBtYXRjaD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgKytuZXdzdGFydDsgLy8gZ28gYXQgbGVhc3Qgb25lIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVbMl0gPSBwYXJzZUludChuZXdzdGFydC50b0ZpeGVkKDApKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXMucHVzaF9jYXB0dXJlcyhpLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gbm90IGZvdW5kLlxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBzdHJpbmcuZ3N1Yi4gKi9cclxuICAgICAgICBzdGF0aWMgZ3N1YihMKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgdmFyIHNsID0gcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBwID0gTC5jaGVja1N0cmluZygyKTtcclxuICAgICAgICAgICAgdmFyIG1heG4gPSBMLm9wdEludCg0LCBzbCArIDEpO1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGFuY2hvciA9IHAuY2hhckF0KDApID09ICdeJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYW5jaG9yKVxyXG4gICAgICAgICAgICAgICAgcCA9IHAuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICB2YXIgbXMgPSBuZXcgTWF0Y2hTdGF0ZV8xLk1hdGNoU3RhdGUoTCwgcywgc2wpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgICAgICB2YXIgc2kgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAobiA8IG1heG4pIHtcclxuICAgICAgICAgICAgICAgIG1zLmxldmVsID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gbXMubWF0Y2goc2ksIHAsIDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBtcy5hZGR2YWx1ZShiLCBzaSwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZSA+PSAwICYmIGUgPiBzaSkgLy8gbm9uIGVtcHR5IG1hdGNoP1xyXG4gICAgICAgICAgICAgICAgICAgIHNpID0gZTsgLy8gc2tpcCBpdFxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2kgPCBtcy5lbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmQocy5jaGFyQ29kZUF0KHNpKyspKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcocy5zdWJzdHJpbmcoc2kpKTtcclxuICAgICAgICAgICAgTC5wdXNoU3RyaW5nKGIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihuKTsgLy8gbnVtYmVyIG9mIHN1YnN0aXR1dGlvbnNcclxuICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBhZGRxdW90ZWQoTCwgYiwgYXJnKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTC5jaGVja1N0cmluZyhhcmcpO1xyXG4gICAgICAgICAgICB2YXIgbCA9IHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBiLmFwcGVuZCgnXCInLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzLmNoYXJBdChpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1wiJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXFxcJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZCgnXFxcXCcuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kKHMuY2hhckNvZGVBdChpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKFwiXFxcXHJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcMCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKFwiXFxcXHUwMDAwXCIgLypcIlxcXFwwMDBcIiovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmQocy5jaGFyQ29kZUF0KGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYi5hcHBlbmQoJ1wiJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGZvcm1hdChMKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmcgPSAxO1xyXG4gICAgICAgICAgICB2YXIgc3RyZnJtdCA9IEwuY2hlY2tTdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIHZhciBzZmwgPSBzdHJmcm10Lmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGIgPSBuZXcgU3RyaW5nQnVmZmVyXzEuU3RyaW5nQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBzZmwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJmcm10LmNoYXJDb2RlQXQoaSkgIT0gTWF0Y2hTdGF0ZV8xLk1hdGNoU3RhdGUuTF9FU0MpIHtcclxuICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZChzdHJmcm10LmNoYXJDb2RlQXQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJmcm10LmNoYXJDb2RlQXQoKytpKSA9PSBNYXRjaFN0YXRlXzEuTWF0Y2hTdGF0ZS5MX0VTQykge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYXBwZW5kKHN0cmZybXQuY2hhckNvZGVBdChpKyspKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgLy8gZm9ybWF0IGl0ZW1cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgKythcmc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBuZXcgRm9ybWF0SXRlbV8xLkZvcm1hdEl0ZW0oTCwgc3RyZnJtdC5zdWJzdHJpbmcoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gaXRlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChTdHJpbmcuZnJvbUNoYXJDb2RlKGl0ZW0udHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmZvcm1hdENoYXIoYiwgTC5jaGVja051bWJlcihhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ28nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gOnRvZG86IHNob3VsZCBiZSB1bnNpZ25lZCBjb252ZXJzaW9ucyBjb3BlIGJldHRlciB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWdhdGl2ZSBudW1iZXI/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmZvcm1hdEludGVnZXIoYiwgTC5jaGVja051bWJlcihhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdnJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmZvcm1hdEZsb2F0KGIsIEwuY2hlY2tOdW1iZXIoYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdMaWIuYWRkcXVvdGVkKEwsIGIsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmZvcm1hdFN0cmluZyhiLCBMLmNoZWNrU3RyaW5nKGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTC5lcnJvcihcImludmFsaWQgb3B0aW9uIHRvICdmb3JtYXQnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMLnB1c2hTdHJpbmcoYi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHN0cmluZy5sZW4uICovXHJcbiAgICAgICAgc3RhdGljIGxlbihMKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHN0cmluZy5sb3dlci4gKi9cclxuICAgICAgICBzdGF0aWMgbG93ZXIoTCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IEwuY2hlY2tTdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIEwucHVzaFN0cmluZyhzLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgc3RyaW5nLm1hdGNoLiAqL1xyXG4gICAgICAgIHN0YXRpYyBtYXRjaChMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdMaWIuZmluZEF1eChMLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBJbXBsZW1lbnRzIHN0cmluZy5yZXAuICovXHJcbiAgICAgICAgc3RhdGljIHJlcChMKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTC5jaGVja1N0cmluZygxKTtcclxuICAgICAgICAgICAgdmFyIG4gPSBMLmNoZWNrSW50KDIpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucHVzaFN0cmluZyhiLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgc3RyaW5nLnJldmVyc2UuICovXHJcbiAgICAgICAgc3RhdGljIHJldmVyc2UoTCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IEwuY2hlY2tTdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIHZhciBiID0gbmV3IFN0cmluZ0J1ZmZlcl8xLlN0cmluZ0J1ZmZlcigpO1xyXG4gICAgICAgICAgICB2YXIgbCA9IHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoLS1sID49IDApIHtcclxuICAgICAgICAgICAgICAgIGIuYXBwZW5kKHMuY2hhckNvZGVBdChsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTC5wdXNoU3RyaW5nKGIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSGVscGVyIGZvciB7QGxpbmsgI3N1Yn0gYW5kIGZyaWVuZHMuICovXHJcbiAgICAgICAgc3RhdGljIHBvc3JlbGF0KHBvcywgcykge1xyXG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxlbiA9IHMubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gbGVuICsgcG9zICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgc3RyaW5nLnN1Yi4gKi9cclxuICAgICAgICBzdGF0aWMgc3ViKEwpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBMLmNoZWNrU3RyaW5nKDEpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTdHJpbmdMaWIucG9zcmVsYXQoTC5jaGVja0ludCgyKSwgcyk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBTdHJpbmdMaWIucG9zcmVsYXQoTC5vcHRJbnQoMywgLTEpLCBzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPiBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0IDw9IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoU3RyaW5nKHMuc3Vic3RyaW5nKHN0YXJ0IC0gMSwgZW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBMLnB1c2hMaXRlcmFsKFwiXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyBzdHJpbmcudXBwZXIuICovXHJcbiAgICAgICAgc3RhdGljIHVwcGVyKEwpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBMLmNoZWNrU3RyaW5nKDEpO1xyXG4gICAgICAgICAgICBMLnB1c2hTdHJpbmcocy50b1VwcGVyQ2FzZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gIGNoYXJhY3RlciBpbmRleCBvZiBzdGFydCBvZiBtYXRjaCAoLTEgaWYgbm8gbWF0Y2gpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBsbWVtZmluZChzMSwgbDEsIHMyLCBsMikge1xyXG4gICAgICAgICAgICBpZiAobDIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGVtcHR5IHN0cmluZ3MgYXJlIGV2ZXJ5d2hlcmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsMiA+IGwxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7IC8vIGF2b2lkcyBhIG5lZ2F0aXZlIGwxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHMxLmluZGV4T2YoczIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBKdXN0IGxpa2UgQydzIHN0cnBicmsuXHJcbiAgICAgICAgICogQHJldHVybiBhbiBpbmRleCBpbnRvIDx2YXI+czwvdmFyPiBvciAtMSBmb3Igbm8gbWF0Y2guXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIHN0cnBicmsocywgX3NldCkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IF9zZXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHMuaW5kZXhPZihfc2V0LmNoYXJBdChpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5TdHJpbmdMaWIgPSBTdHJpbmdMaWI7XHJcbiAgICAvLyBFYWNoIGZ1bmN0aW9uIGluIHRoZSBzdHJpbmcgbGlicmFyeSBjb3JyZXNwb25kcyB0byBhbiBpbnN0YW5jZSBvZlxyXG4gICAgLy8gdGhpcyBjbGFzcyB3aGljaCBpcyBhc3NvY2lhdGVkICh0aGUgJ3doaWNoJyBtZW1iZXIpIHdpdGggYW4gaW50ZWdlclxyXG4gICAgLy8gd2hpY2ggaXMgdW5pcXVlIHdpdGhpbiB0aGlzIGNsYXNzLiAgVGhleSBhcmUgdGFrZW4gZnJvbSB0aGUgZm9sbG93aW5nXHJcbiAgICAvLyBzZXQuXHJcbiAgICBTdHJpbmdMaWIuQllURSA9IDE7XHJcbiAgICBTdHJpbmdMaWIuQ0hBUiA9IDI7XHJcbiAgICBTdHJpbmdMaWIuRFVNUCA9IDM7XHJcbiAgICBTdHJpbmdMaWIuRklORCA9IDQ7XHJcbiAgICBTdHJpbmdMaWIuRk9STUFUID0gNTtcclxuICAgIFN0cmluZ0xpYi5HRklORCA9IDY7XHJcbiAgICBTdHJpbmdMaWIuR01BVENIID0gNztcclxuICAgIFN0cmluZ0xpYi5HU1VCID0gODtcclxuICAgIFN0cmluZ0xpYi5MRU4gPSA5O1xyXG4gICAgU3RyaW5nTGliLkxPV0VSID0gMTA7XHJcbiAgICBTdHJpbmdMaWIuTUFUQ0ggPSAxMTtcclxuICAgIFN0cmluZ0xpYi5SRVAgPSAxMjtcclxuICAgIFN0cmluZ0xpYi5SRVZFUlNFID0gMTM7XHJcbiAgICBTdHJpbmdMaWIuU1VCID0gMTQ7XHJcbiAgICBTdHJpbmdMaWIuVVBQRVIgPSAxNTtcclxuICAgIFN0cmluZ0xpYi5HTUFUQ0hfQVVYID0gMTY7XHJcbiAgICBTdHJpbmdMaWIuR01BVENIX0FVWF9GVU4gPSBuZXcgU3RyaW5nTGliKFN0cmluZ0xpYi5HTUFUQ0hfQVVYKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ0xpYi5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL2phdmEvUmVhZGVyXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5TdHJpbmdSZWFkZXIgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL1JlYWRlclwiKTtcclxuICAgIC8qICAkSGVhZGVyOiAvL2luZm8ucmF2ZW5icm9vay5jb20vcHJvamVjdC9qaWxpL3ZlcnNpb24vMS4xL2NvZGUvbW5qL2x1YS9TdHJpbmdSZWFkZXIuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKiogRXJzYXR6IHJlcGxhY2VtZW50IGZvciB7QGxpbmsgamF2YS5pby5TdHJpbmdSZWFkZXJ9IGZyb20gSlNFLiAqL1xyXG4gICAgY2xhc3MgU3RyaW5nUmVhZGVyIGV4dGVuZHMgUmVhZGVyXzEuUmVhZGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIC8qKiBJbmRleCBvZiB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uLiAgLTEgaWYgY2xvc2VkLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gMDsgLy8gPSAwXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRleCBvZiB0aGUgY3VycmVudCBtYXJrIChzZXQgd2l0aCB7QGxpbmsgI21hcmt9KS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX21hcmsgPSAwOyAvLyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3MgPSBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrKGxpbWl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmsgPSB0aGlzLl9jdXJyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrU3VwcG9ydGVkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdSZWFkZXIgcmVhZCBlcnJvclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudCA+PSB0aGlzLl9zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zLmNoYXJDb2RlQXQodGhpcy5fY3VycmVudCsrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZE11bHRpQnl0ZXMoY2J1Ziwgb2ZmLCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgPCAwIHx8IGxlbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50ID49IHRoaXMuX3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudCArIGxlbiA+IHRoaXMuX3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9zLmxlbmd0aCAtIHRoaXMuX2N1cnJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY2J1ZltvZmYgKyBpXSA9IHRoaXMuX3MuY2hhckNvZGVBdCh0aGlzLl9jdXJyZW50ICsgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCArPSBsZW47XHJcbiAgICAgICAgICAgIHJldHVybiBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0KCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbWFyaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLlN0cmluZ1JlYWRlciA9IFN0cmluZ1JlYWRlcjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ1JlYWRlci5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL2phdmEvQ2hhcmFjdGVyXCIsIFwiLi4vamF2YS9IYXNodGFibGVcIiwgXCIuLi9qYXZhL051bWJlckZvcm1hdEV4Y2VwdGlvblwiLCBcIi4uL2phdmEvU3RyaW5nQnVmZmVyXCIsIFwiLi9CbG9ja0NudFwiLCBcIi4vQ29uc0NvbnRyb2xcIiwgXCIuL0V4cGRlc2NcIiwgXCIuL0Z1bmNTdGF0ZVwiLCBcIi4vTEhTQXNzaWduXCIsIFwiLi9MdWFcIiwgXCIuL1Byb3RvXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5TeW50YXggPSB2b2lkIDA7XHJcbiAgICBjb25zdCBDaGFyYWN0ZXJfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL0NoYXJhY3RlclwiKTtcclxuICAgIGNvbnN0IEhhc2h0YWJsZV8xID0gcmVxdWlyZShcIi4uL2phdmEvSGFzaHRhYmxlXCIpO1xyXG4gICAgY29uc3QgTnVtYmVyRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vamF2YS9OdW1iZXJGb3JtYXRFeGNlcHRpb25cIik7XHJcbiAgICBjb25zdCBTdHJpbmdCdWZmZXJfMSA9IHJlcXVpcmUoXCIuLi9qYXZhL1N0cmluZ0J1ZmZlclwiKTtcclxuICAgIGNvbnN0IEJsb2NrQ250XzEgPSByZXF1aXJlKFwiLi9CbG9ja0NudFwiKTtcclxuICAgIGNvbnN0IENvbnNDb250cm9sXzEgPSByZXF1aXJlKFwiLi9Db25zQ29udHJvbFwiKTtcclxuICAgIGNvbnN0IEV4cGRlc2NfMSA9IHJlcXVpcmUoXCIuL0V4cGRlc2NcIik7XHJcbiAgICBjb25zdCBGdW5jU3RhdGVfMSA9IHJlcXVpcmUoXCIuL0Z1bmNTdGF0ZVwiKTtcclxuICAgIGNvbnN0IExIU0Fzc2lnbl8xID0gcmVxdWlyZShcIi4vTEhTQXNzaWduXCIpO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICBjb25zdCBQcm90b18xID0gcmVxdWlyZShcIi4vUHJvdG9cIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvU3ludGF4LmphdmEjMSAkXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDYgTm9raWEgQ29ycG9yYXRpb24gYW5kL29yIGl0cyBzdWJzaWRpYXJ5KC1pZXMpLlxyXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgICAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICAgICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAgICAgKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdFxyXG4gICAgICogdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgICAqXHJcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAgICAgKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXHJcbiAgICAgKiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxyXG4gICAgICogQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAgICAgKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICAgICAqL1xyXG4gICAgLy9zZWUgamlsbGNvZGUoSmF2YSBJbXBsZW1lbnRhdGlvbiBvZiBMdWEgTGFuZ3VhZ2UsIEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cclxuICAgIC8v6L+Z6YeM55qE5Luj56CB56e75qSN6IeqamlsbGNvZGUoTHVh55qESmF2YeWunueOsO+8jEppbGwpOlxyXG4gICAgLy9cdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qaWxsY29kZS9cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBTeW50YXggYW5hbHlzZXIuICBMZXhpbmcsIHBhcnNpbmcsIGNvZGUgZ2VuZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgU3ludGF4IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihMLCB6LCBzb3VyY2UpIHtcclxuICAgICAgICAgICAgLy8gRnJvbSBzdHJ1Y3QgTGV4U3RhdGVcclxuICAgICAgICAgICAgLyoqIGN1cnJlbnQgY2hhcmFjdGVyICovXHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xyXG4gICAgICAgICAgICAvKiogaW5wdXQgbGluZSBjb3VudGVyICovXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVudW1iZXIgPSAxO1xyXG4gICAgICAgICAgICAvKiogbGluZSBvZiBsYXN0IHRva2VuICdjb25zdW1lZCcgKi9cclxuICAgICAgICAgICAgdGhpcy5fbGFzdGxpbmUgPSAxO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgKiBUaGUgdG9rZW4gdmFsdWUuICBGb3IgXCJwdW5jdHVhdGlvblwiIHRva2VucyB0aGlzIGlzIHRoZSBBU0NJSSB2YWx1ZVxyXG4gICAgICAgICAgICAqIGZvciB0aGUgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW47IGZvciBvdGhlciB0b2tlbnMgYSBtZW1iZXIgb2YgdGhlXHJcbiAgICAgICAgICAgICogZW51bSAoYWxsIG9mIHdoaWNoIGFyZSA+IDI1NSkuXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gMDtcclxuICAgICAgICAgICAgLyoqIFNlbWFudGljIGluZm8gZm9yIHRva2VuOyBhIG51bWJlci4gKi9cclxuICAgICAgICAgICAgdGhpcy5fdG9rZW5SID0gMDtcclxuICAgICAgICAgICAgLyoqIFNlbWFudGljIGluZm8gZm9yIHRva2VuOyBhIHN0cmluZy4gKi9cclxuICAgICAgICAgICAgdGhpcy5fdG9rZW5TID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqIExvb2thaGVhZCB0b2tlbiB2YWx1ZS4gKi9cclxuICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkID0gU3ludGF4LlRLX0VPUztcclxuICAgICAgICAgICAgLyoqIFNlbWFudGljIGluZm8gZm9yIGxvb2thaGVhZDsgYSBudW1iZXIuICovXHJcbiAgICAgICAgICAgIHRoaXMuX2xvb2thaGVhZFIgPSAwO1xyXG4gICAgICAgICAgICAvKiogU2VtYW50aWMgaW5mbyBmb3IgbG9va2FoZWFkOyBhIHN0cmluZy4gKi9cclxuICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkUyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiBTZW1hbnRpYyBpbmZvIGZvciByZXR1cm4gdmFsdWUgZnJvbSB7QGxpbmsgI2xsZXh9OyBhIG51bWJlci4gKi9cclxuICAgICAgICAgICAgdGhpcy5fc2VtUiA9IDA7XHJcbiAgICAgICAgICAgIC8qKiBBcyB7QGxpbmsgI3NlbVJ9LCBmb3Igc3RyaW5nLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9zZW1TID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqIEZ1bmNTdGF0ZSBmb3IgY3VycmVudCAoaW5uZXJtb3N0KSBmdW5jdGlvbiBiZWluZyBwYXJzZWQuICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZzID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqIEJ1ZmZlciBmb3IgdG9rZW5zLiAqL1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmID0gbmV3IFN0cmluZ0J1ZmZlcl8xLlN0cmluZ0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAvKiogbG9jYWxlIGRlY2ltYWwgcG9pbnQuICovXHJcbiAgICAgICAgICAgIC8vVE9ETzrov5nkuKrlj5jph4/osozkvLzmsqHmnInkvb/nlKhcclxuICAgICAgICAgICAgdGhpcy5fZGVjcG9pbnQgPSAnLicuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgU3ludGF4LmluaXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fTCA9IEw7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSB6O1xyXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1RPRE865a6e546w6Z2Z5oCB5Yid5aeL5YyWXHJcbiAgICAgICAgc3RhdGljIGluaXQoKSB7XHJcbiAgICAgICAgICAgIGlmIChTeW50YXguX3Jlc2VydmVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIFN5bnRheC5fcmVzZXJ2ZWQgPSBuZXcgSGFzaHRhYmxlXzEuSGFzaHRhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFN5bnRheC5OVU1fUkVTRVJWRUQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzpcclxuICAgICAgICAgICAgICAgICAgICBTeW50YXguX3Jlc2VydmVkLnB1dChTeW50YXguX3Rva2Vuc1tpXSwgbmV3IE51bWJlcihTeW50YXguRklSU1RfUkVTRVJWRUQgKyBpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGxhc3RsaW5lKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFzdGxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZyb20gPGN0eXBlLmg+XHJcbiAgICAgICAgLy8gSW1wbGVtZW50YXRpb25zIG9mIGZ1bmN0aW9ucyBmcm9tIDxjdHlwZS5oPiBhcmUgb25seSBjb3JyZWN0IGNvcGllc1xyXG4gICAgICAgIC8vIHRvIHRoZSBleHRlbnQgdGhhdCBMdWEgcmVxdWlyZXMgdGhlbS5cclxuICAgICAgICAvLyBHZW5lcmFsbHkgdGhleSBoYXZlIGRlZmF1bHQgYWNjZXNzIHNvIHRoYXQgU3RyaW5nTGliIGNhbiBzZWUgdGhlbS5cclxuICAgICAgICAvLyBVbmxpa2UgQydzIHRoZXNlIHZlcnNpb24gYXJlIG5vdCBsb2NhbGUgZGVwZW5kZW50LCB0aGV5IHVzZSB0aGVcclxuICAgICAgICAvLyBJU08tTGF0aW4tMSBkZWZpbml0aW9ucyBmcm9tIENMREMgMS4xIENoYXJhY3RlciBjbGFzcy5cclxuICAgICAgICBzdGF0aWMgaXNhbG51bShjKSB7XHJcbiAgICAgICAgICAgIHZhciBjaCA9IGM7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNVcHBlckNhc2UoY2gpIHx8XHJcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMb3dlckNhc2UoY2gpIHx8XHJcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEaWdpdChjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBpc2FscGhhKGMpIHtcclxuICAgICAgICAgICAgdmFyIGNoID0gYztcclxuICAgICAgICAgICAgcmV0dXJuIENoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc1VwcGVyQ2FzZShjaCkgfHxcclxuICAgICAgICAgICAgICAgIENoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xvd2VyQ2FzZShjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBjaGFyICh3aGVuIGNvbnZlcnRlZCBmcm9tIHRoZSBpbnQpIGlzIGFcclxuICAgICAgICAgKiBjb250cm9sIGNoYXJhY3Rlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGF0aWMgaXNjbnRybChjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjIDwgMHgyMCB8fCBjID09IDB4N2Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBpc2RpZ2l0KGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RpZ2l0KGMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgaXNsb3dlcihjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMb3dlckNhc2UoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2hhcmFjdGVyIGlzIHB1bmN0dWF0aW9uIGlmIG5vdCBjbnRybCwgbm90IGFsbnVtLCBhbmQgbm90IHNwYWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBpc3B1bmN0KGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFTeW50YXguaXNhbG51bShjKSAmJiAhU3ludGF4LmlzY250cmwoYykgJiYgIVN5bnRheC5pc3NwYWNlKGMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgaXNzcGFjZShjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjID09ICcgJy5jaGFyQ29kZUF0KDApIHx8XHJcbiAgICAgICAgICAgICAgICBjID09ICdcXGYnLmNoYXJDb2RlQXQoMCkgfHxcclxuICAgICAgICAgICAgICAgIGMgPT0gJ1xcbicuY2hhckNvZGVBdCgwKSB8fFxyXG4gICAgICAgICAgICAgICAgYyA9PSAnXFxyJy5jaGFyQ29kZUF0KDApIHx8XHJcbiAgICAgICAgICAgICAgICBjID09ICdcXHQnLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBpc3VwcGVyKGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc1VwcGVyQ2FzZShjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGlzeGRpZ2l0KGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RpZ2l0KGMpIHx8XHJcbiAgICAgICAgICAgICAgICAoJ2EnLmNoYXJDb2RlQXQoMCkgPD0gYyAmJiBjIDw9ICdmJy5jaGFyQ29kZUF0KDApKSB8fFxyXG4gICAgICAgICAgICAgICAgKCdBJy5jaGFyQ29kZUF0KDApIDw9IGMgJiYgYyA8PSAnRicuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZyb20gbGxleC5jXHJcbiAgICAgICAgY2hlY2tfbmV4dChfc2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChfc2V0LmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl9jdXJyZW50KSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zYXZlX2FuZF9uZXh0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJySXNOZXdsaW5lKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudCA9PSAnXFxuJy5jaGFyQ29kZUF0KDApIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID09ICdcXHInLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluY2xpbmVudW1iZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLl9jdXJyZW50O1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IGN1cnJJc05ld2xpbmUoKVxyXG4gICAgICAgICAgICB0aGlzLm5leHQoKTsgLy8gc2tpcCAnXFxuJyBvciAnXFxyJ1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJySXNOZXdsaW5lKCkgJiYgdGhpcy5fY3VycmVudCAhPSBvbGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpOyAvLyBza2lwICdcXG5cXHInIG9yICdcXHJcXG4nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCsrdGhpcy5fbGluZW51bWJlciA8IDApIC8vIG92ZXJmbG93XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnhTeW50YXhlcnJvcihcImNodW5rIGhhcyB0b28gbWFueSBsaW5lc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBza2lwX3NlcCgpIHtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9jdXJyZW50O1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IHMgPT0gJ1snIHx8IHMgPT0gJ10nXHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZV9hbmRfbmV4dCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fY3VycmVudCA9PSAnPScuY2hhckNvZGVBdCgwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlX2FuZF9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fY3VycmVudCA9PSBzKSA/IGNvdW50IDogKC1jb3VudCkgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkX2xvbmdfc3RyaW5nKGlzU3RyaW5nLCBzZXApIHtcclxuICAgICAgICAgICAgdmFyIGNvbnQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnNhdmVfYW5kX25leHQoKTsgLyogc2tpcCAybmQgYFsnICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJJc05ld2xpbmUoKSkgLyogc3RyaW5nIHN0YXJ0cyB3aXRoIGEgbmV3bGluZT8gKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5jbGluZW51bWJlcigpOyAvKiBza2lwIGl0ICovXHJcbiAgICAgICAgICAgIGxvb3A6IHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5fY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LkVPWik6IC8vVE9ETzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54TGV4ZXJyb3IoaXNTdHJpbmcgPyBcInVuZmluaXNoZWQgbG9uZyBzdHJpbmdcIiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVuZmluaXNoZWQgbG9uZyBjb21tZW50XCIsIFN5bnRheC5US19FT1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLyogdG8gYXZvaWQgd2FybmluZ3MgKi9cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICddJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2tpcF9zZXAoKSA9PSBzZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZV9hbmRfbmV4dCgpOyAvKiBza2lwIDJuZCBgXScgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxuJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fc2F2ZSgnXFxuJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNsaW5lbnVtYmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmLnNldExlbmd0aCgwKTsgLyogYXZvaWQgd2FzdGluZyBzcGFjZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVfYW5kX25leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gLyogbG9vcCAqL1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciByYXd0b2tlbiA9IHRoaXMuX2J1ZmYudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmltX2J5ID0gMiArIHNlcDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbVMgPSByYXd0b2tlbi5zdWJzdHJpbmcodHJpbV9ieSwgcmF3dG9rZW4ubGVuZ3RoIC0gdHJpbV9ieSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIExleCBhIHRva2VuIGFuZCByZXR1cm4gaXQuICBUaGUgc2VtYW50aWMgaW5mbyBmb3IgdGhlIHRva2VuIGlzXHJcbiAgICAgICAgICogc3RvcmVkIGluIDxjb2RlPnRoaXMuc2VtUjwvY29kZT4gb3IgPGNvZGU+dGhpcy5zZW1TPC9jb2RlPiBhc1xyXG4gICAgICAgICAqIGFwcHJvcHJpYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxsZXgoKSB7XHJcbiAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJsbGV4KCkgZW50ZXIsIGN1cnJlbnQ6XCIgKyB0aGlzLl9jdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9idWZmLnNldExlbmd0aCgwKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl9jdXJyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhc2UgXFxcXG5cXFxcclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2xpbmVudW1iZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYXNlIC1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50ICE9ICctJy5jaGFyQ29kZUF0KDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICctJy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlbHNlIGlzIGEgY29tbWVudCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgPT0gJ1snLmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXAyID0gdGhpcy5za2lwX3NlcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZi5zZXRMZW5ndGgoMCk7IC8qIGBza2lwX3NlcCcgbWF5IGRpcnR5IHRoZSBidWZmZXIgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXAyID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRfbG9uZ19zdHJpbmcoZmFsc2UsIHNlcDIpOyAvKiBsb25nIGNvbW1lbnQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmLnNldExlbmd0aCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlbHNlIHNob3J0IGNvbW1lbnQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmN1cnJJc05ld2xpbmUoKSAmJiB0aGlzLl9jdXJyZW50ICE9IFN5bnRheC5FT1opXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYXNlIFtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcCA9IHRoaXMuc2tpcF9zZXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRfbG9uZ19zdHJpbmcodHJ1ZSwgc2VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguVEtfU1RSSU5HO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlcCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnWycuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54TGV4ZXJyb3IoXCJpbnZhbGlkIGxvbmcgc3RyaW5nIGRlbGltaXRlclwiLCBTeW50YXguVEtfU1RSSU5HKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGF2b2lkcyBDaGVja3N0eWxlIHdhcm5pbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYXNlID1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50ICE9ICc9Jy5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJz0nLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguVEtfRVE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhc2UgPFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgIT0gJz0nLmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPCcuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5US19MRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTHVhXzEuTHVhLkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FzZSA+XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudCAhPSAnPScuY2hhckNvZGVBdCgwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc+Jy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4LlRLX0dFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYXNlIH5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50ICE9ICc9Jy5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ34nLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguVEtfTkU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcIic6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFwnJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhc2UgXFxcIidcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkX3N0cmluZyh0aGlzLl9jdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5US19TVFJJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYXNlIC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlX2FuZF9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrX25leHQoXCIuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja19uZXh0KFwiLlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguVEtfRE9UUztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguVEtfQ09OQ0FUO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFTeW50YXguaXNkaWdpdCh0aGlzLl9jdXJyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcuJy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkX251bWVyYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguVEtfTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmcuZnJvbUNoYXJDb2RlKFN5bnRheC5FT1opOiAvL1RPRE86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYXNlIEVPWlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4LlRLX0VPUztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3ludGF4Lmlzc3BhY2UodGhpcy5fY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaXNzcGFjZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2VydCAhY3VycklzTmV3bGluZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTeW50YXguaXNkaWdpdCh0aGlzLl9jdXJyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEx1YV8xLkx1YS5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpc2RpZ2l0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkX251bWVyYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguVEtfTlVNQkVSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFN5bnRheC5pc2FscGhhKHRoaXMuX2N1cnJlbnQpIHx8IHRoaXMuX2N1cnJlbnQgPT0gJ18nLmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMdWFfMS5MdWEuRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaXNhbHBoYSBvciBfXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWRlbnRpZmllciBvciByZXNlcnZlZCB3b3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlX2FuZF9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChTeW50YXguaXNhbG51bSh0aGlzLl9jdXJyZW50KSB8fCB0aGlzLl9jdXJyZW50ID09ICdfJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5fYnVmZi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBTeW50YXguX3Jlc2VydmVkLl9nZXQocyk7IC8vVE9ETzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW1TID0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4LlRLX05BTUU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5fY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7IC8vIHNpbmdsZS1jaGFyIHRva2Vuc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy91bnJlYWNoYWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX3oucmVhZCgpO1xyXG4gICAgICAgICAgICBpZiAoTHVhXzEuTHVhLkQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3ludGF4Lm5leHQoKSwgY3VycmVudDpcIiArIHRoaXMuX2N1cnJlbnQgKyBcIihcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5fY3VycmVudCkgKyBcIilcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFJlYWRzIG51bWJlci4gIFdyaXRlcyB0byBzZW1SLiAqL1xyXG4gICAgICAgIHJlYWRfbnVtZXJhbCgpIHtcclxuICAgICAgICAgICAgLy8gYXNzZXJ0IGlzZGlnaXQoY3VycmVudCk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZV9hbmRfbmV4dCgpO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChTeW50YXguaXNkaWdpdCh0aGlzLl9jdXJyZW50KSB8fCB0aGlzLl9jdXJyZW50ID09ICcuJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tfbmV4dChcIkVlXCIpKSAvLyAnRScgP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja19uZXh0KFwiKy1cIik7IC8vIG9wdGlvbmFsIGV4cG9uZW50IHNpZ25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoU3ludGF4LmlzYWxudW0odGhpcy5fY3VycmVudCkgfHwgdGhpcy5fY3VycmVudCA9PSAnXycuY2hhckNvZGVBdCgwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlX2FuZF9uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gOnRvZG86IGNvbnNpZGVyIGRvaW5nIFBVQy1SaW8ncyBkZWNpbWFsIHBvaW50IHRyaWNrcy5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbVIgPSBOdW1iZXIodGhpcy5fYnVmZi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb25fMS5OdW1iZXJGb3JtYXRFeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMueExleGVycm9yKFwibWFsZm9ybWVkIG51bWJlclwiLCBTeW50YXguVEtfTlVNQkVSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogUmVhZHMgc3RyaW5nLiAgV3JpdGVzIHRvIHNlbVMuICovXHJcbiAgICAgICAgcmVhZF9zdHJpbmcoZGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZV9hbmRfbmV4dCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fY3VycmVudCAhPSBkZWwpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl9jdXJyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nLmZyb21DaGFyQ29kZShTeW50YXguRU9aKTogLy9UT0RPOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnhMZXhlcnJvcihcInVuZmluaXNoZWQgc3RyaW5nXCIsIFN5bnRheC5US19FT1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gYXZvaWQgY29tcGlsZXIgd2FybmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54TGV4ZXJyb3IoXCJ1bmZpbmlzaGVkIHN0cmluZ1wiLCBTeW50YXguVEtfU1RSSU5HKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGF2b2lkIGNvbXBpbGVyIHdhcm5pbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXFxcJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTsgLy8gZG8gbm90IHNhdmUgdGhlICdcXCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl9jdXJyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gNztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIG5vICdcXGEnIGluIEphdmEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnXFxiJy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdcXGYnLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gJ1xcbicuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnXFxyJy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdcXHQnLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gMTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBubyAnXFx2JyBpbiBKYXZhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3NhdmUoJ1xcbicuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jbGluZW51bWJlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LkVPWik6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyB3aWxsIHJhaXNlIGFuIGVycm9yIG5leHQgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghU3ludGF4LmlzZGlnaXQodGhpcy5fY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZV9hbmRfbmV4dCgpOyAvLyBoYW5kbGVzIFxcXFwsIFxcXCIsIFxcJywgXFw/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyBcXHh4eFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IDEwICogYyArICh0aGlzLl9jdXJyZW50IC0gJzAnLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKytpIDwgMyAmJiBTeW50YXguaXNkaWdpdCh0aGlzLl9jdXJyZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB1bmljb2RlLCB0aGVyZSBhcmUgbm8gYm91bmRzIG9uIGEgMy1kaWdpdCBkZWNpbWFsLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3NhdmUoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fc2F2ZShjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVfYW5kX25leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNhdmVfYW5kX25leHQoKTsgLy8gc2tpcCBkZWxpbWl0ZXJcclxuICAgICAgICAgICAgdmFyIHJhd3Rva2VuID0gdGhpcy5fYnVmZi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZW1TID0gcmF3dG9rZW4uc3Vic3RyaW5nKDEsIHJhd3Rva2VuLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzYXZlKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmLmFwcGVuZCh0aGlzLl9jdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX19zYXZlKGMpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZi5hcHBlbmQoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNhdmVfYW5kX25leHQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEdldHRlciBmb3Igc291cmNlLiAqL1xyXG4gICAgICAgIGdldCBzb3VyY2UoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR4dFRva2VuKHRvaykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRvaykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfTkFNRTpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlRLX1NUUklORzpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlRLX05VTUJFUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4LnhUb2tlbjJzdHIodG9rKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogRXF1aXZhbGVudCB0byA8Y29kZT5sdWFYX2xleGVycm9yPC9jb2RlPi4gKi9cclxuICAgICAgICB4TGV4ZXJyb3IobXNnLCB0b2spIHtcclxuICAgICAgICAgICAgbXNnID0gdGhpcy5zb3VyY2UgKyBcIjpcIiArIHRoaXMuX2xpbmVudW1iZXIgKyBcIjogXCIgKyBtc2c7XHJcbiAgICAgICAgICAgIGlmICh0b2sgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbXNnID0gbXNnICsgXCIgbmVhciAnXCIgKyB0aGlzLnR4dFRva2VuKHRvaykgKyBcIidcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9MLnB1c2hTdHJpbmcobXNnKTtcclxuICAgICAgICAgICAgdGhpcy5fTC5kVGhyb3coTHVhXzEuTHVhLkVSUlNZTlRBWCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIDxjb2RlPmx1YVhfbmV4dDwvY29kZT4uICovXHJcbiAgICAgICAgeE5leHQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RsaW5lID0gdGhpcy5fbGluZW51bWJlcjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCAhPSBTeW50YXguVEtfRU9TKSAvLyBpcyB0aGVyZSBhIGxvb2stYWhlYWQgdG9rZW4/XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlbiA9IHRoaXMuX2xvb2thaGVhZDsgLy8gVXNlIHRoaXMgb25lLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5SID0gdGhpcy5fbG9va2FoZWFkUjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuUyA9IHRoaXMuX2xvb2thaGVhZFM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rYWhlYWQgPSBTeW50YXguVEtfRU9TOyAvLyBhbmQgZGlzY2hhcmdlIGl0LlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSB0aGlzLmxsZXgoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuUiA9IHRoaXMuX3NlbVI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlblMgPSB0aGlzLl9zZW1TO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIDxjb2RlPmx1YVhfc3ludGF4ZXJyb3I8L2NvZGU+LiAqL1xyXG4gICAgICAgIHhTeW50YXhlcnJvcihtc2cpIHtcclxuICAgICAgICAgICAgdGhpcy54TGV4ZXJyb3IobXNnLCB0aGlzLl90b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyB4VG9rZW4yc3RyKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA8IFN5bnRheC5GSVJTVF9SRVNFUlZFRCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHRva2VuID09IChjaGFyKXRva2VuO1xyXG4gICAgICAgICAgICAgICAgaWYgKFN5bnRheC5pc2NudHJsKHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNoYXIoXCIgKyB0b2tlbiArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTeW50YXguX3Rva2Vuc1t0b2tlbiAtIFN5bnRheC5GSVJTVF9SRVNFUlZFRF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZyb20gbHBhcnNlci5jXHJcbiAgICAgICAgc3RhdGljIGJsb2NrX2ZvbGxvdyh0b2tlbikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19FTFNFOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfRUxTRUlGOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfRU5EOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfVU5USUw6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19FT1M6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVjayhjKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b2tlbiAhPSBjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yX2V4cGVjdGVkKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB3aGF0ICAgdGhlIHRva2VuIHRoYXQgaXMgaW50ZW5kZWQgdG8gZW5kIHRoZSBtYXRjaC5cclxuICAgICAgICAgKiBAcGFyYW0gd2hvICAgIHRoZSB0b2tlbiB0aGF0IGJlZ2lucyB0aGUgbWF0Y2guXHJcbiAgICAgICAgICogQHBhcmFtIHdoZXJlICB0aGUgbGluZSBudW1iZXIgb2YgPHZhcj53aGF0PC92YXI+LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNoZWNrX21hdGNoKHdoYXQsIHdobywgd2hlcmUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRlc3RuZXh0KHdoYXQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2hlcmUgPT0gdGhpcy5fbGluZW51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JfZXhwZWN0ZWQod2hhdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhTeW50YXhlcnJvcihcIidcIiArIFN5bnRheC54VG9rZW4yc3RyKHdoYXQpICsgXCInIGV4cGVjdGVkICh0byBjbG9zZSAnXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTeW50YXgueFRva2VuMnN0cih3aG8pICsgXCInIGF0IGxpbmUgXCIgKyB3aGVyZSArIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbG9zZV9mdW5jKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZXZhcnMoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtSZXQoMCwgMCk7IC8vIGZpbmFsIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5fZnMuY2xvc2UoKTtcclxuICAgICAgICAgICAgLy8gOnRvZG86IGNoZWNrIHRoaXMgaXMgYSB2YWxpZCBhc3NlcnRpb24gdG8gbWFrZVxyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IGZzICE9IGZzLnByZXZcclxuICAgICAgICAgICAgdGhpcy5fZnMgPSB0aGlzLl9mcy5wcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgb3Bjb2RlX25hbWUob3ApIHtcclxuICAgICAgICAgICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfTU9WRTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNT1ZFXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9MT0FESzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJMT0FES1wiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfTE9BREJPT0w6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTE9BREJPT0xcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0xPQUROSUw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTE9BRE5JTFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfR0VUVVBWQUw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR0VUVVBWQUxcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0dFVEdMT0JBTDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJHRVRHTE9CQUxcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0dFVFRBQkxFOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdFVFRBQkxFXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9TRVRHTE9CQUw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU0VUR0xPQkFMXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9TRVRVUFZBTDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTRVRVUFZBTFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfU0VUVEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU0VUVEFCTEVcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX05FV1RBQkxFOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5FV1RBQkxFXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9TRUxGOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlNFTEZcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0FERDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBRERcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX1NVQjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTVUJcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX01VTDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNVUxcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0RJVjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJESVZcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX01PRDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNT0RcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX1BPVzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJQT1dcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX1VOTTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVTk1cIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX05PVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOT1RcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0xFTjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJMRU5cIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0NPTkNBVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJDT05DQVRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0pNUDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJKTVBcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0VROlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVRXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9MVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJMVFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTEVcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX1RFU1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVEVTVFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfVEVTVFNFVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJURVNUU0VUXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9DQUxMOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkNBTExcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX1RBSUxDQUxMOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlRBSUxDQUxMXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9SRVRVUk46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUkVUVVJOXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEx1YV8xLkx1YS5PUF9GT1JMT09QOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkZPUkxPT1BcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0ZPUlBSRVA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRk9SUFJFUFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfVEZPUkxPT1A6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVEZPUkxPT1BcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX1NFVExJU1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU0VUTElTVFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfQ0xPU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ0xPU0VcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgTHVhXzEuTHVhLk9QX0NMT1NVUkU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ0xPU1VSRVwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMdWFfMS5MdWEuT1BfVkFSQVJHOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlZBUkFSR1wiO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI/P1wiICsgb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29kZXN0cmluZyhlLCBzKSB7XHJcbiAgICAgICAgICAgIGUuaW5pdChFeHBkZXNjXzEuRXhwZGVzYy5WSywgdGhpcy5fZnMua1N0cmluZ0socykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja25hbWUoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVzdHJpbmcoZSwgdGhpcy5zdHJfY2hlY2tuYW1lKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbnRlcmxldmVsKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9MLm5DY2FsbHMrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZXJyb3JfZXhwZWN0ZWQodG9rKSB7XHJcbiAgICAgICAgICAgIHRoaXMueFN5bnRheGVycm9yKFwiJ1wiICsgU3ludGF4LnhUb2tlbjJzdHIodG9rKSArIFwiJyBleHBlY3RlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVhdmVsZXZlbCgpIHtcclxuICAgICAgICAgICAgdGhpcy5fTC5uQ2NhbGxzLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBFcXVpdmFsZW50IHRvIGx1YVlfcGFyc2VyLiAqL1xyXG4gICAgICAgIHN0YXRpYyBwYXJzZXIoTCwgX2luLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBscyA9IG5ldyBTeW50YXgoTCwgX2luLCBuYW1lKTtcclxuICAgICAgICAgICAgdmFyIGZzID0gbmV3IEZ1bmNTdGF0ZV8xLkZ1bmNTdGF0ZShscyk7XHJcbiAgICAgICAgICAgIGxzLm9wZW5fZnVuYyhmcyk7XHJcbiAgICAgICAgICAgIGZzLmYuaXNWYXJhcmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBscy54TmV4dCgpO1xyXG4gICAgICAgICAgICBscy5jaHVuaygpO1xyXG4gICAgICAgICAgICBscy5jaGVjayhTeW50YXguVEtfRU9TKTtcclxuICAgICAgICAgICAgbHMuY2xvc2VfZnVuYygpO1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IGZzLnByZXYgPT0gbnVsbFxyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IGZzLmYubnVwcyA9PSAwXHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgbHMuZnMgPT0gbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gZnMuZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZldmFycyh0b2xldmVsKSB7XHJcbiAgICAgICAgICAgIC8vIDp0b2RvOiBjb25zaWRlciBtYWtpbmcgYSBtZXRob2QgaW4gRnVuY1N0YXRlLlxyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fZnMubmFjdHZhciA+IHRvbGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmdldGxvY3ZhcigtLXRoaXMuX2ZzLm5hY3R2YXIpLmVuZHBjID0gdGhpcy5fZnMucGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2luZ2xldmFyKF92YXIpIHtcclxuICAgICAgICAgICAgdmFyIHZhcm5hbWUgPSB0aGlzLnN0cl9jaGVja25hbWUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2luZ2xldmFyYXV4KHRoaXMuX2ZzLCB2YXJuYW1lLCBfdmFyLCB0cnVlKSA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WR0xPQkFMKSB7XHJcbiAgICAgICAgICAgICAgICBfdmFyLmluZm8gPSB0aGlzLl9mcy5rU3RyaW5nSyh2YXJuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzaW5nbGV2YXJhdXgoZiwgbiwgX3ZhciwgYmFzZSkge1xyXG4gICAgICAgICAgICBpZiAoZiA9PSBudWxsKSAvLyBubyBtb3JlIGxldmVscz9cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF92YXIuaW5pdChFeHBkZXNjXzEuRXhwZGVzYy5WR0xPQkFMLCBMdWFfMS5MdWEuTk9fUkVHKTsgLy8gZGVmYXVsdCBpcyBnbG9iYWwgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgIHJldHVybiBFeHBkZXNjXzEuRXhwZGVzYy5WR0xPQkFMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBmLnNlYXJjaHZhcihuKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBfdmFyLmluaXQoRXhwZGVzY18xLkV4cGRlc2MuVkxPQ0FMLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZi5tYXJrdXB2YWwodik7IC8vIGxvY2FsIHdpbGwgYmUgdXNlZCBhcyBhbiB1cHZhbFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwZGVzY18xLkV4cGRlc2MuVkxPQ0FMO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSAvLyBub3QgZm91bmQgYXQgY3VycmVudCBsZXZlbDsgdHJ5IHVwcGVyIG9uZVxyXG4gICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zaW5nbGV2YXJhdXgoZi5wcmV2LCBuLCBfdmFyLCBmYWxzZSkgPT0gRXhwZGVzY18xLkV4cGRlc2MuVkdMT0JBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwZGVzY18xLkV4cGRlc2MuVkdMT0JBTDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3Zhci51cHZhbCh0aGlzLmluZGV4dXB2YWx1ZShmLCBuLCBfdmFyKSk7IC8vIGVsc2Ugd2FzIExPQ0FMIG9yIFVQVkFMXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cGRlc2NfMS5FeHBkZXNjLlZVUFZBTDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdHJfY2hlY2tuYW1lKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrKFN5bnRheC5US19OQU1FKTtcclxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl90b2tlblM7XHJcbiAgICAgICAgICAgIHRoaXMueE5leHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlc3RuZXh0KGMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rva2VuID09IGMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueE5leHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR1JBTU1BUiBSVUxFU1xyXG4gICAgICAgIGNodW5rKCkge1xyXG4gICAgICAgICAgICAvLyBjaHVuayAtPiB7IHN0YXQgWyc7J10gfVxyXG4gICAgICAgICAgICB2YXIgaXNsYXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJsZXZlbCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAoIWlzbGFzdCAmJiAhU3ludGF4LmJsb2NrX2ZvbGxvdyh0aGlzLl90b2tlbikpIHtcclxuICAgICAgICAgICAgICAgIGlzbGFzdCA9IHRoaXMuc3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RuZXh0KCc7Jy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgICAgIC8vIyBhc3NlcnQgZnMuZi5tYXhzdGFja3NpemUgPj0gZnMuZnJlZXJlZyAmJiBmcy5mcmVlcmVnID49IGZzLm5hY3R2YXJcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmZyZWVyZWcgPSB0aGlzLl9mcy5uYWN0dmFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGVhdmVsZXZlbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdHJ1Y3Rvcl8odCkge1xyXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3RvciAtPiA/P1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuX2xpbmVudW1iZXI7XHJcbiAgICAgICAgICAgIHZhciBwYyA9IHRoaXMuX2ZzLmtDb2RlQUJDKEx1YV8xLkx1YS5PUF9ORVdUQUJMRSwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHZhciBjYyA9IG5ldyBDb25zQ29udHJvbF8xLkNvbnNDb250cm9sKHQpO1xyXG4gICAgICAgICAgICB0LmluaXQoRXhwZGVzY18xLkV4cGRlc2MuVlJFTE9DQUJMRSwgcGMpO1xyXG4gICAgICAgICAgICBjYy52LmluaXQoRXhwZGVzY18xLkV4cGRlc2MuVlZPSUQsIDApOyAvKiBubyB2YWx1ZSAoeWV0KSAqL1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rRXhwMm5leHRyZWcodCk7IC8qIGZpeCBpdCBhdCBzdGFjayB0b3AgKGZvciBnYykgKi9cclxuICAgICAgICAgICAgdGhpcy5jaGVja25leHQoJ3snLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAvLyMgYXNzZXJ0IGNjLnYuayA9PSBFeHBkZXNjLlZWT0lEIHx8IGNjLnRvc3RvcmUgPiAwXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9rZW4gPT0gJ30nLmNoYXJDb2RlQXQoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlbGlzdGZpZWxkKGNjKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl90b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX05BTUUpOiAvKiBtYXkgYmUgbGlzdGZpZWxkcyBvciByZWNmaWVsZHMgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54TG9va2FoZWFkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQgIT0gJz0nLmNoYXJDb2RlQXQoMCkpIC8qIGV4cHJlc3Npb24/ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RmaWVsZChjYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjZmllbGQoY2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzogLyogY29uc3RydWN0b3JfaXRlbSAtPiByZWNmaWVsZCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2ZpZWxkKGNjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogLyogY29uc3RydWN0b3JfcGFydCAtPiBsaXN0ZmllbGQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZmllbGQoY2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy50ZXN0bmV4dCgnLCcuY2hhckNvZGVBdCgwKSkgfHwgdGhpcy50ZXN0bmV4dCgnOycuY2hhckNvZGVBdCgwKSkpO1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrX21hdGNoKCd9Jy5jaGFyQ29kZUF0KDApLCAneycuY2hhckNvZGVBdCgwKSwgbGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdGxpc3RmaWVsZChjYyk7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gdGhpcy5fZnMuZi5jb2RlOyAvL2ludCBbXSBcclxuICAgICAgICAgICAgY29kZVtwY10gPSBMdWFfMS5MdWEuU0VUQVJHX0IoY29kZVtwY10sIFN5bnRheC5vSW50MmZiKGNjLm5hKSk7IC8qIHNldCBpbml0aWFsIGFycmF5IHNpemUgKi9cclxuICAgICAgICAgICAgY29kZVtwY10gPSBMdWFfMS5MdWEuU0VUQVJHX0MoY29kZVtwY10sIFN5bnRheC5vSW50MmZiKGNjLm5oKSk7IC8qIHNldCBpbml0aWFsIHRhYmxlIHNpemUgKi9cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIG9JbnQyZmIoeCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IDA7IC8qIGV4cG9uZW50ICovXHJcbiAgICAgICAgICAgIHdoaWxlICh4IDwgMCB8fCB4ID49IDE2KSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gKHggKyAxKSA+Pj4gMTtcclxuICAgICAgICAgICAgICAgIGUrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHggPCA4KSA/IHggOiAoKChlICsgMSkgPDwgMykgfCAoeCAtIDgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVjZmllbGQoY2MpIHtcclxuICAgICAgICAgICAgLyogcmVjZmllbGQgLT4gKE5BTUUgfCBgWydleHAxYF0nKSA9IGV4cDEgKi9cclxuICAgICAgICAgICAgdmFyIHJlZyA9IHRoaXMuX2ZzLmZyZWVyZWc7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBuZXcgRXhwZGVzY18xLkV4cGRlc2MoKTtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG5ldyBFeHBkZXNjXzEuRXhwZGVzYygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9rZW4gPT0gU3ludGF4LlRLX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHlDaGVja2xpbWl0KGZzLCBjYy5uaCwgTUFYX0lOVCwgXCJpdGVtcyBpbiBhIGNvbnN0cnVjdG9yXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja25hbWUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIC8qIHRva2VuID09ICdbJyAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy55aW5kZXgoa2V5KTtcclxuICAgICAgICAgICAgY2MubmgrKztcclxuICAgICAgICAgICAgdGhpcy5jaGVja25leHQoJz0nLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rRXhwMlJLKGtleSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwcih2YWwpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfU0VUVEFCTEUsIGNjLnQuaW5mbywgdGhpcy5fZnMua0V4cDJSSyhrZXkpLCB0aGlzLl9mcy5rRXhwMlJLKHZhbCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5mcmVlcmVnID0gcmVnOyAvKiBmcmVlIHJlZ2lzdGVycyAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0bGlzdGZpZWxkKGNjKSB7XHJcbiAgICAgICAgICAgIGlmIChjYy50b3N0b3JlID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChTeW50YXguaGFzbXVsdHJldChjYy52LmspKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rU2V0bXVsdHJldChjYy52KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtTZXRsaXN0KGNjLnQuaW5mbywgY2MubmEsIEx1YV8xLkx1YS5NVUxUUkVUKTtcclxuICAgICAgICAgICAgICAgIGNjLm5hLS07IC8qIGRvIG5vdCBjb3VudCBsYXN0IGV4cHJlc3Npb24gKHVua25vd24gbnVtYmVyIG9mIGVsZW1lbnRzKSAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNjLnYuayAhPSBFeHBkZXNjXzEuRXhwZGVzYy5WVk9JRClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rRXhwMm5leHRyZWcoY2Mudik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rU2V0bGlzdChjYy50LmluZm8sIGNjLm5hLCBjYy50b3N0b3JlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbG9zZWxpc3RmaWVsZChjYykge1xyXG4gICAgICAgICAgICBpZiAoY2Mudi5rID09IEV4cGRlc2NfMS5FeHBkZXNjLlZWT0lEKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvKiB0aGVyZSBpcyBubyBsaXN0IGl0ZW0gKi9cclxuICAgICAgICAgICAgdGhpcy5fZnMua0V4cDJuZXh0cmVnKGNjLnYpO1xyXG4gICAgICAgICAgICBjYy52LmsgPSBFeHBkZXNjXzEuRXhwZGVzYy5WVk9JRDtcclxuICAgICAgICAgICAgaWYgKGNjLnRvc3RvcmUgPT0gTHVhXzEuTHVhLkxGSUVMRFNfUEVSX0ZMVVNIKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rU2V0bGlzdChjYy50LmluZm8sIGNjLm5hLCBjYy50b3N0b3JlKTsgLyogZmx1c2ggKi9cclxuICAgICAgICAgICAgICAgIGNjLnRvc3RvcmUgPSAwOyAvKiBubyBtb3JlIGl0ZW1zIHBlbmRpbmcgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBleHByKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJleHByKHYsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHJldHVybiBudW1iZXIgb2YgZXhwcmVzc2lvbnMgaW4gZXhwcmVzc2lvbiBsaXN0LiAqL1xyXG4gICAgICAgIGV4cGxpc3QxKHYpIHtcclxuICAgICAgICAgICAgLy8gZXhwbGlzdDEgLT4gZXhwciB7ICcsJyBleHByIH1cclxuICAgICAgICAgICAgdmFyIG4gPSAxOyAvLyBhdCBsZWFzdCBvbmUgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICB0aGlzLmV4cHIodik7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRlc3RuZXh0KCcsJy5jaGFyQ29kZUF0KDApKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua0V4cDJuZXh0cmVnKHYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHByKHYpO1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHByc3RhdCgpIHtcclxuICAgICAgICAgICAgLy8gc3RhdCAtPiBmdW5jIHwgYXNzaWdubWVudFxyXG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBMSFNBc3NpZ25fMS5MSFNBc3NpZ24oKTtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5ZXhwKHYudik7XHJcbiAgICAgICAgICAgIGlmICh2LnYuayA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WQ0FMTCkgLy8gc3RhdCAtPiBmdW5jXHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5zZXRhcmdjKHYudiwgMSk7IC8vIGNhbGwgc3RhdGVtZW50IHVzZXMgbm8gcmVzdWx0c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgLy8gc3RhdCAtPiBhc3NpZ25tZW50XHJcbiAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2LnByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50KHYsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgKiogY2hlY2sgd2hldGhlciwgaW4gYW4gYXNzaWdubWVudCB0byBhIGxvY2FsIHZhcmlhYmxlLCB0aGUgbG9jYWwgdmFyaWFibGVcclxuICAgICAgICAqKiBpcyBuZWVkZWQgaW4gYSBwcmV2aW91cyBhc3NpZ25tZW50ICh0byBhIHRhYmxlKS4gSWYgc28sIHNhdmUgb3JpZ2luYWxcclxuICAgICAgICAqKiBsb2NhbCB2YWx1ZSBpbiBhIHNhZmUgcGxhY2UgYW5kIHVzZSB0aGlzIHNhZmUgY29weSBpbiB0aGUgcHJldmlvdXNcclxuICAgICAgICAqKiBhc3NpZ25tZW50LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgY2hlY2tfY29uZmxpY3QobGgsIHYpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5fZnMuZnJlZXJlZzsgLyogZXZlbnR1YWwgcG9zaXRpb24gdG8gc2F2ZSBsb2NhbCB2YXJpYWJsZSAqL1xyXG4gICAgICAgICAgICB2YXIgY29uZmxpY3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yICg7IGxoICE9IG51bGw7IGxoID0gbGgucHJldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxoLnYuayA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WSU5ERVhFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaC52LmluZm8gPT0gdi5pbmZvKSAvKiBjb25mbGljdD8gKi8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxoLnYuaW5mbyA9IGV4dHJhOyAvKiBwcmV2aW91cyBhc3NpZ25tZW50IHdpbGwgdXNlIHNhZmUgY29weSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGgudi5hdXggPT0gdi5pbmZvKSAvKiBjb25mbGljdD8gKi8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxoLnYuYXV4ID0gZXh0cmE7IC8qIHByZXZpb3VzIGFzc2lnbm1lbnQgd2lsbCB1c2Ugc2FmZSBjb3B5ICovXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb25mbGljdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua0NvZGVBQkMoTHVhXzEuTHVhLk9QX01PVkUsIHRoaXMuX2ZzLmZyZWVyZWcsIHYuaW5mbywgMCk7IC8qIG1ha2UgY29weSAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua1Jlc2VydmVyZWdzKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2lnbm1lbnQobGgsIG52YXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgIHZhciBraW5kID0gbGgudi5rO1xyXG4gICAgICAgICAgICBpZiAoIShFeHBkZXNjXzEuRXhwZGVzYy5WTE9DQUwgPD0ga2luZCAmJiBraW5kIDw9IEV4cGRlc2NfMS5FeHBkZXNjLlZJTkRFWEVEKSlcclxuICAgICAgICAgICAgICAgIHRoaXMueFN5bnRheGVycm9yKFwic3ludGF4IGVycm9yXCIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZXN0bmV4dCgnLCcuY2hhckNvZGVBdCgwKSkpIC8qIGFzc2lnbm1lbnQgLT4gYCwnIHByaW1hcnlleHAgYXNzaWdubWVudCAqLyB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnYgPSBuZXcgTEhTQXNzaWduXzEuTEhTQXNzaWduKCk7XHJcbiAgICAgICAgICAgICAgICBudi5pbml0KGxoKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5ZXhwKG52LnYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG52LnYuayA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WTE9DQUwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja19jb25mbGljdChsaCwgbnYudik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnQobnYsIG52YXJzICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSAvKiBhc3NpZ25tZW50IC0+IGA9JyBleHBsaXN0MSAqLyB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4cHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrbmV4dCgnPScuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuZXhwcyA9IHRoaXMuZXhwbGlzdDEoZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4cHMgIT0gbnZhcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkanVzdF9hc3NpZ24obnZhcnMsIG5leHBzLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4cHMgPiBudmFycylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnMuZnJlZXJlZyAtPSBuZXhwcyAtIG52YXJzOyAvKiByZW1vdmUgZXh0cmEgdmFsdWVzICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rU2V0b25lcmV0KGUpOyAvKiBjbG9zZSBsYXN0IGV4cHJlc3Npb24gKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rU3RvcmV2YXIobGgudiwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvKiBhdm9pZCBkZWZhdWx0ICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZS5pbml0KEV4cGRlc2NfMS5FeHBkZXNjLlZOT05SRUxPQywgdGhpcy5fZnMuZnJlZXJlZyAtIDEpOyAvKiBkZWZhdWx0IGFzc2lnbm1lbnQgKi9cclxuICAgICAgICAgICAgdGhpcy5fZnMua1N0b3JldmFyKGxoLnYsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jYXJncyhmKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5fbGluZW51bWJlcjtcclxuICAgICAgICAgICAgc3dpdGNoIChTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuX3Rva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6IC8vIGZ1bmNhcmdzIC0+ICcoJyBbIGV4cGxpc3QxIF0gJyknXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgIT0gdGhpcy5sYXN0bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnhTeW50YXhlcnJvcihcImFtYmlndW91cyBzeW50YXggKGZ1bmN0aW9uIGNhbGwgeCBuZXcgc3RhdGVtZW50KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b2tlbiA9PSAnKScuY2hhckNvZGVBdCgwKSkgLy8gYXJnIGxpc3QgaXMgZW1wdHk/XHJcbiAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5raW5kID0gRXhwZGVzY18xLkV4cGRlc2MuVlZPSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGxpc3QxKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rU2V0bXVsdHJldChhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja19tYXRjaCgnKScuY2hhckNvZGVBdCgwKSwgJygnLmNoYXJDb2RlQXQoMCksIGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAneyc6IC8vIGZ1bmNhcmdzIC0+IGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvcl8oYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX1NUUklORyk6IC8vIGZ1bmNhcmdzIC0+IFNUUklOR1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZXN0cmluZyhhcmdzLCB0aGlzLl90b2tlblMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueE5leHQoKTsgLy8gbXVzdCB1c2UgdG9rZW5TIGJlZm9yZSAnbmV4dCdcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54U3ludGF4ZXJyb3IoXCJmdW5jdGlvbiBhcmd1bWVudHMgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFzc2VydCAoZi5raW5kKCkgPT0gVk5PTlJFTE9DKTtcclxuICAgICAgICAgICAgdmFyIG5wYXJhbXM7XHJcbiAgICAgICAgICAgIHZhciBiYXNlID0gZi5pbmZvOyAvLyBiYXNlIHJlZ2lzdGVyIGZvciBjYWxsXHJcbiAgICAgICAgICAgIGlmIChhcmdzLmhhc211bHRyZXQoKSkge1xyXG4gICAgICAgICAgICAgICAgbnBhcmFtcyA9IEx1YV8xLkx1YS5NVUxUUkVUOyAvLyBvcGVuIGNhbGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmtpbmQgIT0gRXhwZGVzY18xLkV4cGRlc2MuVlZPSUQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rRXhwMm5leHRyZWcoYXJncyk7IC8vIGNsb3NlIGxhc3QgYXJndW1lbnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5wYXJhbXMgPSB0aGlzLl9mcy5mcmVlcmVnIC0gKGJhc2UgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmLmluaXQoRXhwZGVzY18xLkV4cGRlc2MuVkNBTEwsIHRoaXMuX2ZzLmtDb2RlQUJDKEx1YV8xLkx1YS5PUF9DQUxMLCBiYXNlLCBucGFyYW1zICsgMSwgMikpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rRml4bGluZShsaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5fZnMuZnJlZXJlZyA9IGJhc2UgKyAxOyAvLyBjYWxsIHJlbW92ZXMgZnVuY3Rpb25zIGFuZCBhcmd1bWVudHNcclxuICAgICAgICAgICAgLy8gYW5kIGxlYXZlcyAodW5sZXNzIGNoYW5nZWQpIG9uZSByZXN1bHQuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZWZpeGV4cCh2KSB7XHJcbiAgICAgICAgICAgIC8vIHByZWZpeGV4cCAtPiBOQU1FIHwgJygnIGV4cHIgJyknXHJcbiAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl90b2tlbikpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJygnOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLl9saW5lbnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnhOZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcih2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja19tYXRjaCgnKScuY2hhckNvZGVBdCgwKSwgJygnLmNoYXJDb2RlQXQoMCksIGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rRGlzY2hhcmdldmFycyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nLmZyb21DaGFyQ29kZShTeW50YXguVEtfTkFNRSk6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaW5nbGV2YXIodik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhTeW50YXhlcnJvcihcInVuZXhwZWN0ZWQgc3ltYm9sXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcmltYXJ5ZXhwKHYpIHtcclxuICAgICAgICAgICAgLy8gcHJpbWFyeWV4cCAtPlxyXG4gICAgICAgICAgICAvLyAgICBwcmVmaXhleHAgeyAnLicgTkFNRSB8ICdbJyBleHAgJ10nIHwgJzonIE5BTUUgZnVuY2FyZ3MgfCBmdW5jYXJncyB9XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4ZXhwKHYpO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuX3Rva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy4nOiAvKiBmaWVsZCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpZWxkKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzogLyogYFsnIGV4cDEgYF0nICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBuZXcgRXhwZGVzY18xLkV4cGRlc2MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtFeHAyYW55cmVnKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55aW5kZXgoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtJbmRleGVkKHYsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOic6IC8qIGA6JyBOQU1FIGZ1bmNhcmdzICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkyID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnhOZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrbmFtZShrZXkyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtTZWxmKHYsIGtleTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mdW5jYXJncyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX1NUUklORyk6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6IC8vIGZ1bmNhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtFeHAybmV4dHJlZyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mdW5jYXJncyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHN0YXQoKSB7XHJcbiAgICAgICAgICAgIC8vIHN0YXQgLT4gUkVUVVJOIGV4cGxpc3RcclxuICAgICAgICAgICAgdGhpcy54TmV4dCgpOyAvLyBza2lwIFJFVFVSTlxyXG4gICAgICAgICAgICAvLyByZWdpc3RlcnMgd2l0aCByZXR1cm5lZCB2YWx1ZXMgKGZpcnN0LCBucmV0KVxyXG4gICAgICAgICAgICB2YXIgZmlyc3QgPSAwO1xyXG4gICAgICAgICAgICB2YXIgbnJldDtcclxuICAgICAgICAgICAgaWYgKFN5bnRheC5ibG9ja19mb2xsb3codGhpcy5fdG9rZW4pIHx8IHRoaXMuX3Rva2VuID09ICc7Jy5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbm8gdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IDA7XHJcbiAgICAgICAgICAgICAgICBucmV0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgICAgICBucmV0ID0gdGhpcy5leHBsaXN0MShlKTtcclxuICAgICAgICAgICAgICAgIGlmIChTeW50YXguaGFzbXVsdHJldChlLmspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnMua1NldG11bHRyZXQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuayA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WQ0FMTCAmJiBucmV0ID09IDEpIC8qIHRhaWwgY2FsbD8gKi8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5zZXRjb2RlKGUsIEx1YV8xLkx1YS5TRVRfT1BDT0RFKHRoaXMuX2ZzLmdldGNvZGUoZSksIEx1YV8xLkx1YS5PUF9UQUlMQ0FMTCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyMgYXNzZXJ0IEx1YS5BUkdBKGZzLmdldGNvZGUoZSkpID09IGZzLm5hY3R2YXJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLl9mcy5uYWN0dmFyO1xyXG4gICAgICAgICAgICAgICAgICAgIG5yZXQgPSBMdWFfMS5MdWEuTVVMVFJFVDsgLyogcmV0dXJuIGFsbCB2YWx1ZXMgKi9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChucmV0ID09IDEpIC8vIG9ubHkgb25lIHNpbmdsZSB2YWx1ZT9cclxuICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMuX2ZzLmtFeHAyYW55cmVnKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnMua0V4cDJuZXh0cmVnKGUpOyAvKiB2YWx1ZXMgbXVzdCBnbyB0byB0aGUgYHN0YWNrJyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMuX2ZzLm5hY3R2YXI7IC8qIHJldHVybiBhbGwgYGFjdGl2ZScgdmFsdWVzICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIyBhc3NlcnQgbnJldCA9PSBmcy5mcmVlcmVnIC0gZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZnMua1JldChmaXJzdCwgbnJldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNpbXBsZWV4cCh2KSB7XHJcbiAgICAgICAgICAgIC8vIHNpbXBsZWV4cCAtPiBOVU1CRVIgfCBTVFJJTkcgfCBOSUwgfCB0cnVlIHwgZmFsc2UgfCAuLi4gfFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgY29uc3RydWN0b3IgfCBGVU5DVElPTiBib2R5IHwgcHJpbWFyeWV4cFxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19OVU1CRVI6XHJcbiAgICAgICAgICAgICAgICAgICAgdi5pbml0KEV4cGRlc2NfMS5FeHBkZXNjLlZLTlVNLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB2Lm52YWwgPSB0aGlzLl90b2tlblI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19TVFJJTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2Rlc3RyaW5nKHYsIHRoaXMuX3Rva2VuUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19OSUw6XHJcbiAgICAgICAgICAgICAgICAgICAgdi5pbml0KEV4cGRlc2NfMS5FeHBkZXNjLlZOSUwsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfVFJVRTpcclxuICAgICAgICAgICAgICAgICAgICB2LmluaXQoRXhwZGVzY18xLkV4cGRlc2MuVlRSVUUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfRkFMU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgdi5pbml0KEV4cGRlc2NfMS5FeHBkZXNjLlZGQUxTRSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19ET1RTOiAvKiB2YXJhcmcgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZzLmYuaXNWYXJhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueFN5bnRheGVycm9yKFwiY2Fubm90IHVzZSBcXFwiLi4uXFxcIiBvdXRzaWRlIGEgdmFyYXJnIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuaW5pdChFeHBkZXNjXzEuRXhwZGVzYy5WVkFSQVJHLCB0aGlzLl9mcy5rQ29kZUFCQyhMdWFfMS5MdWEuT1BfVkFSQVJHLCAwLCAxLCAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd7Jy5jaGFyQ29kZUF0KDApOiAvKiBjb25zdHJ1Y3RvciAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JfKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlRLX0ZVTkNUSU9OOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHkodiwgZmFsc2UsIHRoaXMuX2xpbmVudW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5ZXhwKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnhOZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlbWVudCgpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLl9saW5lbnVtYmVyO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19JRjogLy8gc3RhdCAtPiBpZnN0YXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlmc3RhdChsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19XSElMRTogLy8gc3RhdCAtPiB3aGlsZXN0YXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndoaWxlc3RhdChsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19ETzogLy8gc3RhdCAtPiBETyBibG9jayBFTkRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhOZXh0KCk7IC8vIHNraXAgRE9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja19tYXRjaChTeW50YXguVEtfRU5ELCBTeW50YXguVEtfRE8sIGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlRLX0ZPUjogLy8gc3RhdCAtPiBmb3JzdGF0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JzdGF0KGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlRLX1JFUEVBVDogLy8gc3RhdCAtPiByZXBlYXRzdGF0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRzdGF0KGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlRLX0ZVTkNUSU9OOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3N0YXQobGluZSk7IC8vIHN0YXQgLT4gZnVuY3N0YXRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19MT0NBTDogLy8gc3RhdCAtPiBsb2NhbHN0YXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhOZXh0KCk7IC8vIHNraXAgTE9DQUxcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXN0bmV4dChTeW50YXguVEtfRlVOQ1RJT04pKSAvLyBsb2NhbCBmdW5jdGlvbj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbGZ1bmMoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxzdGF0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfUkVUVVJOOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0c3RhdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBtdXN0IGJlIGxhc3Qgc3RhdGVtZW50XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19CUkVBSzogLy8gc3RhdCAtPiBicmVha3N0YXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhOZXh0KCk7IC8vIHNraXAgQlJFQUtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJyZWFrc3RhdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBtdXN0IGJlIGxhc3Qgc3RhdGVtZW50XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcnN0YXQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIENvbnZlcnRzIHRva2VuIGludG8gYmluYXJ5IG9wZXJhdG9yLiAgKi9cclxuICAgICAgICBzdGF0aWMgZ2V0Ymlub3ByKG9wKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZShvcCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX0FERDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX1NVQjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX01VTDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX0RJVjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX01PRDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ14nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX1BPVztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nLmZyb21DaGFyQ29kZShTeW50YXguVEtfQ09OQ0FUKTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4Lk9QUl9DT05DQVQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX05FKTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4Lk9QUl9ORTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nLmZyb21DaGFyQ29kZShTeW50YXguVEtfRVEpOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX0VRO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5PUFJfTFQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX0xFKTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4Lk9QUl9MRTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX0dUO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmcuZnJvbUNoYXJDb2RlKFN5bnRheC5US19HRSk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5PUFJfR0U7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX0FORCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5PUFJfQU5EO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmcuZnJvbUNoYXJDb2RlKFN5bnRheC5US19PUik6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5PUFJfT1I7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX05PQklOT1BSO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBnZXR1bm9wcihvcCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKFN0cmluZy5mcm9tQ2hhckNvZGUob3ApKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX05PVCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5PUFJfTk9UO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheC5PUFJfTUlOVVM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcjJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4Lk9QUl9MRU47XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXguT1BSX05PVU5PUFI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzZXIuXHJcbiAgICAgICAgICogPGNvZGU+c3ViZXhwciAtPiAoc2ltcGxlZXhwKSB8IHVub3Agc3ViZXhwcikgeyBiaW5vcCBzdWJleHByIH08L2NvZGU+XHJcbiAgICAgICAgICogd2hlcmUgPHZhcj5iaW5vcDwvdmFyPiBpcyBhbnkgYmluYXJ5IG9wZXJhdG9yIHdpdGggYSBwcmlvcml0eVxyXG4gICAgICAgICAqIGhpZ2hlciB0aGFuIDx2YXI+bGltaXQ8L3Zhcj4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3ViZXhwcih2LCBsaW1pdCkge1xyXG4gICAgICAgICAgICB0aGlzLmVudGVybGV2ZWwoKTtcclxuICAgICAgICAgICAgdmFyIHVvcCA9IFN5bnRheC5nZXR1bm9wcih0aGlzLl90b2tlbik7XHJcbiAgICAgICAgICAgIGlmICh1b3AgIT0gU3ludGF4Lk9QUl9OT1VOT1BSKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnhOZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmV4cHIodiwgU3ludGF4LlVOQVJZX1BSSU9SSVRZKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtQcmVmaXgodW9wLCB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2ltcGxlZXhwKHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGV4cGFuZCB3aGlsZSBvcGVyYXRvcnMgaGF2ZSBwcmlvcml0aWVzIGhpZ2hlciB0aGFuICdsaW1pdCdcclxuICAgICAgICAgICAgdmFyIG9wID0gU3ludGF4LmdldGJpbm9wcih0aGlzLl90b2tlbik7XHJcbiAgICAgICAgICAgIHdoaWxlIChvcCAhPSBTeW50YXguT1BSX05PQklOT1BSICYmIFN5bnRheC5QUklPUklUWVtvcF1bMF0gPiBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYyID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnhOZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rSW5maXgob3AsIHYpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBzdWItZXhwcmVzc2lvbiB3aXRoIGhpZ2hlciBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRvcCA9IHRoaXMuc3ViZXhwcih2MiwgU3ludGF4LlBSSU9SSVRZW29wXVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rUG9zZml4KG9wLCB2LCB2Mik7XHJcbiAgICAgICAgICAgICAgICBvcCA9IG5leHRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxlYXZlbGV2ZWwoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbnRlcmJsb2NrKGYsIGJsLCBpc2JyZWFrYWJsZSkge1xyXG4gICAgICAgICAgICBibC5icmVha2xpc3QgPSBGdW5jU3RhdGVfMS5GdW5jU3RhdGUuTk9fSlVNUDtcclxuICAgICAgICAgICAgYmwuaXNicmVha2FibGUgPSBpc2JyZWFrYWJsZTtcclxuICAgICAgICAgICAgYmwubmFjdHZhciA9IGYubmFjdHZhcjtcclxuICAgICAgICAgICAgYmwudXB2YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgYmwucHJldmlvdXMgPSBmLmJsO1xyXG4gICAgICAgICAgICBmLmJsID0gYmw7XHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgZi5mcmVlcmVnID09IGYubmFjdHZhclxyXG4gICAgICAgIH1cclxuICAgICAgICBsZWF2ZWJsb2NrKGYpIHtcclxuICAgICAgICAgICAgdmFyIGJsID0gZi5ibDtcclxuICAgICAgICAgICAgZi5ibCA9IGJsLnByZXZpb3VzO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZXZhcnMoYmwubmFjdHZhcik7XHJcbiAgICAgICAgICAgIGlmIChibC51cHZhbClcclxuICAgICAgICAgICAgICAgIGYua0NvZGVBQkMoTHVhXzEuTHVhLk9QX0NMT1NFLCBibC5uYWN0dmFyLCAwLCAwKTtcclxuICAgICAgICAgICAgLyogbG9vcHMgaGF2ZSBubyBib2R5ICovXHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgKCFibC5pc2JyZWFrYWJsZSkgfHwgKCFibC51cHZhbClcclxuICAgICAgICAgICAgLy8jIGFzc2VydCBibC5uYWN0dmFyID09IGYubmFjdHZhclxyXG4gICAgICAgICAgICBmLmZyZWVyZWcgPSBmLm5hY3R2YXI7IC8qIGZyZWUgcmVnaXN0ZXJzICovXHJcbiAgICAgICAgICAgIGYua1BhdGNodG9oZXJlKGJsLmJyZWFrbGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgKiogez09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAqKiBSdWxlcyBmb3IgU3RhdGVtZW50c1xyXG4gICAgICAgICoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgKi9cclxuICAgICAgICBibG9jaygpIHtcclxuICAgICAgICAgICAgLyogYmxvY2sgLT4gY2h1bmsgKi9cclxuICAgICAgICAgICAgdmFyIGJsID0gbmV3IEJsb2NrQ250XzEuQmxvY2tDbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5lbnRlcmJsb2NrKHRoaXMuX2ZzLCBibCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmNodW5rKCk7XHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgYmwuYnJlYWtsaXN0ID09IEZ1bmNTdGF0ZS5OT19KVU1QXHJcbiAgICAgICAgICAgIHRoaXMubGVhdmVibG9jayh0aGlzLl9mcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrc3RhdCgpIHtcclxuICAgICAgICAgICAgdmFyIGJsID0gdGhpcy5fZnMuYmw7XHJcbiAgICAgICAgICAgIHZhciB1cHZhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAoYmwgIT0gbnVsbCAmJiAhYmwuaXNicmVha2FibGUpIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETzp8fD1cclxuICAgICAgICAgICAgICAgIHVwdmFsIHx8ICh1cHZhbCA9IGJsLnVwdmFsKTtcclxuICAgICAgICAgICAgICAgIGJsID0gYmwucHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJsID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnhTeW50YXhlcnJvcihcIm5vIGxvb3AgdG8gYnJlYWtcIik7XHJcbiAgICAgICAgICAgIGlmICh1cHZhbClcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtDb2RlQUJDKEx1YV8xLkx1YS5PUF9DTE9TRSwgYmwubmFjdHZhciwgMCwgMCk7XHJcbiAgICAgICAgICAgIGJsLmJyZWFrbGlzdCA9IHRoaXMuX2ZzLmtDb25jYXQoYmwuYnJlYWtsaXN0LCB0aGlzLl9mcy5rSnVtcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3N0YXQobGluZSkge1xyXG4gICAgICAgICAgICAvKiBmdW5jc3RhdCAtPiBGVU5DVElPTiBmdW5jbmFtZSBib2R5ICovXHJcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgIHZhciB2ID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgIHRoaXMueE5leHQoKTsgLyogc2tpcCBGVU5DVElPTiAqL1xyXG4gICAgICAgICAgICB2YXIgbmVlZHNlbGYgPSB0aGlzLmZ1bmNuYW1lKHYpO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkoYiwgbmVlZHNlbGYsIGxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rU3RvcmV2YXIodiwgYik7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtGaXhsaW5lKGxpbmUpOyAvKiBkZWZpbml0aW9uIGBoYXBwZW5zJyBpbiB0aGUgZmlyc3QgbGluZSAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja25leHQoYykge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrKGMpO1xyXG4gICAgICAgICAgICB0aGlzLnhOZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmxpc3QoKSB7XHJcbiAgICAgICAgICAgIC8qIHBhcmxpc3QgLT4gWyBwYXJhbSB7IGAsJyBwYXJhbSB9IF0gKi9cclxuICAgICAgICAgICAgdmFyIGYgPSB0aGlzLl9mcy5mO1xyXG4gICAgICAgICAgICB2YXIgbnBhcmFtcyA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b2tlbiAhPSAnKScuY2hhckNvZGVBdCgwKSkgLyogaXMgYHBhcmxpc3QnIG5vdCBlbXB0eT8gKi8ge1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVEtfTkFNRTogLyogcGFyYW0gLT4gTkFNRSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3X2xvY2FsdmFyKHRoaXMuc3RyX2NoZWNrbmFtZSgpLCBucGFyYW1zKyspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5US19ET1RTOiAvKiBwYXJhbSAtPiBgLi4uJyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmlzVmFyYXJnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueFN5bnRheGVycm9yKFwiPG5hbWU+IG9yICcuLi4nIGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKCghZi5pc1ZhcmFyZykgJiYgdGhpcy50ZXN0bmV4dCgnLCcuY2hhckNvZGVBdCgwKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0bG9jYWx2YXJzKG5wYXJhbXMpO1xyXG4gICAgICAgICAgICBmLm51bXBhcmFtcyA9IHRoaXMuX2ZzLm5hY3R2YXI7IC8qIFZBUkFSR19IQVNBUkcgbm90IG5vdyB1c2VkICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtSZXNlcnZlcmVncyh0aGlzLl9mcy5uYWN0dmFyKTsgLyogcmVzZXJ2ZSByZWdpc3RlciBmb3IgcGFyYW1ldGVycyAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRsb2N2YXIoaSkge1xyXG4gICAgICAgICAgICB2YXIgZnN0YXRlID0gdGhpcy5fZnM7XHJcbiAgICAgICAgICAgIHJldHVybiBmc3RhdGUuZi5sb2N2YXJzW2ZzdGF0ZS5hY3R2YXJbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGp1c3Rsb2NhbHZhcnMobnZhcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZnMubmFjdHZhciArPSBudmFycztcclxuICAgICAgICAgICAgZm9yICg7IG52YXJzICE9IDA7IG52YXJzLS0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0bG9jdmFyKHRoaXMuX2ZzLm5hY3R2YXIgLSBudmFycykuc3RhcnRwYyA9IHRoaXMuX2ZzLnBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld19sb2NhbHZhcmxpdGVyYWwodiwgbikge1xyXG4gICAgICAgICAgICB0aGlzLm5ld19sb2NhbHZhcih2LCBuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXJyb3JsaW1pdChsaW1pdCwgd2hhdCkge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gdGhpcy5fZnMuZi5saW5lZGVmaW5lZCA9PSAwID9cclxuICAgICAgICAgICAgICAgIFwibWFpbiBmdW5jdGlvbiBoYXMgbW9yZSB0aGFuIFwiICsgbGltaXQgKyBcIiBcIiArIHdoYXQgOlxyXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBhdCBsaW5lIFwiICsgdGhpcy5fZnMuZi5saW5lZGVmaW5lZCArIFwiIGhhcyBtb3JlIHRoYW4gXCIgKyBsaW1pdCArIFwiIFwiICsgd2hhdDtcclxuICAgICAgICAgICAgdGhpcy54TGV4ZXJyb3IobXNnLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeUNoZWNrbGltaXQodiwgbCwgbSkge1xyXG4gICAgICAgICAgICBpZiAodiA+IGwpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ybGltaXQobCwgbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld19sb2NhbHZhcihuYW1lLCBuKSB7XHJcbiAgICAgICAgICAgIHRoaXMueUNoZWNrbGltaXQodGhpcy5fZnMubmFjdHZhciArIG4gKyAxLCBMdWFfMS5MdWEuTUFYVkFSUywgXCJsb2NhbCB2YXJpYWJsZXNcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmFjdHZhclt0aGlzLl9mcy5uYWN0dmFyICsgbl0gPSB0aGlzLnJlZ2lzdGVybG9jYWx2YXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2lzdGVybG9jYWx2YXIodmFybmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgZiA9IHRoaXMuX2ZzLmY7XHJcbiAgICAgICAgICAgIGYuZW5zdXJlTG9jdmFycyh0aGlzLl9MLCB0aGlzLl9mcy5ubG9jdmFycywgLypTaG9ydCovIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTsgLy9UT0RPOlxyXG4gICAgICAgICAgICBmLmxvY3ZhcnNbdGhpcy5fZnMubmxvY3ZhcnNdLnZhcm5hbWUgPSB2YXJuYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnMubmxvY3ZhcnMrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgYm9keShlLCBuZWVkc2VsZiwgbGluZSkge1xyXG4gICAgICAgICAgICAvKiBib2R5IC0+ICBgKCcgcGFybGlzdCBgKScgY2h1bmsgRU5EICovXHJcbiAgICAgICAgICAgIHZhciBuZXdfZnMgPSBuZXcgRnVuY1N0YXRlXzEuRnVuY1N0YXRlKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5fZnVuYyhuZXdfZnMpO1xyXG4gICAgICAgICAgICBuZXdfZnMuZi5saW5lZGVmaW5lZCA9IGxpbmU7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tuZXh0KCcoJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgaWYgKG5lZWRzZWxmKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5ld19sb2NhbHZhcmxpdGVyYWwoXCJzZWxmXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3Rsb2NhbHZhcnMoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJsaXN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tuZXh0KCcpJy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgdGhpcy5jaHVuaygpO1xyXG4gICAgICAgICAgICBuZXdfZnMuZi5sYXN0bGluZWRlZmluZWQgPSB0aGlzLl9saW5lbnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrX21hdGNoKFN5bnRheC5US19FTkQsIFN5bnRheC5US19GVU5DVElPTiwgbGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VfZnVuYygpO1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hjbG9zdXJlKG5ld19mcywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFVQVkFMX0sodXB2YWxkZXNjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodXB2YWxkZXNjID4+PiA4KSAmIDB4RkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFVQVkFMX0lORk8odXB2YWxkZXNjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1cHZhbGRlc2MgJiAweEZGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBVUFZBTF9FTkNPREUoaywgaW5mbykge1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IChrICYgMHhGRikgPT0gayAmJiAoaW5mbyAmIDB4RkYpID09IGluZm9cclxuICAgICAgICAgICAgcmV0dXJuICgoayAmIDB4RkYpIDw8IDgpIHwgKGluZm8gJiAweEZGKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaGNsb3N1cmUoZnVuYywgdikge1xyXG4gICAgICAgICAgICB2YXIgZiA9IHRoaXMuX2ZzLmY7XHJcbiAgICAgICAgICAgIGYuZW5zdXJlUHJvdG9zKHRoaXMuX0wsIHRoaXMuX2ZzLm5wKTtcclxuICAgICAgICAgICAgdmFyIGZmID0gZnVuYy5mO1xyXG4gICAgICAgICAgICBmLnBbdGhpcy5fZnMubnArK10gPSBmZjtcclxuICAgICAgICAgICAgdi5pbml0KEV4cGRlc2NfMS5FeHBkZXNjLlZSRUxPQ0FCTEUsIHRoaXMuX2ZzLmtDb2RlQUJ4KEx1YV8xLkx1YS5PUF9DTE9TVVJFLCAwLCB0aGlzLl9mcy5ucCAtIDEpKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZi5udXBzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cHZhbHVlID0gZnVuYy51cHZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBvID0gKHRoaXMuVVBWQUxfSyh1cHZhbHVlKSA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WTE9DQUwpID8gTHVhXzEuTHVhLk9QX01PVkUgOlxyXG4gICAgICAgICAgICAgICAgICAgIEx1YV8xLkx1YS5PUF9HRVRVUFZBTDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtDb2RlQUJDKG8sIDAsIHRoaXMuVVBWQUxfSU5GTyh1cHZhbHVlKSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY25hbWUodikge1xyXG4gICAgICAgICAgICAvKiBmdW5jbmFtZSAtPiBOQU1FIHtmaWVsZH0gW2A6JyBOQU1FXSAqL1xyXG4gICAgICAgICAgICB2YXIgbmVlZHNlbGYgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zaW5nbGV2YXIodik7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl90b2tlbiA9PSAnLicuY2hhckNvZGVBdCgwKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZmllbGQodik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b2tlbiA9PSAnOicuY2hhckNvZGVBdCgwKSkge1xyXG4gICAgICAgICAgICAgICAgbmVlZHNlbGYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWVsZCh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmVlZHNlbGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkKHYpIHtcclxuICAgICAgICAgICAgLyogZmllbGQgLT4gWycuJyB8ICc6J10gTkFNRSAqL1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtFeHAyYW55cmVnKHYpO1xyXG4gICAgICAgICAgICB0aGlzLnhOZXh0KCk7IC8qIHNraXAgdGhlIGRvdCBvciBjb2xvbiAqL1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrbmFtZShrZXkpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rSW5kZXhlZCh2LCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBlYXRzdGF0KGxpbmUpIHtcclxuICAgICAgICAgICAgLyogcmVwZWF0c3RhdCAtPiBSRVBFQVQgYmxvY2sgVU5USUwgY29uZCAqL1xyXG4gICAgICAgICAgICB2YXIgcmVwZWF0X2luaXQgPSB0aGlzLl9mcy5rR2V0bGFiZWwoKTtcclxuICAgICAgICAgICAgdmFyIGJsMSA9IG5ldyBCbG9ja0NudF8xLkJsb2NrQ250KCk7XHJcbiAgICAgICAgICAgIHZhciBibDIgPSBuZXcgQmxvY2tDbnRfMS5CbG9ja0NudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmVudGVyYmxvY2sodGhpcy5fZnMsIGJsMSwgdHJ1ZSk7IC8qIGxvb3AgYmxvY2sgKi9cclxuICAgICAgICAgICAgdGhpcy5lbnRlcmJsb2NrKHRoaXMuX2ZzLCBibDIsIGZhbHNlKTsgLyogc2NvcGUgYmxvY2sgKi9cclxuICAgICAgICAgICAgdGhpcy54TmV4dCgpOyAvKiBza2lwIFJFUEVBVCAqL1xyXG4gICAgICAgICAgICB0aGlzLmNodW5rKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfbWF0Y2goU3ludGF4LlRLX1VOVElMLCBTeW50YXguVEtfUkVQRUFULCBsaW5lKTtcclxuICAgICAgICAgICAgdmFyIGNvbmRleGl0ID0gdGhpcy5jb25kKCk7IC8qIHJlYWQgY29uZGl0aW9uIChpbnNpZGUgc2NvcGUgYmxvY2spICovXHJcbiAgICAgICAgICAgIGlmICghYmwyLnVwdmFsKSAvKiBubyB1cHZhbHVlcz8gKi8ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZWJsb2NrKHRoaXMuX2ZzKTsgLyogZmluaXNoIHNjb3BlICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rUGF0Y2hsaXN0KGNvbmRleGl0LCByZXBlYXRfaW5pdCk7IC8qIGNsb3NlIHRoZSBsb29wICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSAvKiBjb21wbGV0ZSBzZW1hbnRpY3Mgd2hlbiB0aGVyZSBhcmUgdXB2YWx1ZXMgKi8ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3N0YXQoKTsgLyogaWYgY29uZGl0aW9uIHRoZW4gYnJlYWsgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtQYXRjaHRvaGVyZShjb25kZXhpdCk7IC8qIGVsc2UuLi4gKi9cclxuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVibG9jayh0aGlzLl9mcyk7IC8qIGZpbmlzaCBzY29wZS4uLiAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua1BhdGNobGlzdCh0aGlzLl9mcy5rSnVtcCgpLCByZXBlYXRfaW5pdCk7IC8qIGFuZCByZXBlYXQgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxlYXZlYmxvY2sodGhpcy5fZnMpOyAvKiBmaW5pc2ggbG9vcCAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25kKCkge1xyXG4gICAgICAgICAgICAvKiBjb25kIC0+IGV4cCAqL1xyXG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBFeHBkZXNjXzEuRXhwZGVzYygpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cHIodik7IC8qIHJlYWQgY29uZGl0aW9uICovXHJcbiAgICAgICAgICAgIGlmICh2LmsgPT0gRXhwZGVzY18xLkV4cGRlc2MuVk5JTClcclxuICAgICAgICAgICAgICAgIHYuayA9IEV4cGRlc2NfMS5FeHBkZXNjLlZGQUxTRTsgLyogYGZhbHNlcycgYXJlIGFsbCBlcXVhbCBoZXJlICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtHb2lmdHJ1ZSh2KTtcclxuICAgICAgICAgICAgcmV0dXJuIHYuZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3Blbl9mdW5jKGZ1bmNzdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBQcm90b18xLlByb3RvKCk7IC8qIHJlZ2lzdGVycyAwLzEgYXJlIGFsd2F5cyB2YWxpZCAqL1xyXG4gICAgICAgICAgICBmLmluaXQyKHRoaXMuc291cmNlLCAyKTtcclxuICAgICAgICAgICAgZnVuY3N0YXRlLmYgPSBmO1xyXG4gICAgICAgICAgICBmdW5jc3RhdGUubHMgPSB0aGlzO1xyXG4gICAgICAgICAgICBmdW5jc3RhdGUuTCA9IHRoaXMuX0w7XHJcbiAgICAgICAgICAgIGZ1bmNzdGF0ZS5wcmV2ID0gdGhpcy5fZnM7IC8qIGxpbmtlZCBsaXN0IG9mIGZ1bmNzdGF0ZXMgKi9cclxuICAgICAgICAgICAgdGhpcy5fZnMgPSBmdW5jc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvY2Fsc3RhdCgpIHtcclxuICAgICAgICAgICAgLyogc3RhdCAtPiBMT0NBTCBOQU1FIHtgLCcgTkFNRX0gW2A9JyBleHBsaXN0MV0gKi9cclxuICAgICAgICAgICAgdmFyIG52YXJzID0gMDtcclxuICAgICAgICAgICAgdmFyIG5leHBzO1xyXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFeHBkZXNjXzEuRXhwZGVzYygpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5ld19sb2NhbHZhcih0aGlzLnN0cl9jaGVja25hbWUoKSwgbnZhcnMrKyk7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMudGVzdG5leHQoJywnLmNoYXJDb2RlQXQoMCkpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVzdG5leHQoJz0nLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXhwcyA9IHRoaXMuZXhwbGlzdDEoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlLmsgPSBFeHBkZXNjXzEuRXhwZGVzYy5WVk9JRDtcclxuICAgICAgICAgICAgICAgIG5leHBzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkanVzdF9hc3NpZ24obnZhcnMsIG5leHBzLCBlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGp1c3Rsb2NhbHZhcnMobnZhcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JzdGF0KGxpbmUpIHtcclxuICAgICAgICAgICAgLyogZm9yc3RhdCAtPiBGT1IgKGZvcm51bSB8IGZvcmxpc3QpIEVORCAqL1xyXG4gICAgICAgICAgICB2YXIgYmwgPSBuZXcgQmxvY2tDbnRfMS5CbG9ja0NudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmVudGVyYmxvY2sodGhpcy5fZnMsIGJsLCB0cnVlKTsgLyogc2NvcGUgZm9yIGxvb3AgYW5kIGNvbnRyb2wgdmFyaWFibGVzICovXHJcbiAgICAgICAgICAgIHRoaXMueE5leHQoKTsgLyogc2tpcCBgZm9yJyAqL1xyXG4gICAgICAgICAgICB2YXIgdmFybmFtZSA9IHRoaXMuc3RyX2NoZWNrbmFtZSgpOyAvKiBmaXJzdCB2YXJpYWJsZSBuYW1lICovXHJcbiAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl90b2tlbikpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybnVtKHZhcm5hbWUsIGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnLCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZy5mcm9tQ2hhckNvZGUoU3ludGF4LlRLX0lOKTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmxpc3QodmFybmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueFN5bnRheGVycm9yKFwiXFxcIj1cXFwiIG9yIFxcXCJpblxcXCIgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jaGVja19tYXRjaChTeW50YXguVEtfRU5ELCBTeW50YXguVEtfRk9SLCBsaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5sZWF2ZWJsb2NrKHRoaXMuX2ZzKTsgLyogbG9vcCBzY29wZSAoYGJyZWFrJyBqdW1wcyB0byB0aGlzIHBvaW50KSAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JudW0odmFybmFtZSwgbGluZSkge1xyXG4gICAgICAgICAgICAvKiBmb3JudW0gLT4gTkFNRSA9IGV4cDEsZXhwMVssZXhwMV0gZm9yYm9keSAqL1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMuX2ZzLmZyZWVyZWc7XHJcbiAgICAgICAgICAgIHRoaXMubmV3X2xvY2FsdmFybGl0ZXJhbChcIihmb3IgaW5kZXgpXCIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLm5ld19sb2NhbHZhcmxpdGVyYWwoXCIoZm9yIGxpbWl0KVwiLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5uZXdfbG9jYWx2YXJsaXRlcmFsKFwiKGZvciBzdGVwKVwiLCAyKTtcclxuICAgICAgICAgICAgdGhpcy5uZXdfbG9jYWx2YXIodmFybmFtZSwgMyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tuZXh0KCc9Jy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgdGhpcy5leHAxKCk7IC8qIGluaXRpYWwgdmFsdWUgKi9cclxuICAgICAgICAgICAgdGhpcy5jaGVja25leHQoJywnLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cDEoKTsgLyogbGltaXQgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMudGVzdG5leHQoJywnLmNoYXJDb2RlQXQoMCkpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5leHAxKCk7IC8qIG9wdGlvbmFsIHN0ZXAgKi9cclxuICAgICAgICAgICAgZWxzZSAvKiBkZWZhdWx0IHN0ZXAgPSAxICovIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtDb2RlQUJ4KEx1YV8xLkx1YS5PUF9MT0FESywgdGhpcy5fZnMuZnJlZXJlZywgdGhpcy5fZnMua051bWJlcksoMSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua1Jlc2VydmVyZWdzKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZm9yYm9keShiYXNlLCBsaW5lLCAxLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwMSgpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXhwZGVzY18xLkV4cGRlc2MoKTtcclxuICAgICAgICAgICAgdGhpcy5leHByKGUpO1xyXG4gICAgICAgICAgICB2YXIgayA9IGUuaztcclxuICAgICAgICAgICAgdGhpcy5fZnMua0V4cDJuZXh0cmVnKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybGlzdChpbmRleG5hbWUpIHtcclxuICAgICAgICAgICAgLyogZm9ybGlzdCAtPiBOQU1FIHssTkFNRX0gSU4gZXhwbGlzdDEgZm9yYm9keSAqL1xyXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFeHBkZXNjXzEuRXhwZGVzYygpO1xyXG4gICAgICAgICAgICB2YXIgbnZhcnMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMuX2ZzLmZyZWVyZWc7XHJcbiAgICAgICAgICAgIC8qIGNyZWF0ZSBjb250cm9sIHZhcmlhYmxlcyAqL1xyXG4gICAgICAgICAgICB0aGlzLm5ld19sb2NhbHZhcmxpdGVyYWwoXCIoZm9yIGdlbmVyYXRvcilcIiwgbnZhcnMrKyk7XHJcbiAgICAgICAgICAgIHRoaXMubmV3X2xvY2FsdmFybGl0ZXJhbChcIihmb3Igc3RhdGUpXCIsIG52YXJzKyspO1xyXG4gICAgICAgICAgICB0aGlzLm5ld19sb2NhbHZhcmxpdGVyYWwoXCIoZm9yIGNvbnRyb2wpXCIsIG52YXJzKyspO1xyXG4gICAgICAgICAgICAvKiBjcmVhdGUgZGVjbGFyZWQgdmFyaWFibGVzICovXHJcbiAgICAgICAgICAgIHRoaXMubmV3X2xvY2FsdmFyKGluZGV4bmFtZSwgbnZhcnMrKyk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRlc3RuZXh0KCcsJy5jaGFyQ29kZUF0KDApKSlcclxuICAgICAgICAgICAgICAgIHRoaXMubmV3X2xvY2FsdmFyKHRoaXMuc3RyX2NoZWNrbmFtZSgpLCBudmFycysrKTtcclxuICAgICAgICAgICAgdGhpcy5jaGVja25leHQoU3ludGF4LlRLX0lOKTtcclxuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLl9saW5lbnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdF9hc3NpZ24oMywgdGhpcy5leHBsaXN0MShlKSwgZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtDaGVja3N0YWNrKDMpOyAvKiBleHRyYSBzcGFjZSB0byBjYWxsIGdlbmVyYXRvciAqL1xyXG4gICAgICAgICAgICB0aGlzLmZvcmJvZHkoYmFzZSwgbGluZSwgbnZhcnMgLSAzLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcmJvZHkoYmFzZSwgbGluZSwgbnZhcnMsIGlzbnVtKSB7XHJcbiAgICAgICAgICAgIC8qIGZvcmJvZHkgLT4gRE8gYmxvY2sgKi9cclxuICAgICAgICAgICAgdmFyIGJsID0gbmV3IEJsb2NrQ250XzEuQmxvY2tDbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5hZGp1c3Rsb2NhbHZhcnMoMyk7IC8qIGNvbnRyb2wgdmFyaWFibGVzICovXHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tuZXh0KFN5bnRheC5US19ETyk7XHJcbiAgICAgICAgICAgIHZhciBwcmVwID0gaXNudW0gPyB0aGlzLl9mcy5rQ29kZUFzQngoTHVhXzEuTHVhLk9QX0ZPUlBSRVAsIGJhc2UsIEZ1bmNTdGF0ZV8xLkZ1bmNTdGF0ZS5OT19KVU1QKSA6IHRoaXMuX2ZzLmtKdW1wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJibG9jayh0aGlzLl9mcywgYmwsIGZhbHNlKTsgLyogc2NvcGUgZm9yIGRlY2xhcmVkIHZhcmlhYmxlcyAqL1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdGxvY2FsdmFycyhudmFycyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtSZXNlcnZlcmVncyhudmFycyk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2soKTtcclxuICAgICAgICAgICAgdGhpcy5sZWF2ZWJsb2NrKHRoaXMuX2ZzKTsgLyogZW5kIG9mIHNjb3BlIGZvciBkZWNsYXJlZCB2YXJpYWJsZXMgKi9cclxuICAgICAgICAgICAgdGhpcy5fZnMua1BhdGNodG9oZXJlKHByZXApO1xyXG4gICAgICAgICAgICB2YXIgZW5kZm9yID0gaXNudW0gP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua0NvZGVBc0J4KEx1YV8xLkx1YS5PUF9GT1JMT09QLCBiYXNlLCBGdW5jU3RhdGVfMS5GdW5jU3RhdGUuTk9fSlVNUCkgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua0NvZGVBQkMoTHVhXzEuTHVhLk9QX1RGT1JMT09QLCBiYXNlLCAwLCBudmFycyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtGaXhsaW5lKGxpbmUpOyAvKiBwcmV0ZW5kIHRoYXQgYE9QX0ZPUicgc3RhcnRzIHRoZSBsb29wICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmtQYXRjaGxpc3QoKGlzbnVtID8gZW5kZm9yIDogdGhpcy5fZnMua0p1bXAoKSksIHByZXAgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWZzdGF0KGxpbmUpIHtcclxuICAgICAgICAgICAgLyogaWZzdGF0IC0+IElGIGNvbmQgVEhFTiBibG9jayB7RUxTRUlGIGNvbmQgVEhFTiBibG9ja30gW0VMU0UgYmxvY2tdIEVORCAqL1xyXG4gICAgICAgICAgICB2YXIgZXNjYXBlbGlzdCA9IEZ1bmNTdGF0ZV8xLkZ1bmNTdGF0ZS5OT19KVU1QO1xyXG4gICAgICAgICAgICB2YXIgZmxpc3QgPSB0aGlzLnRlc3RfdGhlbl9ibG9jaygpOyAvKiBJRiBjb25kIFRIRU4gYmxvY2sgKi9cclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3Rva2VuID09IFN5bnRheC5US19FTFNFSUYpIHtcclxuICAgICAgICAgICAgICAgIGVzY2FwZWxpc3QgPSB0aGlzLl9mcy5rQ29uY2F0KGVzY2FwZWxpc3QsIHRoaXMuX2ZzLmtKdW1wKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnMua1BhdGNodG9oZXJlKGZsaXN0KTtcclxuICAgICAgICAgICAgICAgIGZsaXN0ID0gdGhpcy50ZXN0X3RoZW5fYmxvY2soKTsgLyogRUxTRUlGIGNvbmQgVEhFTiBibG9jayAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b2tlbiA9PSBTeW50YXguVEtfRUxTRSkge1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlbGlzdCA9IHRoaXMuX2ZzLmtDb25jYXQoZXNjYXBlbGlzdCwgdGhpcy5fZnMua0p1bXAoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rUGF0Y2h0b2hlcmUoZmxpc3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54TmV4dCgpOyAvKiBza2lwIEVMU0UgKGFmdGVyIHBhdGNoLCBmb3IgY29ycmVjdCBsaW5lIGluZm8pICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrKCk7IC8qIGBlbHNlJyBwYXJ0ICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZXNjYXBlbGlzdCA9IHRoaXMuX2ZzLmtDb25jYXQoZXNjYXBlbGlzdCwgZmxpc3QpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rUGF0Y2h0b2hlcmUoZXNjYXBlbGlzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfbWF0Y2goU3ludGF4LlRLX0VORCwgU3ludGF4LlRLX0lGLCBsaW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVzdF90aGVuX2Jsb2NrKCkge1xyXG4gICAgICAgICAgICAvKiB0ZXN0X3RoZW5fYmxvY2sgLT4gW0lGIHwgRUxTRUlGXSBjb25kIFRIRU4gYmxvY2sgKi9cclxuICAgICAgICAgICAgdGhpcy54TmV4dCgpOyAvKiBza2lwIElGIG9yIEVMU0VJRiAqL1xyXG4gICAgICAgICAgICB2YXIgY29uZGV4aXQgPSB0aGlzLmNvbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5jaGVja25leHQoU3ludGF4LlRLX1RIRU4pO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrKCk7IC8qIGB0aGVuJyBwYXJ0ICovXHJcbiAgICAgICAgICAgIHJldHVybiBjb25kZXhpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGVzdGF0KGxpbmUpIHtcclxuICAgICAgICAgICAgLyogd2hpbGVzdGF0IC0+IFdISUxFIGNvbmQgRE8gYmxvY2sgRU5EICovXHJcbiAgICAgICAgICAgIHZhciBibCA9IG5ldyBCbG9ja0NudF8xLkJsb2NrQ250KCk7XHJcbiAgICAgICAgICAgIHRoaXMueE5leHQoKTsgLyogc2tpcCBXSElMRSAqL1xyXG4gICAgICAgICAgICB2YXIgd2hpbGVpbml0ID0gdGhpcy5fZnMua0dldGxhYmVsKCk7XHJcbiAgICAgICAgICAgIHZhciBjb25kZXhpdCA9IHRoaXMuY29uZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmVudGVyYmxvY2sodGhpcy5fZnMsIGJsLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5jaGVja25leHQoU3ludGF4LlRLX0RPKTtcclxuICAgICAgICAgICAgdGhpcy5ibG9jaygpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rUGF0Y2hsaXN0KHRoaXMuX2ZzLmtKdW1wKCksIHdoaWxlaW5pdCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfbWF0Y2goU3ludGF4LlRLX0VORCwgU3ludGF4LlRLX1dISUxFLCBsaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5sZWF2ZWJsb2NrKHRoaXMuX2ZzKTtcclxuICAgICAgICAgICAgdGhpcy5fZnMua1BhdGNodG9oZXJlKGNvbmRleGl0KTsgLyogZmFsc2UgY29uZGl0aW9ucyBmaW5pc2ggdGhlIGxvb3AgKi9cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGhhc211bHRyZXQoaykge1xyXG4gICAgICAgICAgICByZXR1cm4gayA9PSBFeHBkZXNjXzEuRXhwZGVzYy5WQ0FMTCB8fCBrID09IEV4cGRlc2NfMS5FeHBkZXNjLlZWQVJBUkc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkanVzdF9hc3NpZ24obnZhcnMsIG5leHBzLCBlKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IG52YXJzIC0gbmV4cHM7XHJcbiAgICAgICAgICAgIGlmIChTeW50YXguaGFzbXVsdHJldChlLmspKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYSsrOyAvKiBpbmNsdWRlcyBjYWxsIGl0c2VsZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBleHRyYSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcy5rU2V0cmV0dXJucyhlLCBleHRyYSk7IC8qIGxhc3QgZXhwLiBwcm92aWRlcyB0aGUgZGlmZmVyZW5jZSAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhID4gMSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rUmVzZXJ2ZXJlZ3MoZXh0cmEgLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmsgIT0gRXhwZGVzY18xLkV4cGRlc2MuVlZPSUQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnMua0V4cDJuZXh0cmVnKGUpOyAvKiBjbG9zZSBsYXN0IGV4cHJlc3Npb24gKi9cclxuICAgICAgICAgICAgICAgIGlmIChleHRyYSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnID0gdGhpcy5fZnMuZnJlZXJlZztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcy5rUmVzZXJ2ZXJlZ3MoZXh0cmEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZzLmtOaWwocmVnLCBleHRyYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbG9jYWxmdW5jKCkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBFeHBkZXNjXzEuRXhwZGVzYygpO1xyXG4gICAgICAgICAgICB0aGlzLm5ld19sb2NhbHZhcih0aGlzLnN0cl9jaGVja25hbWUoKSwgMCk7XHJcbiAgICAgICAgICAgIHZhciB2ID0gbmV3IEV4cGRlc2NfMS5FeHBkZXNjKCk7XHJcbiAgICAgICAgICAgIHYuaW5pdChFeHBkZXNjXzEuRXhwZGVzYy5WTE9DQUwsIHRoaXMuX2ZzLmZyZWVyZWcpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rUmVzZXJ2ZXJlZ3MoMSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0bG9jYWx2YXJzKDEpO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkoYiwgZmFsc2UsIHRoaXMuX2xpbmVudW1iZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rU3RvcmV2YXIodiwgYik7XHJcbiAgICAgICAgICAgIC8qIGRlYnVnIGluZm9ybWF0aW9uIHdpbGwgb25seSBzZWUgdGhlIHZhcmlhYmxlIGFmdGVyIHRoaXMgcG9pbnQhICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZzLmdldGxvY3Zhcih0aGlzLl9mcy5uYWN0dmFyIC0gMSkuc3RhcnRwYyA9IHRoaXMuX2ZzLnBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aW5kZXgodikge1xyXG4gICAgICAgICAgICAvKiBpbmRleCAtPiAnWycgZXhwciAnXScgKi9cclxuICAgICAgICAgICAgdGhpcy54TmV4dCgpOyAvKiBza2lwIHRoZSAnWycgKi9cclxuICAgICAgICAgICAgdGhpcy5leHByKHYpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcy5rRXhwMnZhbCh2KTtcclxuICAgICAgICAgICAgdGhpcy5jaGVja25leHQoJ10nLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4TG9va2FoZWFkKCkge1xyXG4gICAgICAgICAgICAvLyMgYXNzZXJ0IGxvb2thaGVhZCA9PSBUS19FT1NcclxuICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkID0gdGhpcy5sbGV4KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb2thaGVhZFIgPSB0aGlzLl9zZW1SO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29rYWhlYWRTID0gdGhpcy5fc2VtUztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGlzdGZpZWxkKGNjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwcihjYy52KTtcclxuICAgICAgICAgICAgdGhpcy55Q2hlY2tsaW1pdChjYy5uYSwgTHVhXzEuTHVhLk1BWEFSR19CeCwgXCJpdGVtcyBpbiBhIGNvbnN0cnVjdG9yXCIpO1xyXG4gICAgICAgICAgICBjYy5uYSsrO1xyXG4gICAgICAgICAgICBjYy50b3N0b3JlKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4dXB2YWx1ZShmdW5jc3RhdGUsIG5hbWUsIHYpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBmdW5jc3RhdGUuZjtcclxuICAgICAgICAgICAgdmFyIG9sZHNpemUgPSBmLnNpemV1cHZhbHVlcztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmLm51cHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZnVuY3N0YXRlLnVwdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuVVBWQUxfSyhlbnRyeSkgPT0gdi5rICYmIHRoaXMuVVBWQUxfSU5GTyhlbnRyeSkgPT0gdi5pbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8jIGFzc2VydCBuYW1lLmVxdWFscyhmLnVwdmFsdWVzW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIG5ldyBvbmUgKi9cclxuICAgICAgICAgICAgdGhpcy55Q2hlY2tsaW1pdChmLm51cHMgKyAxLCBMdWFfMS5MdWEuTUFYVVBWQUxVRVMsIFwidXB2YWx1ZXNcIik7XHJcbiAgICAgICAgICAgIGYuZW5zdXJlVXB2YWxzKHRoaXMuX0wsIGYubnVwcyk7XHJcbiAgICAgICAgICAgIGYudXB2YWx1ZXNbZi5udXBzXSA9IG5hbWU7XHJcbiAgICAgICAgICAgIC8vIyBhc3NlcnQgdi5rID09IEV4cGRlc2MuVkxPQ0FMIHx8IHYuayA9PSBFeHBkZXNjLlZVUFZBTFxyXG4gICAgICAgICAgICBmdW5jc3RhdGUudXB2YWx1ZXNbZi5udXBzXSA9IHRoaXMuVVBWQUxfRU5DT0RFKHYuaywgdi5pbmZvKTtcclxuICAgICAgICAgICAgcmV0dXJuIGYubnVwcysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aWsOWinlxyXG4gICAgICAgIGdldCBMKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fTDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLlN5bnRheCA9IFN5bnRheDtcclxuICAgIC8qKiBFbmQgb2YgRmlsZSwgbXVzdCBiZSAtMSBhcyB0aGF0IGlzIHdoYXQgcmVhZCgpIHJldHVybnMuICovXHJcbiAgICBTeW50YXguRU9aID0gLTE7XHJcbiAgICBTeW50YXguRklSU1RfUkVTRVJWRUQgPSAyNTc7XHJcbiAgICAvLyBXQVJOSU5HOiBpZiB5b3UgY2hhbmdlIHRoZSBvcmRlciBvZiB0aGlzIGVudW1lcmF0aW9uLFxyXG4gICAgLy8gZ3JlcCBcIk9SREVSIFJFU0VSVkVEXCJcclxuICAgIFN5bnRheC5US19BTkQgPSBTeW50YXguRklSU1RfUkVTRVJWRUQgKyAwO1xyXG4gICAgU3ludGF4LlRLX0JSRUFLID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMTtcclxuICAgIFN5bnRheC5US19ETyA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDI7XHJcbiAgICBTeW50YXguVEtfRUxTRSA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDM7XHJcbiAgICBTeW50YXguVEtfRUxTRUlGID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgNDtcclxuICAgIFN5bnRheC5US19FTkQgPSBTeW50YXguRklSU1RfUkVTRVJWRUQgKyA1O1xyXG4gICAgU3ludGF4LlRLX0ZBTFNFID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgNjtcclxuICAgIFN5bnRheC5US19GT1IgPSBTeW50YXguRklSU1RfUkVTRVJWRUQgKyA3O1xyXG4gICAgU3ludGF4LlRLX0ZVTkNUSU9OID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgODtcclxuICAgIFN5bnRheC5US19JRiA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDk7XHJcbiAgICBTeW50YXguVEtfSU4gPSBTeW50YXguRklSU1RfUkVTRVJWRUQgKyAxMDtcclxuICAgIFN5bnRheC5US19MT0NBTCA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDExO1xyXG4gICAgU3ludGF4LlRLX05JTCA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDEyO1xyXG4gICAgU3ludGF4LlRLX05PVCA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDEzO1xyXG4gICAgU3ludGF4LlRLX09SID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMTQ7XHJcbiAgICBTeW50YXguVEtfUkVQRUFUID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMTU7XHJcbiAgICBTeW50YXguVEtfUkVUVVJOID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMTY7XHJcbiAgICBTeW50YXguVEtfVEhFTiA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDE3O1xyXG4gICAgU3ludGF4LlRLX1RSVUUgPSBTeW50YXguRklSU1RfUkVTRVJWRUQgKyAxODtcclxuICAgIFN5bnRheC5US19VTlRJTCA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDE5O1xyXG4gICAgU3ludGF4LlRLX1dISUxFID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMjA7XHJcbiAgICBTeW50YXguVEtfQ09OQ0FUID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMjE7XHJcbiAgICBTeW50YXguVEtfRE9UUyA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDIyO1xyXG4gICAgU3ludGF4LlRLX0VRID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMjM7XHJcbiAgICBTeW50YXguVEtfR0UgPSBTeW50YXguRklSU1RfUkVTRVJWRUQgKyAyNDtcclxuICAgIFN5bnRheC5US19MRSA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDI1O1xyXG4gICAgU3ludGF4LlRLX05FID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMjY7XHJcbiAgICBTeW50YXguVEtfTlVNQkVSID0gU3ludGF4LkZJUlNUX1JFU0VSVkVEICsgMjc7XHJcbiAgICBTeW50YXguVEtfTkFNRSA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDI4O1xyXG4gICAgU3ludGF4LlRLX1NUUklORyA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDI5O1xyXG4gICAgU3ludGF4LlRLX0VPUyA9IFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDMwO1xyXG4gICAgU3ludGF4Lk5VTV9SRVNFUlZFRCA9IFN5bnRheC5US19XSElMRSAtIFN5bnRheC5GSVJTVF9SRVNFUlZFRCArIDE7XHJcbiAgICAvKiogRXF1aXZhbGVudCB0byBsdWFYX3Rva2Vucy4gIE9SREVSIFJFU0VSVkVEICovXHJcbiAgICBTeW50YXguX3Rva2VucyA9IFtcclxuICAgICAgICBcImFuZFwiLCBcImJyZWFrXCIsIFwiZG9cIiwgXCJlbHNlXCIsIFwiZWxzZWlmXCIsXHJcbiAgICAgICAgXCJlbmRcIiwgXCJmYWxzZVwiLCBcImZvclwiLCBcImZ1bmN0aW9uXCIsIFwiaWZcIixcclxuICAgICAgICBcImluXCIsIFwibG9jYWxcIiwgXCJuaWxcIiwgXCJub3RcIiwgXCJvclwiLCBcInJlcGVhdFwiLFxyXG4gICAgICAgIFwicmV0dXJuXCIsIFwidGhlblwiLCBcInRydWVcIiwgXCJ1bnRpbFwiLCBcIndoaWxlXCIsXHJcbiAgICAgICAgXCIuLlwiLCBcIi4uLlwiLCBcIj09XCIsIFwiPj1cIiwgXCI8PVwiLCBcIn49XCIsXHJcbiAgICAgICAgXCI8bnVtYmVyPlwiLCBcIjxuYW1lPlwiLCBcIjxzdHJpbmc+XCIsIFwiPGVvZj5cIlxyXG4gICAgXTtcclxuICAgIC8vIGdyZXAgXCJPUkRFUiBPUFJcIiBpZiB5b3UgY2hhbmdlIHRoZXNlIGVudW1zLlxyXG4gICAgLy8gZGVmYXVsdCBhY2Nlc3Mgc28gdGhhdCBGdW5jU3RhdGUgY2FuIGFjY2VzcyB0aGVtLlxyXG4gICAgU3ludGF4Lk9QUl9BREQgPSAwO1xyXG4gICAgU3ludGF4Lk9QUl9TVUIgPSAxO1xyXG4gICAgU3ludGF4Lk9QUl9NVUwgPSAyO1xyXG4gICAgU3ludGF4Lk9QUl9ESVYgPSAzO1xyXG4gICAgU3ludGF4Lk9QUl9NT0QgPSA0O1xyXG4gICAgU3ludGF4Lk9QUl9QT1cgPSA1O1xyXG4gICAgU3ludGF4Lk9QUl9DT05DQVQgPSA2O1xyXG4gICAgU3ludGF4Lk9QUl9ORSA9IDc7XHJcbiAgICBTeW50YXguT1BSX0VRID0gODtcclxuICAgIFN5bnRheC5PUFJfTFQgPSA5O1xyXG4gICAgU3ludGF4Lk9QUl9MRSA9IDEwO1xyXG4gICAgU3ludGF4Lk9QUl9HVCA9IDExO1xyXG4gICAgU3ludGF4Lk9QUl9HRSA9IDEyO1xyXG4gICAgU3ludGF4Lk9QUl9BTkQgPSAxMztcclxuICAgIFN5bnRheC5PUFJfT1IgPSAxNDtcclxuICAgIFN5bnRheC5PUFJfTk9CSU5PUFIgPSAxNTtcclxuICAgIFN5bnRheC5PUFJfTUlOVVMgPSAwO1xyXG4gICAgU3ludGF4Lk9QUl9OT1QgPSAxO1xyXG4gICAgU3ludGF4Lk9QUl9MRU4gPSAyO1xyXG4gICAgU3ludGF4Lk9QUl9OT1VOT1BSID0gMztcclxuICAgIC8vIE9SREVSIE9QUlxyXG4gICAgLyoqXHJcbiAgICAqIFByaW9yaXR5IHRhYmxlLiAgbGVmdC1wcmlvcml0eSBvZiBhbiBvcGVyYXRvciBpc1xyXG4gICAgKiA8Y29kZT5wcmlvcml0eVtvcF1bMF08L2NvZGU+LCBpdHMgcmlnaHQgcHJpb3JpdHkgaXNcclxuICAgICogPGNvZGU+cHJpb3JpdHlbb3BdWzFdPC9jb2RlPi4gIFBsZWFzZSBkbyBub3QgbW9kaWZ5IHRoaXMgdGFibGUuXHJcbiAgICAqL1xyXG4gICAgU3ludGF4LlBSSU9SSVRZID0gW1xyXG4gICAgICAgIFs2LCA2XSwgWzYsIDZdLCBbNywgN10sIFs3LCA3XSwgWzcsIDddLFxyXG4gICAgICAgIFsxMCwgOV0sIFs1LCA0XSxcclxuICAgICAgICBbMywgM10sIFszLCAzXSxcclxuICAgICAgICBbMywgM10sIFszLCAzXSwgWzMsIDNdLCBbMywgM10sXHJcbiAgICAgICAgWzIsIDJdLCBbMSwgMV0gLy8gbG9naWNhbCAoYW5kL29yKVxyXG4gICAgXTtcclxuICAgIC8qKiBQcmlvcml0eSBmb3IgdW5hcnkgb3BlcmF0b3JzLiAqL1xyXG4gICAgU3ludGF4LlVOQVJZX1BSSU9SSVRZID0gODtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5bnRheC5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vTHVhSmF2YUNhbGxiYWNrXCIsIFwiLi4vamF2YS9TdHJpbmdCdWZmZXJcIiwgXCIuL0x1YVwiXSwgZmFjdG9yeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuVGFibGVMaWIgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBMdWFKYXZhQ2FsbGJhY2tfMSA9IHJlcXVpcmUoXCIuL0x1YUphdmFDYWxsYmFja1wiKTtcclxuICAgIGNvbnN0IFN0cmluZ0J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL2phdmEvU3RyaW5nQnVmZmVyXCIpO1xyXG4gICAgY29uc3QgTHVhXzEgPSByZXF1aXJlKFwiLi9MdWFcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvVGFibGVMaWIuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5zIEx1YSdzIHRhYmxlIGxpYnJhcnkuXHJcbiAgICAgKiBUaGUgbGlicmFyeSBjYW4gYmUgb3BlbmVkIHVzaW5nIHRoZSB7QGxpbmsgI29wZW59IG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgVGFibGVMaWIgZXh0ZW5kcyBMdWFKYXZhQ2FsbGJhY2tfMS5MdWFKYXZhQ2FsbGJhY2sge1xyXG4gICAgICAgIC8qKiBDb25zdHJ1Y3RzIGluc3RhbmNlLCBmaWxsaW5nIGluIHRoZSAnd2hpY2gnIG1lbWJlci4gKi9cclxuICAgICAgICBjb25zdHJ1Y3Rvcih3aGljaCkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl93aGljaCA9IHdoaWNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXBsZW1lbnRzIGFsbCBvZiB0aGUgZnVuY3Rpb25zIGluIHRoZSBMdWEgdGFibGUgbGlicmFyeS4gIERvIG5vdFxyXG4gICAgICAgICAqIGNhbGwgZGlyZWN0bHkuXHJcbiAgICAgICAgICogQHBhcmFtIEwgIHRoZSBMdWEgc3RhdGUgaW4gd2hpY2ggdG8gZXhlY3V0ZS5cclxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiByZXR1cm5lZCBwYXJhbWV0ZXJzLCBhcyBwZXIgY29udmVudGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsdWFGdW5jdGlvbihMKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fd2hpY2gpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgVGFibGVMaWIuQ09OQ0FUOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZUxpYi5jb25jYXQoTCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlTGliLklOU0VSVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGVMaWIuaW5zZXJ0KEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZUxpYi5NQVhOOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZUxpYi5tYXhuKEwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZUxpYi5SRU1PVkU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlTGliLnJlbW92ZShMKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgVGFibGVMaWIuU09SVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGVMaWIuc29ydChMKTtcclxuICAgICAgICAgICAgICAgIC8vRklYTUU6IGFkZGVkXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlTGliLkdFVE46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlTGliLmdldG4oTCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogT3BlbnMgdGhlIHN0cmluZyBsaWJyYXJ5IGludG8gdGhlIGdpdmVuIEx1YSBzdGF0ZS4gIFRoaXMgcmVnaXN0ZXJzXHJcbiAgICAgICAgKiB0aGUgc3ltYm9scyBvZiB0aGUgc3RyaW5nIGxpYnJhcnkgaW4gYSBuZXdseSBjcmVhdGVkIHRhYmxlIGNhbGxlZFxyXG4gICAgICAgICogXCJzdHJpbmdcIi5cclxuICAgICAgICAqIEBwYXJhbSBMICBUaGUgTHVhIHN0YXRlIGludG8gd2hpY2ggdG8gb3Blbi5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBvcGVuKEwpIHtcclxuICAgICAgICAgICAgTC5fX3JlZ2lzdGVyKFwidGFibGVcIik7XHJcbiAgICAgICAgICAgIFRhYmxlTGliLnIoTCwgXCJjb25jYXRcIiwgVGFibGVMaWIuQ09OQ0FUKTtcclxuICAgICAgICAgICAgVGFibGVMaWIucihMLCBcImluc2VydFwiLCBUYWJsZUxpYi5JTlNFUlQpO1xyXG4gICAgICAgICAgICBUYWJsZUxpYi5yKEwsIFwiZ2V0blwiLCBUYWJsZUxpYi5HRVROKTsgLy9GSVhNRTogYWRkZWRcclxuICAgICAgICAgICAgVGFibGVMaWIucihMLCBcIm1heG5cIiwgVGFibGVMaWIuTUFYTik7XHJcbiAgICAgICAgICAgIFRhYmxlTGliLnIoTCwgXCJyZW1vdmVcIiwgVGFibGVMaWIuUkVNT1ZFKTtcclxuICAgICAgICAgICAgVGFibGVMaWIucihMLCBcInNvcnRcIiwgVGFibGVMaWIuU09SVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBSZWdpc3RlciBhIGZ1bmN0aW9uLiAqL1xyXG4gICAgICAgIHN0YXRpYyByKEwsIG5hbWUsIHdoaWNoKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gbmV3IFRhYmxlTGliKHdoaWNoKTtcclxuICAgICAgICAgICAgdmFyIGxpYiA9IEwuZ2V0R2xvYmFsKFwidGFibGVcIik7XHJcbiAgICAgICAgICAgIEwuc2V0RmllbGQobGliLCBuYW1lLCBmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgdGFibGUuY29uY2F0LiAqL1xyXG4gICAgICAgIHN0YXRpYyBjb25jYXQoTCkge1xyXG4gICAgICAgICAgICB2YXIgc2VwID0gTC5vcHRTdHJpbmcoMiwgXCJcIik7XHJcbiAgICAgICAgICAgIEwuY2hlY2tUeXBlKDEsIEx1YV8xLkx1YS5UVEFCTEUpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IEwub3B0SW50KDMsIDEpO1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IEwub3B0SW50KDQsIEx1YV8xLkx1YS5vYmpMZW4oTC52YWx1ZSgxKSkpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBTdHJpbmdCdWZmZXJfMS5TdHJpbmdCdWZmZXIoKTtcclxuICAgICAgICAgICAgdmFyIHQgPSBMLnZhbHVlKDEpO1xyXG4gICAgICAgICAgICBmb3IgKDsgaSA8PSBsYXN0OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gTHVhXzEuTHVhLnJhd0dldEkodCwgaSk7XHJcbiAgICAgICAgICAgICAgICBMLmFyZ0NoZWNrKEx1YV8xLkx1YS5pc1N0cmluZyh2KSwgMSwgXCJ0YWJsZSBjb250YWlucyBub24tc3RyaW5nc1wiKTtcclxuICAgICAgICAgICAgICAgIGIuYXBwZW5kU3RyaW5nKEwudG9TdHJpbmdfKHYpKTtcclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGxhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgYi5hcHBlbmRTdHJpbmcoTC50b1N0cmluZ18oc2VwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTC5wdXNoU3RyaW5nKGIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyB0YWJsZS5pbnNlcnQuICovXHJcbiAgICAgICAgc3RhdGljIGluc2VydChMKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gVGFibGVMaWIuYXV4X2dldG4oTCwgMSkgKyAxOyAvLyBmaXJzdCBlbXB0eSBlbGVtZW50XHJcbiAgICAgICAgICAgIHZhciBwb3M7IC8vIHdoZXJlIHRvIGluc2VydCBuZXcgZWxlbWVudFxyXG4gICAgICAgICAgICB2YXIgdCA9IEwudmFsdWUoMSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoTC5nZXRUb3AoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBjYWxsZWQgd2l0aCBvbmx5IDIgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZTsgLy8gaW5zZXJ0IG5ldyBlbGVtZW50IGF0IHRoZSBlbmRcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBMLmNoZWNrSW50KDIpOyAvLyAybmQgYXJndW1lbnQgaXMgdGhlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPiBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHBvczsgLy8gZ3JvdyBhcnJheSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gZTsgaSA+IHBvczsgLS1pKSAvLyBtb3ZlIHVwIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0W2ldID0gdFtpLTFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgaSwgTHVhXzEuTHVhLnJhd0dldEkodCwgaSAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEwuZXJyb3IoXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvICdpbnNlcnQnXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucmF3U2V0SSh0LCBwb3MsIEwudmFsdWUoLTEpKTsgLy8gdFtwb3NdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgdGFibGUubWF4bi4gKi9cclxuICAgICAgICBzdGF0aWMgbWF4bihMKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSAwO1xyXG4gICAgICAgICAgICBMLmNoZWNrVHlwZSgxLCBMdWFfMS5MdWEuVFRBQkxFKTtcclxuICAgICAgICAgICAgdmFyIHQgPSBMLnZhbHVlKDEpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHQua2V5cygpO1xyXG4gICAgICAgICAgICB3aGlsZSAoZS5oYXNNb3JlRWxlbWVudHMoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG8gPSBlLm5leHRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTHVhXzEuTHVhLl9fX190eXBlKG8pID09IEx1YV8xLkx1YS5UTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBMLnRvTnVtYmVyKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID4gbWF4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucHVzaE51bWJlcihtYXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEltcGxlbWVudHMgdGFibGUucmVtb3ZlLiAqL1xyXG4gICAgICAgIHN0YXRpYyByZW1vdmUoTCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IFRhYmxlTGliLmF1eF9nZXRuKEwsIDEpO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gTC5vcHRJbnQoMiwgZSk7XHJcbiAgICAgICAgICAgIGlmIChlID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDsgLy8gdGFibGUgaXMgJ2VtcHR5J1xyXG4gICAgICAgICAgICB2YXIgdCA9IEwudmFsdWUoMSk7XHJcbiAgICAgICAgICAgIHZhciBvID0gTHVhXzEuTHVhLnJhd0dldEkodCwgcG9zKTsgLy8gcmVzdWx0ID0gdFtwb3NdXHJcbiAgICAgICAgICAgIGZvciAoOyBwb3MgPCBlOyArK3Bvcykge1xyXG4gICAgICAgICAgICAgICAgTC5yYXdTZXRJKHQsIHBvcywgTHVhXzEuTHVhLnJhd0dldEkodCwgcG9zICsgMSkpOyAvLyB0W3Bvc10gPSB0W3BvcysxXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEwucmF3U2V0SSh0LCBlLCBMdWFfMS5MdWEuTklMKTsgLy8gdFtlXSA9IG5pbFxyXG4gICAgICAgICAgICBMLnB1c2hPYmplY3Qobyk7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogSW1wbGVtZW50cyB0YWJsZS5zb3J0LiAqL1xyXG4gICAgICAgIHN0YXRpYyBzb3J0KEwpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBUYWJsZUxpYi5hdXhfZ2V0bihMLCAxKTtcclxuICAgICAgICAgICAgaWYgKCFMLmlzTm9uZU9yTmlsKDIpKSAvLyBpcyB0aGVyZSBhIDJuZCBhcmd1bWVudD9cclxuICAgICAgICAgICAgICAgIEwuY2hlY2tUeXBlKDIsIEx1YV8xLkx1YS5URlVOQ1RJT04pO1xyXG4gICAgICAgICAgICBMLnNldFRvcCgyKTsgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIHR3byBhcmd1bWVudHNcclxuICAgICAgICAgICAgVGFibGVMaWIuYXV4c29ydChMLCAxLCBuKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBhdXhzb3J0KEwsIGwsIHUpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBMLnZhbHVlKDEpO1xyXG4gICAgICAgICAgICB3aGlsZSAobCA8IHUpIC8vIGZvciB0YWlsIHJlY3Vyc2lvblxyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgajtcclxuICAgICAgICAgICAgICAgIC8vIHNvcnQgZWxlbWVudHMgYVtsXSwgYVtsK3UvMl0sIGFuZCBhW3VdXHJcbiAgICAgICAgICAgICAgICB2YXIgbzEgPSBMdWFfMS5MdWEucmF3R2V0SSh0LCBsKTtcclxuICAgICAgICAgICAgICAgIHZhciBvMiA9IEx1YV8xLkx1YS5yYXdHZXRJKHQsIHUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFRhYmxlTGliLnNvcnRfY29tcChMLCBvMiwgbzEpKSAvLyBhW3VdIDwgYVtsXT9cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5yYXdTZXRJKHQsIGwsIG8yKTtcclxuICAgICAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgdSwgbzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHUgLSBsID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIG9ubHkgMiBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgaSA9IChsICsgdSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgbzEgPSBMdWFfMS5MdWEucmF3R2V0SSh0LCBpKTtcclxuICAgICAgICAgICAgICAgIG8yID0gTHVhXzEuTHVhLnJhd0dldEkodCwgbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoVGFibGVMaWIuc29ydF9jb21wKEwsIG8xLCBvMikpIC8vIGFbaV08YVtsXT9cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5yYXdTZXRJKHQsIGksIG8yKTtcclxuICAgICAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgbCwgbzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbzIgPSBMdWFfMS5MdWEucmF3R2V0SSh0LCB1KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVGFibGVMaWIuc29ydF9jb21wKEwsIG8yLCBvMSkpIC8vIGFbdV08YVtpXT9cclxuICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgaSwgbzIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgdSwgbzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1IC0gbCA9PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBvbmx5IDMgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIHZhciBwID0gTHVhXzEuTHVhLnJhd0dldEkodCwgaSk7IC8vIFBpdm90XHJcbiAgICAgICAgICAgICAgICBvMiA9IEx1YV8xLkx1YS5yYXdHZXRJKHQsIHUgLSAxKTtcclxuICAgICAgICAgICAgICAgIEwucmF3U2V0SSh0LCBpLCBvMik7XHJcbiAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgdSAtIDEsIHApO1xyXG4gICAgICAgICAgICAgICAgLy8gYVtsXSA8PSBQID09IGFbdS0xXSA8PSBhW3VdLCBvbmx5IG5lZWQgdG8gc29ydCBmcm9tIGwrMSB0byB1LTJcclxuICAgICAgICAgICAgICAgIGkgPSBsO1xyXG4gICAgICAgICAgICAgICAgaiA9IHUgLSAxO1xyXG4gICAgICAgICAgICAgICAgLy8gTkI6IFBpdm90IFAgaXMgaW4gcFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIC8vIGludmFyaWFudDogYVtsLi5pXSA8PSBQIDw9IGFbai4udV1cclxuICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwZWF0ICsraSB1bnRpbCBhW2ldID49IFBcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvMSA9IEx1YV8xLkx1YS5yYXdHZXRJKHQsICsraSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVGFibGVMaWIuc29ydF9jb21wKEwsIG8xLCBwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IHUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMLmVycm9yKFwiaW52YWxpZCBvcmRlciBmdW5jdGlvbiBmb3Igc29ydGluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwcmVhdCAtLWogdW50aWwgYVtqXSA8PSBQXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbzIgPSBMdWFfMS5MdWEucmF3R2V0SSh0LCAtLWopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVRhYmxlTGliLnNvcnRfY29tcChMLCBwLCBvMikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTC5lcnJvcihcImludmFsaWQgb3JkZXIgZnVuY3Rpb24gZm9yIHNvcnRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgTC5yYXdTZXRJKHQsIGksIG8yKTtcclxuICAgICAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgaiwgbzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbzEgPSBMdWFfMS5MdWEucmF3R2V0SSh0LCB1IC0gMSk7XHJcbiAgICAgICAgICAgICAgICBvMiA9IEx1YV8xLkx1YS5yYXdHZXRJKHQsIGkpO1xyXG4gICAgICAgICAgICAgICAgTC5yYXdTZXRJKHQsIHUgLSAxLCBvMik7XHJcbiAgICAgICAgICAgICAgICBMLnJhd1NldEkodCwgaSwgbzEpOyAvLyBzd2FwIHBpdm90IChhW3UtMV0pIHdpdGggYVtpXVxyXG4gICAgICAgICAgICAgICAgLy8gYVtsLi5pLTEgPD0gYVtpXSA9PSBQIDw9IGFbaSsxLi51XVxyXG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0IHNvIHRoYXQgc21hbGxlciBoYWxmIGlzIGluIFtqLi5pXSBhbmQgbGFyZ2VyIG9uZSBpbiBbbC4udV1cclxuICAgICAgICAgICAgICAgIGlmIChpIC0gbCA8IHUgLSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaiA9IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGwgPSBpICsgMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGogPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gdTtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gaiAtIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBUYWJsZUxpYi5hdXhzb3J0KEwsIGosIGkpOyAvLyBjYWxsIHJlY3Vyc2l2ZWx5IHRoZSBzbWFsbGVyIG9uZVxyXG4gICAgICAgICAgICB9IC8vIHJlcGVhdCB0aGUgcm91dGluZSBmb3IgdGhlIGxhcmdlciBvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIHNvcnRfY29tcChMLCBhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmICghTHVhXzEuTHVhLmlzTmlsKEwudmFsdWUoMikpKSAvLyBmdW5jdGlvbj9cclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEwucHVzaFZhbHVlKDIpO1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoT2JqZWN0KGEpO1xyXG4gICAgICAgICAgICAgICAgTC5wdXNoT2JqZWN0KGIpO1xyXG4gICAgICAgICAgICAgICAgTC5jYWxsKDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IEwudG9Cb29sZWFuKEwudmFsdWUoLTEpKTtcclxuICAgICAgICAgICAgICAgIEwucG9wKDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIC8vIGEgPCBiP1xyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEwubGVzc1RoYW4oYSwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGF1eF9nZXRuKEwsIG4pIHtcclxuICAgICAgICAgICAgTC5jaGVja1R5cGUobiwgTHVhXzEuTHVhLlRUQUJMRSk7XHJcbiAgICAgICAgICAgIHZhciB0ID0gTC52YWx1ZShuKTtcclxuICAgICAgICAgICAgcmV0dXJuIHQuZ2V0bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0ZJWE1FOiBhZGRlZFxyXG4gICAgICAgIHN0YXRpYyBnZXRuKEwpIHtcclxuICAgICAgICAgICAgTC5wdXNoTnVtYmVyKFRhYmxlTGliLmF1eF9nZXRuKEwsIDEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5UYWJsZUxpYiA9IFRhYmxlTGliO1xyXG4gICAgLy8gRWFjaCBmdW5jdGlvbiBpbiB0aGUgdGFibGUgbGlicmFyeSBjb3JyZXNwb25kcyB0byBhbiBpbnN0YW5jZSBvZlxyXG4gICAgLy8gdGhpcyBjbGFzcyB3aGljaCBpcyBhc3NvY2lhdGVkICh0aGUgJ3doaWNoJyBtZW1iZXIpIHdpdGggYW4gaW50ZWdlclxyXG4gICAgLy8gd2hpY2ggaXMgdW5pcXVlIHdpdGhpbiB0aGlzIGNsYXNzLiAgVGhleSBhcmUgdGFrZW4gZnJvbSB0aGUgZm9sbG93aW5nXHJcbiAgICAvLyBzZXQuICBcclxuICAgIFRhYmxlTGliLkNPTkNBVCA9IDE7XHJcbiAgICBUYWJsZUxpYi5JTlNFUlQgPSAyO1xyXG4gICAgVGFibGVMaWIuTUFYTiA9IDM7XHJcbiAgICBUYWJsZUxpYi5SRU1PVkUgPSA0O1xyXG4gICAgVGFibGVMaWIuU09SVCA9IDU7XHJcbiAgICBUYWJsZUxpYi5HRVROID0gNjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhYmxlTGliLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9TbG90XCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5VcFZhbCA9IHZvaWQgMDtcclxuICAgIGNvbnN0IFNsb3RfMSA9IHJlcXVpcmUoXCIuL1Nsb3RcIik7XHJcbiAgICAvKiAgJEhlYWRlcjogLy9pbmZvLnJhdmVuYnJvb2suY29tL3Byb2plY3QvamlsaS92ZXJzaW9uLzEuMS9jb2RlL21uai9sdWEvVXBWYWwuamF2YSMxICRcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwNiBOb2tpYSBDb3Jwb3JhdGlvbiBhbmQvb3IgaXRzIHN1YnNpZGlhcnkoLWllcykuXHJcbiAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gICAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgICAgKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICAgICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICAgICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0XHJcbiAgICAgKiB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgICpcclxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgICAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgICAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1JcclxuICAgICAqIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXHJcbiAgICAgKiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICAgICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gICAgICovXHJcbiAgICAvL3NlZSBqaWxsY29kZShKYXZhIEltcGxlbWVudGF0aW9uIG9mIEx1YSBMYW5ndWFnZSwgSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1xyXG4gICAgLy/ov5nph4znmoTku6PnoIHnp7vmpI3oh6pqaWxsY29kZShMdWHnmoRKYXZh5a6e546w77yMSmlsbCk6XHJcbiAgICAvL1x0aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ppbGxjb2RlL1x0XHJcbiAgICAvKipcclxuICAgICAqIE1vZGVscyBhbiB1cHZhbHVlLiAgVGhpcyBjbGFzcyBpcyBpbnRlcm5hbCB0byBKaWxsIGFuZCBzaG91bGQgbm90IGJlXHJcbiAgICAgKiB1c2VkIGJ5IGNsaWVudHMuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBhbmFsb2d1ZSBvZiB0aGUgVXBWYWwgdHlwZSBpbiBQVUMtUmlvJ3MgTHVhXHJcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiwgaGVuY2UgdGhlIG5hbWUuXHJcbiAgICAgKiBBbiBVcFZhbCBpbnN0YW5jZSBpcyBhIHJlZmVyZW5jZSB0byBhIHZhcmlhYmxlLlxyXG4gICAgICogV2hlbiBpbml0aWFsbHkgY3JlYXRlZCBnZW5lcmFsbHkgdGhlIHZhcmlhYmxlIGlzIGtlcHQgb24gdGhlIFZNXHJcbiAgICAgKiBzdGFjay4gIFdoZW4gdGhlIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyB0aGF0IHZhcmlhYmxlIHJldHVybnMsIHRoZVxyXG4gICAgICogY29ycmVzcG9uZGluZyBzdGFjayBzbG90cyBhcmUgZGVzdHJveWVkLiAgSW4gb3JkZXIgdGhhdCB0aGUgVXBWYWxcclxuICAgICAqIGNvbnRpbnVlcyB0byByZWZlcmVuY2UgdGhlIHZhcmlhYmxlLCBpdCBpcyBjbG9zZWQgKHVzaW5nIHRoZVxyXG4gICAgICogPGNvZGU+Y2xvc2U8L2NvZGU+IG1ldGhvZCkuICBMdWEgZnVuY3Rpb25zIHRoYXQgcmVmZXJlbmNlLCB2aWEgYW5cclxuICAgICAqIHVwdmFsdWUsIHRoZSBzYW1lIGluc3RhbmNlIG9mIHRoZSBzYW1lIHZhcmlhYmxlLCB3aWxsIHNoYXJlIGFuXHJcbiAgICAgKiA8Y29kZT5VcFZhbDwvY29kZT4gKHNvbWV3aGVyZSBpbiB0aGVpciA8Y29kZT51cHZhbDwvY29kZT4gYXJyYXlcclxuICAgICAqIG1lbWJlcik7IGhlbmNlIHRoZXkgc2hhcmUgdXBkYXRlcyB0byB0aGUgdmFyaWFibGUuXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIFVwVmFsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZyZXNoIHVwdmFsdWUgZnJvbSBhbiBvZmZzZXQsIGFuZCBhIHNsb3QuXHJcbiAgICAgICAgICogQ29uY2VwdHVhbGx5IDx2YXI+b2Zmc2V0PC92YXI+IGFuZCA8dmFyPnNsb3Q8L3Zhcj4gY29udmV5IHRoZSBzYW1lXHJcbiAgICAgICAgICogaW5mb3JtYXRpb24sIG9ubHkgb25lIGlzIG5lY2Vzc2FyeSBzaW5jZSB0aGUgb2Zmc2V0IGltcGxpZXMgdGhlXHJcbiAgICAgICAgICogc2xvdCBhbmQgdmljZS12ZXJzYS4gIDx2YXI+c2xvdDwvdmFyPiBpcyB1c2VkIHRvIGRpcmVjdGx5IHJlZmVyZW5jZVxyXG4gICAgICAgICAqIHRoZSB2YWx1ZSAodGhpcyBhdm9pZHMgYW4gaW5kaXJlY3Rpb24gdG8gdGhlIFZNIHN0YWNrKS4gPHZhcj5vZmZzZXQ8L3Zhcj5cclxuICAgICAgICAgKiBpcyB1c2VkIHdoZW4gc2VhcmNoaW5nIGZvciBVcFZhbHMgaW4gdGhlIG9wZW51cHZhbCBsaXN0OyB0aGlzXHJcbiAgICAgICAgICogaGFwcGVucyB3aGVuIGNsb3NpbmcgVXBWYWxzIChmdW5jdGlvbiByZXR1cm4pIG9yIGNyZWF0aW5nIHRoZW1cclxuICAgICAgICAgKiAoZXhlY3V0aW9uIG9mIGZ1bmN0b24gZGVjbGFyYXRpb24pLlxyXG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXQgIGluZGV4IGludG8gTHVhIHRocmVhZCdzIFZNIHN0YWNrLCBtdXN0IGJlIGEgdmFsaWQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHMgIFNsb3QgY29ycmVzcG9uZGluZyB0byBvZmZzZXQuXHJcbiAgICAgICAgICogQHRocm93cyBOdWxsUG9pbnRlckV4Y2VwdGlvbiBpZiBMIGlzIG51bGwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3RydWN0b3Iob2Zmc2V0LCBzKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgb2Zmc2V0IGZpZWxkLiAgU3RvcmVkIGhlcmUsIGJ1dCBub3QgYWN0dWFsbHkgdXNlZCBkaXJlY3RseSBieVxyXG4gICAgICAgICAgICAgKiB0aGlzIGNsYXNzLlxyXG4gICAgICAgICAgICAgKiBVc2VkIChieSB7QGxpbmsgTHVhfSkgd2hlbiBzZWFyY2hpbmcgZm9yIHtAbGluayBVcFZhbH0gaW5zdGFuY2VzLlxyXG4gICAgICAgICAgICAgKiBBbiBvcGVuIFVwVmFsIGhhcyBhIHZhbGlkIG9mZnNldCBmaWVsZC4gIEl0cyBzbG90IGlzIHNoYXJlZFxyXG4gICAgICAgICAgICAgKiB3aXRoIGEgc2xvdCBvZiB0aGUgVk0gc3RhY2suXHJcbiAgICAgICAgICAgICAqIEEgY2xvc2VkIFVwVmFsIGhhcyBvZmZzZXQgPT0gLTEuICBJdCdzIHNsb3Qgd2lsbCBiZSBhIGZyZXNoIGNvcHlcclxuICAgICAgICAgICAgICogYW5kIG5vdCBzaGFyZWQgd2l0aCBhbnkgb3RoZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3MgPSBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXR0ZXIgZm9yIHVuZGVybHlpbmcgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcy5hc09iamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXR0ZXIgZm9yIHVuZGVybHlpbmcgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0IHZhbHVlKG8pIHtcclxuICAgICAgICAgICAgdGhpcy5fcy5zZXRPYmplY3Qobyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvZmZzZXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IG9mZnNldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xvc2VzIGFuIFVwVmFsLiAgVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHN0b3JhZ2Ugb3BlcmF0ZWQgb24gYnlcclxuICAgICAgICAgKiB7QGxpbmsgI2dldFZhbHVlKCkgZ2V0VmFsdWV9IGFuZCB7QGxpbmsgI3NldFZhbHVlKE9iamVjdCkgc2V0VmFsdWV9XHJcbiAgICAgICAgICogaXMgbm90IHNoYXJlZCBieSBhbnkgb3RoZXIgb2JqZWN0LlxyXG4gICAgICAgICAqIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgd2hlbiBhIGZ1bmN0aW9uIHJldHVybnMgKGV4ZWN1dGVzXHJcbiAgICAgICAgICogdGhlIDxjb2RlPk9QX1JFVDwvY29kZT4gVk0gaW5zdHJ1Y3Rpb24pLiAgRWZmZWN0aXZlbHkgdGhpc1xyXG4gICAgICAgICAqIHRyYW5zZmVycyBhIHZhcmlhYmxlIGJpbmRpbmcgZnJvbSB0aGUgc3RhY2sgdG8gdGhlIGhlYXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICAgIHZhciBfczIgPSB0aGlzLl9zO1xyXG4gICAgICAgICAgICB0aGlzLl9zID0gbmV3IFNsb3RfMS5TbG90KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3MuaW5pdDEoX3MyKTtcclxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5VcFZhbCA9IFVwVmFsO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXBWYWwuanMubWFwIl19
